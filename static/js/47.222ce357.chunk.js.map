{"version":3,"sources":["../node_modules/@material-ui/core/Drawer/index.js","../node_modules/@material-ui/icons/ChevronRight.js","../node_modules/@material-ui/icons/ChevronLeft.js","../node_modules/@material-ui/icons/Person.js","../node_modules/@material-ui/core/ListItemSecondaryAction/index.js","../node_modules/@material-ui/core/ListItemSecondaryAction/ListItemSecondaryAction.js","../node_modules/@material-ui/icons/Send.js","../node_modules/recordrtc/RecordRTC.js","../node_modules/@material-ui/icons/People.js","../node_modules/react-router/es/generatePath.js","../node_modules/react-router/es/Redirect.js","../node_modules/react-router-dom/es/Redirect.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","enumerable","get","_Drawer","default","_react","_default","createElement","Fragment","d","fill","_ListItemSecondaryAction","styles","_extends2","_objectWithoutProperties2","_classnames","_withStyles","root","position","right","top","transform","ListItemSecondaryAction","props","children","classes","className","other","muiName","name","RecordRTC","mediaStream","config","RecordRTCConfiguration","type","self","this","initRecorder","initCallback","Recorder","GetRecorderType","mediaRecorder","record","setState","disableLogs","console","log","constructor","stopRecording","callback","state","resumeRecording","setTimeout","warn","stop","_callback","warningLog","__blob","keys","forEach","key","blob","bytesToSize","size","url","URL","createObjectURL","e","call","autoWriteToDisk","getDataURL","dataURL","parameter","DiskStorage","Store","readFile","_blob","postMessage","FileReaderSync","readAsDataURL","_mediaRecorder","Worker","navigator","mozGetUserMedia","reader","FileReader","onload","event","target","result","webWorker","_function","Blob","toString","worker","revokeObjectURL","processInWebWorker","onmessage","data","handleRecordingDuration","counter","recordingDuration","onRecordingStopped","onStateChanged","WARNING","returnObject","startRecording","config2","version","clearRecordedData","pauseRecording","pause","resume","setRecordingDuration","getBlob","toURL","getInternalRecorder","save","fileName","invokeSaveAsDialog","getFromDisk","setAdvertisementArray","arrayOfWebPImages","advertisement","length","i","push","duration","image","bufferSize","sampleRate","buffer","reset","getState","destroy","disableLogsCache","Storage","AudioContextConstructor","close","prop","recorderType","audio","video","WhammyRecorder","CanvasRecorder","WebAssemblyRecorder","GifRecorder","StereoAudioRecorder","MediaStreamRecorder","getTracks","MediaRecorder","prototype","mimeType","split","bitsPerSecond","recorder","isChrome","isEdge","isOpera","ReadableStream","isMediaRecorderCompatible","isTypeSupported","Array","MultiStreamRecorder","isSafari","MRecordRTC","addStream","_mediaStream","mediaType","gif","audioRecorder","numberOfAudioChannels","timeSlice","onTimeStamp","newStream","videoTrack","isFirefox","MediaStream","addTrack","videoRecorder","canvas","frameInterval","workerPath","webAssemblyPath","frameRate","bitrate","isSingleRecorder","gifRecorder","quality","blobURL","output","callback00","webkitURL","_audioDataURL","_videoDataURL","writeToDisk","args","module","Fetch","_type","replace","options","audioDataURL","videoDataURL","gifDataURL","audioBlob","videoBlob","gifBlob","that","global","window","userAgent","getUserMedia","error","arguments","document","documentElement","appendChild","captureStream","mozCaptureStream","obj","getContext","play","drawImage","toDataURL","style","HTMLVideoElement","location","protocol","href","hash","screen","width","height","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","lastTime","element","currTime","Date","getTime","timeToCall","Math","max","id","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","msCancelAnimationFrame","clearTimeout","AudioContext","webkitAudioContext","mozAudioContext","webkitGetUserMedia","indexOf","msSaveBlob","msSaveOrOpenBlob","opera","toLowerCase","test","isElectron","bytes","parseInt","floor","pow","toPrecision","file","fileExtension","splitted","fileFullName","round","random","hyperlink","download","body","click","dispatchEvent","MouseEvent","view","bubbles","cancelable","process","versions","electron","stream","kind","filter","t","setSrcObject","srcObject","mozSrcObject","webkitMediaStream","track","getSeekableBlob","inputBlob","EBML","Error","Reader","decoder","Decoder","tools","fileReader","decode","read","refinedMetadataBuf","makeMetadataSeekable","metadatas","cues","slice","metadataSize","newBlob","readAsArrayBuffer","appVersion","verOffset","ix","nAgt","fullVersion","parseFloat","majorVersion","substring","isNaN","arrayOfBlobs","updateTimeStamp","timestamps","getMimeType","secondObject","clearRecordedDataCB","getArrayOfBlobs","allStates","recorderHints","canRecordMimeType","ondataavailable","recordingCallback","getNativeBlob","onstart","onpause","onresume","onstop","onerror","looper","manuallyStopped","timeslice","start","getAllStates","checkForInactiveTracks","active","ended","isMediaStreamActive","jsAudioNode","leftchannel","rightchannel","recording","recordingLength","desiredSampRate","mergeLeftRightBuffers","mergeAudioBuffers","cb","interleaved","leftBuffers","rightBuffers","internalInterleavedLength","interpolateArray","newSampleRate","oldSampleRate","fitCount","newData","springFactor","Number","tmp","before","toFixed","after","ceil","atPoint","linearInterpolate","mergeBuffers","channelBuffer","rLength","Float64Array","offset","lng","set","writeUTFBytes","string","setUint8","charCodeAt","leftChannel","rightChannel","inputIndex","index","interleave","interleavedLength","ArrayBuffer","DataView","setUint32","setUint16","setInt16","noWorker","workerURL","terminate","resetVariables","isAudioProcessStarted","isPaused","byteLength","context","audioInput","createMediaStreamSource","legalBufferValues","JSON","stringify","createJavaScriptNode","createScriptProcessor","connect","intervalsBasedBuffers","left","onaudioprocess","disconnect","onAudioProcessStarted","inputBuffer","getChannelData","chLeft","Float32Array","chRight","createMediaStreamDestination","destination","htmlElement","html2canvas","isCanvasSupportsStreamCapturing","item","globalCanvas","mediaStreamRecorder","isRecording","_isChrome","webkitRTCPeerConnection","chrome","chromeVersion","matchArray","match","useWhammyRecorder","HTMLCanvasElement","CanvasRenderingContext2D","canvasMediaStream","webkitCaptureStream","mdStream","whammy","frames","drawCanvasFrame","getWebPImages","nodeName","framesLength","frame","idx","framesRemaining","onEncodingCallback","webp","compile","isPausedRecording","cloneCanvas","newCanvas","grabMouse","showMousePointer","onrendered","Whammy","Video","drawFrames","paused","isStopDrawing","dropBlackFrames","_frames","_framesToCheck","_pixTolerance","_frameTolerance","localCanvas","context2d","resultFrames","checkUntilNotBlack","endCheckFrame","sampleColor","maxColorDifference","sqrt","pixTolerance","frameTolerance","doNotCheckNext","o","loop","functionToLoop","asyncLoop","f","matchPixCount","endPixCheck","maxPixCount","finishImage","Image","imageData","getImageData","pix","currentColor","r","g","b","src","concat","cloneNode","onloadedmetadata","muted","_this","WhammyVideo","whammyInWebWorker","getClusterData","clusterTimecode","clusterCounter","clusterFrames","map","block","flags","keyframe","invisible","lacing","discardable","trackNum","timecode","String","fromCharCode","join","makeSimpleBlock","numToBuffer","num","parts","Uint8Array","reverse","bitsToBuffer","bits","substr","getStrLength","unpadded","webm","info","checkFrames","frameNumber","clusterDuration","cluster","generateEBML","json","ebml","len","zeroes","sizeToString","padded","riff","VP8","RIFF","WEBP","frameStart","c","parseWebP","parseRIFF","chunks","atob","add","init","indexedDB","open","db","dbName","request","onError","onsuccess","setVersion","createObjectStore","putInDB","onupgradeneeded","dataBase","dataStoreName","transaction","getFromStore","portionName","objectStore","put","GIFEncoder","script","isHTMLObject","isLoadedMetaData","offsetWidth","offsetHeight","gifEncoder","setRepeat","setDelay","setQuality","onGifRecordingStarted","now","lastAnimationFrame","drawVideoFrame","time","clearedRecordedData","undefined","lastFrameTime","onGifPreview","addFrame","bin","autoplay","playsInline","MultiStreamsMixer","arrayOfMediaStreams","elementClass","videos","isStopDrawingFrames","opacity","zIndex","useGainNode","drawVideosToCanvas","videosLength","fullcanvas","remaining","x","y","onRender","getVideo","volume","resetVideoStreams","streams","startDrawingFrames","appendStreams","audioSource","audioContext","audioDestination","releaseStreams","gainNode","audioSources","source","clearRect","getMixedStream","mixedVideoStream","capturedStream","videoStream","getMixedVideoStream","mixedAudioStream","createGain","gain","audioTracksLength","getMixedAudioStream","mixer","tracks","getAllVideoTracks","previewStream","addStreams","getMixer","cameraStream","controller","cvs","onplaying","ctx","frameTimeout","enqueue","WritableStream","arrayOfBuffers","addEventListener","timebaseDen","realtime","pipeTo","write","fetch","then","arrayBuffer","RecordRTCPromisesHandler","recordRTC","Promise","resolve","reject","patternCache","cacheCount","compileGenerator","pattern","cacheKey","cache","compiledGenerator","pathToRegexp","generatePath","params","generator","pretty","_extends","assign","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","Redirect","_React$Component","apply","subClass","superClass","create","writable","configurable","setPrototypeOf","__proto__","_inherits","isStatic","router","staticContext","componentWillMount","invariant","perform","componentDidMount","componentDidUpdate","prevProps","prevTo","createLocation","to","nextTo","locationsAreEqual","warning","pathname","search","computeTo","_ref","computedMatch","history","render","React","Component","propTypes","PropTypes","object","bool","from","oneOfType","isRequired","defaultProps","contextTypes","shape","func"],"mappings":";2FAEA,IAAIA,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETH,OAAOC,eAAeC,EAAS,UAAW,CACxCE,YAAY,EACZC,IAAK,WACH,OAAOC,EAAQC,WAInB,IAAID,EAAUR,EAAuBC,EAAQ,O,iCCZ7C,IAAID,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQK,aAAU,EAElB,IAAIC,EAASV,EAAuBC,EAAQ,IAIxCU,GAAW,EAFMX,EAAuBC,EAAQ,KAElBQ,SAASC,EAAOD,QAAQG,cAAcF,EAAOD,QAAQI,SAAU,KAAMH,EAAOD,QAAQG,cAAc,OAAQ,CAC1IE,EAAG,mDACDJ,EAAOD,QAAQG,cAAc,OAAQ,CACvCG,KAAM,OACND,EAAG,mBACA,gBAELV,EAAQK,QAAUE,G,iCClBlB,IAAIX,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQK,aAAU,EAElB,IAAIC,EAASV,EAAuBC,EAAQ,IAIxCU,GAAW,EAFMX,EAAuBC,EAAQ,KAElBQ,SAASC,EAAOD,QAAQG,cAAcF,EAAOD,QAAQI,SAAU,KAAMH,EAAOD,QAAQG,cAAc,OAAQ,CAC1IE,EAAG,kDACDJ,EAAOD,QAAQG,cAAc,OAAQ,CACvCG,KAAM,OACND,EAAG,mBACA,eAELV,EAAQK,QAAUE,G,iCClBlB,IAAIX,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQK,aAAU,EAElB,IAAIC,EAASV,EAAuBC,EAAQ,IAIxCU,GAAW,EAFMX,EAAuBC,EAAQ,KAElBQ,SAASC,EAAOD,QAAQG,cAAcF,EAAOD,QAAQI,SAAU,KAAMH,EAAOD,QAAQG,cAAc,OAAQ,CAC1IE,EAAG,kHACDJ,EAAOD,QAAQG,cAAc,OAAQ,CACvCG,KAAM,OACND,EAAG,mBACA,UAELV,EAAQK,QAAUE,G,iCClBlB,IAAIX,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETH,OAAOC,eAAeC,EAAS,UAAW,CACxCE,YAAY,EACZC,IAAK,WACH,OAAOS,EAAyBP,WAIpC,IAAIO,EAA2BhB,EAAuBC,EAAQ,O,iCCZ9D,IAAID,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQK,QAAUL,EAAQa,YAAS,EAEnC,IAAIC,EAAYlB,EAAuBC,EAAQ,IAE3CkB,EAA4BnB,EAAuBC,EAAQ,IAE3DS,EAASV,EAAuBC,EAAQ,IAIxCmB,GAFapB,EAAuBC,EAAQ,IAE9BD,EAAuBC,EAAQ,MAE7CoB,EAAcrB,EAAuBC,EAAQ,KAE7CgB,EAAS,CAEXK,KAAM,CACJC,SAAU,WACVC,MAAO,EACPC,IAAK,MACLC,UAAW,qBASf,SAASC,EAAwBC,GAC/B,IAAIC,EAAWD,EAAMC,SACjBC,EAAUF,EAAME,QAChBC,EAAYH,EAAMG,UAClBC,GAAQ,EAAIb,EAA0BV,SAASmB,EAAO,CAAC,WAAY,UAAW,cAClF,OAAOlB,EAAOD,QAAQG,cAAc,OAAO,EAAIM,EAAUT,SAAS,CAChEsB,WAAW,EAAIX,EAAYX,SAASqB,EAAQR,KAAMS,IACjDC,GAAQH,GATbzB,EAAQa,OAASA,EA6BjBU,EAAwBM,QAAU,0BAElC,IAAItB,GAAW,EAAIU,EAAYZ,SAASQ,EAAQ,CAC9CiB,KAAM,8BADO,CAEZP,GAEHvB,EAAQK,QAAUE,G,iCCnElB,IAAIX,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQK,aAAU,EAElB,IAAIC,EAASV,EAAuBC,EAAQ,IAIxCU,GAAW,EAFMX,EAAuBC,EAAQ,KAElBQ,SAASC,EAAOD,QAAQG,cAAcF,EAAOD,QAAQI,SAAU,KAAMH,EAAOD,QAAQG,cAAc,OAAQ,CAC1IE,EAAG,0CACDJ,EAAOD,QAAQG,cAAc,OAAQ,CACvCG,KAAM,OACND,EAAG,mBACA,QAELV,EAAQK,QAAUE,G,kCCpBlB,oBAoCA,SAASwB,EAAUC,EAAaC,GAC5B,IAAKD,EACD,KAAM,+BAOVC,EAAS,IAAIC,EAAuBF,EAJpCC,EAASA,GAAU,CACfE,KAAM,UAMV,IAAIC,EAAOC,KAsCX,SAASC,EAAaC,GACdA,IACAN,EAAOM,aAAe,WAClBA,IACAA,EAAeN,EAAOM,aAAe,OAI7C,IAAIC,EAAW,IAAIC,EAAgBT,EAAaC,IAEhDS,EAAgB,IAAIF,EAASR,EAAaC,IAC5BU,SAEdC,EAAS,aAEJX,EAAOY,aACRC,QAAQC,IAAI,4BAA6BL,EAAcM,YAAYlB,KAAM,mBAAoBG,EAAOE,MAI5G,SAASc,EAAcC,GAGnB,GAFAA,EAAWA,GAAY,aAElBR,EAAL,CAKA,GAAmB,WAAfN,EAAKe,MAML,OALAf,EAAKgB,uBAELC,YAAW,WACPJ,EAAcC,KACf,GAIY,cAAfd,EAAKe,OAA0BlB,EAAOY,aACtCC,QAAQQ,KAAK,qEAAsElB,EAAKe,OAGvFlB,EAAOY,aACRC,QAAQC,IAAI,qBAAuBd,EAAOE,KAAO,YAGjC,QAAhBF,EAAOE,KACPO,EAAca,KAAKC,IAEnBd,EAAca,OACdC,KAGJZ,EAAS,gBA5BLa,IA8BJ,SAASD,EAAUE,GACf,GAAKhB,EAAL,CASA5C,OAAO6D,KAAKjB,GAAekB,SAAQ,SAASC,GACN,oBAAvBnB,EAAcmB,KAIzBzB,EAAKyB,GAAOnB,EAAcmB,OAG9B,IAAIC,EAAOpB,EAAcoB,KAEzB,IAAKA,EAAM,CACP,IAAIJ,EAGA,KAAM,oBAFNhB,EAAcoB,KAAOA,EAAOJ,EAUpC,GAJII,IAAS7B,EAAOY,aAChBC,QAAQC,IAAIe,EAAK3B,KAAM,KAAM4B,EAAYD,EAAKE,OAG9Cd,EAAU,CACV,IAAIe,EAEJ,IACIA,EAAMC,EAAIC,gBAAgBL,GAC5B,MAAOM,IAEoB,oBAAlBlB,EAASmB,KAChBnB,EAASmB,KAAKjC,EAAM6B,GAEpBf,EAASe,GAIZhC,EAAOqC,iBAIZC,GAAW,SAASC,GAChB,IAAIC,EAAY,GAChBA,EAAUxC,EAAOE,KAAO,QAAUqC,EAClCE,EAAYC,MAAMF,UAnDW,oBAAlBvB,EAASmB,KAChBnB,EAASmB,KAAKjC,EAAM,IAEpBc,EAAS,KAkGzB,SAAS0B,EAASC,GACdC,aAAY,IAAIC,gBAAiBC,cAAcH,IAGnD,SAASN,EAAWrB,EAAU+B,GAC1B,IAAK/B,EACD,KAAM,4CAGV,IAAIY,EAAOmB,EAAiBA,EAAenB,MAAQpB,GAAiB,IAAIoB,KAExE,IAAKA,EAQD,OAPK7B,EAAOY,aACRC,QAAQQ,KAAK,iDAGjBD,YAAW,WACPkB,EAAWrB,EAAU+B,KACtB,KAIP,GAAsB,qBAAXC,QAA2BC,UAAUC,gBAQzC,CACH,IAAIC,EAAS,IAAIC,WACjBD,EAAOL,cAAclB,GACrBuB,EAAOE,OAAS,SAASC,GACrBtC,EAASsC,EAAMC,OAAOC,aAZmC,CAC7D,IAAIC,EAeR,SAA4BC,GACxB,IACI,IAAI9B,EAAOI,EAAIC,gBAAgB,IAAI0B,KAAK,CAACD,EAAUE,WAC/C,qCAAuCF,EAAU9D,KAAO,gBACzD,CACCK,KAAM,4BAGN4D,EAAS,IAAIb,OAAOpB,GAExB,OADAI,EAAI8B,gBAAgBlC,GACbiC,EACT,MAAO3B,KA1BO6B,CAAmBrB,GAEnCe,EAAUO,UAAY,SAASV,GAC3BtC,EAASsC,EAAMW,OAGnBR,EAAUb,YAAYhB,IAwB9B,SAASsC,EAAwBC,GAC7BA,EAAUA,GAAW,EAEF,WAAfjE,EAAKe,MAOU,YAAff,EAAKe,QAILkD,GAAWjE,EAAKkE,kBAChBrD,EAAcb,EAAKmE,qBAIvBF,GAAW,IAEXhD,YAAW,WACP+C,EAAwBC,KACzB,OAnBChD,YAAW,WACP+C,EAAwBC,KACzB,KAoBX,SAASzD,EAASO,GACTf,IAILA,EAAKe,MAAQA,EAE2B,oBAA7Bf,EAAKoE,eAAenC,KAC3BjC,EAAKoE,eAAenC,KAAKjC,EAAMe,GAE/Bf,EAAKoE,eAAerD,IAI5B,IAUIT,EAVA+D,EAAU,8EAAgFxE,EAAOE,KAAO,aAE5G,SAASsB,KACsB,IAAvBxB,EAAOY,aAIXC,QAAQQ,KAAKmD,GAKjB,IAAIC,EAAe,CAYfC,eAtTJ,SAAwBC,GAepB,OAdK3E,EAAOY,aACRC,QAAQC,IAAI,sBAAuBX,EAAKyE,SAGtCD,IAGF3E,EAAS,IAAIC,EAAuBF,EAAa4E,IAGhD3E,EAAOY,aACRC,QAAQC,IAAI,qBAAuBd,EAAOE,KAAO,YAGjDO,GACAA,EAAcoE,oBACdpE,EAAcC,SAEdC,EAAS,aAELR,EAAKkE,mBACLF,IAEGhE,IAGXE,GAAa,WACLF,EAAKkE,mBACLF,OAIDhE,IAoSPa,cAAeA,EAYf8D,eA7LJ,WACSrE,EAKc,cAAfN,EAAKe,OAOTP,EAAS,UAETF,EAAcsE,QAET/E,EAAOY,aACRC,QAAQC,IAAI,sBAXPd,EAAOY,aACRC,QAAQQ,KAAK,mDAAoDlB,EAAKe,OAN1EM,KAsMJL,gBAlLJ,WACSV,EAKc,WAAfN,EAAKe,OAOTP,EAAS,aAGTF,EAAcuE,SAEThF,EAAOY,aACRC,QAAQC,IAAI,uBAZPd,EAAOY,aACRC,QAAQQ,KAAK,oDAAqDlB,EAAKe,OAN3EM,KA2LJnB,aAAcA,EAoBd4E,qBAAsB,SAASZ,EAAmBpD,GAC9C,GAAiC,qBAAtBoD,EACP,KAAM,iCAGV,GAAiC,kBAAtBA,EACP,KAAM,sCAMV,OAHAlE,EAAKkE,kBAAoBA,EACzBlE,EAAKmE,mBAAqBrD,GAAY,aAE/B,CACHqD,mBAAoB,SAASrD,GACzBd,EAAKmE,mBAAqBrD,KActC4D,kBAAmB,WACVpE,GAKLA,EAAcoE,oBAET7E,EAAOY,aACRC,QAAQC,IAAI,+BAPZU,KA8BR0D,QAAS,WACL,GAAKzE,EAKL,OAAOA,EAAcoB,KAJjBL,KAoBRc,WAAYA,EAaZ6C,MAAO,WACH,GAAK1E,EAKL,OAAOwB,EAAIC,gBAAgBzB,EAAcoB,MAJrCL,KAoBR4D,oBAAqB,WACjB,OAAO3E,GAiBX4E,KAAM,SAASC,GACN7E,EAKL8E,EAAmB9E,EAAcoB,KAAMyD,GAJnC9D,KAkBRgE,YAAa,SAASvE,GACbR,EAKLX,EAAU0F,YAAYxF,EAAOE,KAAMe,GAJ/BO,KAuBRiE,sBAAuB,SAASC,GAC5B1F,EAAO2F,cAAgB,GAGvB,IADA,IAAIC,EAASF,EAAkBE,OACtBC,EAAI,EAAGA,EAAID,EAAQC,IACxB7F,EAAO2F,cAAcG,KAAK,CACtBC,SAAUF,EACVG,MAAON,EAAkBG,MAmBrChE,KAAM,KAaNoE,WAAY,EAaZC,WAAY,EAcZC,OAAQ,KAWRC,MAAO,WACgB,cAAfjG,EAAKe,OAA0BlB,EAAOY,aACtCC,QAAQQ,KAAK,4BAGbZ,GAA4D,oBAApCA,EAAcoE,mBACtCpE,EAAcoE,oBAElBpE,EAAgB,KAChBE,EAAS,YACTR,EAAK0B,KAAO,MAchB0C,eAAgB,SAASrD,GAChBlB,EAAOY,aACRC,QAAQC,IAAI,0BAA2BI,IAmB/CA,MAAO,WAUPmF,SAAU,WACN,OAAOlG,EAAKe,OAUhBoF,QAAS,WACL,IAAIC,EAAmBvG,EAAOY,YAE9BZ,EAAS,CACLY,aAAa,GAEjBT,EAAKiG,QACLzF,EAAS,aACT8D,EAAetE,EAAO,KAElBqG,EAAQC,0BACRD,EAAQC,wBAAwBC,QAChCF,EAAQC,wBAA0B,MAGtCzG,EAAOY,YAAc2F,EAEhBvG,EAAOY,aACRC,QAAQC,IAAI,4BAapB8D,QAAS,SAGb,IAAKxE,KAED,OADAD,EAAOsE,EACAA,EAIX,IAAK,IAAIkC,KAAQlC,EACbrE,KAAKuG,GAAQlC,EAAakC,GAK9B,OAFAxG,EAAOC,KAEAqE,EA4HX,SAASxE,EAAuBF,EAAaC,GAqDzC,OApDKA,EAAO4G,cAAiB5G,EAAOE,OAC1BF,EAAO6G,OAAW7G,EAAO8G,MAC3B9G,EAAOE,KAAO,QACLF,EAAO6G,QAAU7G,EAAO8G,QACjC9G,EAAOE,KAAO,UAIlBF,EAAO4G,eAAiB5G,EAAOE,OAC3BF,EAAO4G,eAAiBG,GAAkB/G,EAAO4G,eAAiBI,GAAiEhH,EAAO4G,eAAiBK,EAC3JjH,EAAOE,KAAO,QACPF,EAAO4G,eAAiBM,EAC/BlH,EAAOE,KAAO,MACPF,EAAO4G,eAAiBO,EAC/BnH,EAAOE,KAAO,QACPF,EAAO4G,eAAiBQ,IAC3BC,EAAUtH,EAAa,SAAS6F,QAAUyB,EAAUtH,EAAa,SAAS6F,SAElEyB,EAAUtH,EAAa,SAAS6F,QAAUyB,EAAUtH,EAAa,SAAS6F,OADlF5F,EAAOE,KAAO,QAGPmH,EAAUtH,EAAa,SAAS6F,SAAWyB,EAAUtH,EAAa,SAAS6F,SAClF5F,EAAOE,KAAO,WAOiD,qBAAlBoH,eAAiC,gBAAiBA,cAAcC,YAChHvH,EAAOwH,WACRxH,EAAOwH,SAAW,cAGjBxH,EAAOE,OACRF,EAAOE,KAAOF,EAAOwH,SAASC,MAAM,KAAK,IAGxCzH,EAAO0H,eAMX1H,EAAOE,OACJF,EAAOwH,WACPxH,EAAOE,KAAOF,EAAOwH,SAASC,MAAM,KAAK,IAExCzH,EAAOE,OACRF,EAAOE,KAAO,UAIfF,EAqBX,SAASQ,EAAgBT,EAAaC,GAClC,IAAI2H,EAkEJ,OA9DIC,GAAYC,GAAUC,KAGtBH,EAAWR,GAGc,qBAAlBG,eAAiC,gBAAiBA,cAAcC,YAAcK,IACrFD,EAAWP,GAIK,UAAhBpH,EAAOE,OAAqB0H,GAAYE,KACxCH,EAAWZ,EAEiE,qBAAnBgB,iBACrDJ,EAAWV,IAKC,QAAhBjH,EAAOE,OACPyH,EAAWT,GAIK,WAAhBlH,EAAOE,OACPyH,EAAWX,GAGXgB,KAA+BL,IAAaX,GAAkBW,IAAaT,GAAwC,qBAAlBI,eAAiC,gBAAiBA,cAAcC,YAC7JF,EAAUtH,EAAa,SAAS6F,QAAUyB,EAAUtH,EAAa,SAAS6F,UAEtD,UAAhB5F,EAAOE,KACsC,oBAAlCoH,cAAcW,iBAAkCX,cAAcW,gBAAgB,gBACrFN,EAAWP,GAK8B,oBAAlCE,cAAcW,iBAAkCX,cAAcW,gBAAgB,gBACrFN,EAAWP,IAMvBrH,aAAuBmI,OAASnI,EAAY6F,SAC5C+B,EAAWQ,GAGXnI,EAAO4G,eACPe,EAAW3H,EAAO4G,eAGjB5G,EAAOY,aAAiB+G,GAAcA,EAAS9H,MAChDgB,QAAQC,IAAI,sBAAuB6G,EAAS9H,MAAQ8H,EAAS5G,YAAYlB,OAGxE8H,GAAYS,IACbT,EAAWP,GAGRO,EAkCX,SAASU,EAAWtI,GAUhBK,KAAKkI,UAAY,SAASC,GAClBA,IACAxI,EAAcwI,IAgBtBnI,KAAKoI,UAAY,CACb3B,OAAO,EACPC,OAAO,GAUX1G,KAAKsE,eAAiB,WAClB,IACIkC,EADA4B,EAAYpI,KAAKoI,UAEjBhB,EAAWpH,KAAKoH,UAAY,CAC5BX,MAAO,KACPC,MAAO,KACP2B,IAAK,MAeT,GAZ+B,oBAApBD,EAAU3B,OAAwBmB,MAAgCX,EAAUtH,EAAa,SAAS6F,SACzG4C,EAAU3B,OAAQ,GAGS,oBAApB2B,EAAU1B,OAAwBkB,MAAgCX,EAAUtH,EAAa,SAAS6F,SACzG4C,EAAU1B,OAAQ,GAGO,oBAAlB0B,EAAUC,KAAsBT,MAAgCX,EAAUtH,EAAa,SAAS6F,SACvG4C,EAAUC,KAAM,IAGfD,EAAU3B,QAAU2B,EAAU1B,QAAU0B,EAAUC,IACnD,KAAM,sDA0BV,GAvBMD,EAAU3B,QACZD,EAAe,KACgB,oBAApB4B,EAAU3B,QACjBD,EAAe4B,EAAU3B,OAG7BzG,KAAKsI,cAAgB,IAAI5I,EAAUC,EAAa,CAC5CG,KAAM,QACN+F,WAAY7F,KAAK6F,WACjBC,WAAY9F,KAAK8F,WACjByC,sBAAuBvI,KAAKuI,uBAAyB,EACrD/H,YAAaR,KAAKQ,YAClBgG,aAAcA,EACdY,SAAUA,EAASX,MACnB+B,UAAWxI,KAAKwI,UAChBC,YAAazI,KAAKyI,cAGjBL,EAAU1B,OACX1G,KAAKsI,cAAchE,kBAIrB8D,EAAU1B,MAAO,CACnBF,EAAe,KACgB,oBAApB4B,EAAU1B,QACjBF,EAAe4B,EAAU1B,OAG7B,IAAIgC,EAAY/I,EAEhB,GAAIiI,KAAiCQ,EAAU3B,OAAoC,oBAApB2B,EAAU3B,MAAsB,CAC3F,IAAIkC,EAAa1B,EAAUtH,EAAa,SAAS,GAE7CiJ,IACAF,EAAY,IAAIG,GACNC,SAASH,GAEfnC,GAAgBA,IAAiBG,IAGjCH,EAAeQ,KAGnB0B,EAAY,IAAIG,GACNC,SAASH,GAI3B3I,KAAK+I,cAAgB,IAAIrJ,EAAUgJ,EAAW,CAC1C5I,KAAM,QACN4G,MAAO1G,KAAK0G,MACZsC,OAAQhJ,KAAKgJ,OACbC,cAAejJ,KAAKiJ,eAAiB,GACrCzI,YAAaR,KAAKQ,YAClBgG,aAAcA,EACdY,SAAUA,EAASV,MACnB8B,UAAWxI,KAAKwI,UAChBC,YAAazI,KAAKyI,YAClBS,WAAYlJ,KAAKkJ,WACjBC,gBAAiBnJ,KAAKmJ,gBACtBC,UAAWpJ,KAAKoJ,UAChBC,QAASrJ,KAAKqJ,UAGbjB,EAAU3B,OACXzG,KAAK+I,cAAczE,iBAI3B,GAAM8D,EAAU3B,OAAW2B,EAAU1B,MAAO,CACxC,IAAI3G,EAAOC,KAEPsJ,GAAmD,IAAhC1B,KAEnBQ,EAAU3B,iBAAiBM,GAAyBqB,EAAU1B,QAEnC,IAApB0B,EAAU3B,QAAsC,IAApB2B,EAAU1B,OAAkB0B,EAAU3B,QAAU2B,EAAU1B,SAD7F4C,GAAmB,IAKE,IAArBA,GACAvJ,EAAKuI,cAAgB,KACrBvI,EAAKgJ,cAAczE,kBAEnBvE,EAAKgJ,cAAc9I,cAAa,WAC5BF,EAAKuI,cAAcrI,cAAa,WAE5BF,EAAKgJ,cAAczE,iBACnBvE,EAAKuI,cAAchE,uBAM7B8D,EAAUC,MACZ7B,EAAe,KACc,oBAAlB4B,EAAUC,MACjB7B,EAAe4B,EAAUC,KAE7BrI,KAAKuJ,YAAc,IAAI7J,EAAUC,EAAa,CAC1CG,KAAM,MACNsJ,UAAWpJ,KAAKoJ,WAAa,IAC7BI,QAASxJ,KAAKwJ,SAAW,GACzBhJ,YAAaR,KAAKQ,YAClBgG,aAAcA,EACdY,SAAUA,EAASiB,MAEvBrI,KAAKuJ,YAAYjF,mBAgBzBtE,KAAKY,cAAgB,SAASC,GAC1BA,EAAWA,GAAY,aAEnBb,KAAKsI,eACLtI,KAAKsI,cAAc1H,eAAc,SAAS6I,GACtC5I,EAAS4I,EAAS,YAItBzJ,KAAK+I,eACL/I,KAAK+I,cAAcnI,eAAc,SAAS6I,GACtC5I,EAAS4I,EAAS,YAItBzJ,KAAKuJ,aACLvJ,KAAKuJ,YAAY3I,eAAc,SAAS6I,GACpC5I,EAAS4I,EAAS,WAY9BzJ,KAAK0E,eAAiB,WACd1E,KAAKsI,eACLtI,KAAKsI,cAAc5D,iBAGnB1E,KAAK+I,eACL/I,KAAK+I,cAAcrE,iBAGnB1E,KAAKuJ,aACLvJ,KAAKuJ,YAAY7E,kBAWzB1E,KAAKe,gBAAkB,WACff,KAAKsI,eACLtI,KAAKsI,cAAcvH,kBAGnBf,KAAK+I,eACL/I,KAAK+I,cAAchI,kBAGnBf,KAAKuJ,aACLvJ,KAAKuJ,YAAYxI,mBAmBzBf,KAAK8E,QAAU,SAASjE,GACpB,IAAI6I,EAAS,GAkBb,OAhBI1J,KAAKsI,gBACLoB,EAAOjD,MAAQzG,KAAKsI,cAAcxD,WAGlC9E,KAAK+I,gBACLW,EAAOhD,MAAQ1G,KAAK+I,cAAcjE,WAGlC9E,KAAKuJ,cACLG,EAAOrB,IAAMrI,KAAKuJ,YAAYzE,WAG9BjE,GACAA,EAAS6I,GAGNA,GAUX1J,KAAKkG,QAAU,WACPlG,KAAKsI,gBACLtI,KAAKsI,cAAcpC,UACnBlG,KAAKsI,cAAgB,MAGrBtI,KAAK+I,gBACL/I,KAAK+I,cAAc7C,UACnBlG,KAAK+I,cAAgB,MAGrB/I,KAAKuJ,cACLvJ,KAAKuJ,YAAYrD,UACjBlG,KAAKuJ,YAAc,OAgB3BvJ,KAAKkC,WAAa,SAASrB,GA0BvB,SAASqB,EAAWT,EAAMkI,GACtB,GAAsB,qBAAX9G,OAAwB,CAC/B,IAAIS,EAkBZ,SAA4BC,GACxB,IAOI3B,EAPAH,EAAOI,EAAIC,gBAAgB,IAAI0B,KAAK,CAACD,EAAUE,WAC/C,qCAAuCF,EAAU9D,KAAO,gBACzD,CACCK,KAAM,4BAGN4D,EAAS,IAAIb,OAAOpB,GAExB,GAAmB,qBAARI,EACPD,EAAMC,MACH,IAAyB,qBAAd+H,UAGd,KAAM,sCAFNhI,EAAMgI,UAKV,OADAhI,EAAI+B,gBAAgBlC,GACbiC,EAnCaE,EAAmB,SAAkBpB,GACjDC,aAAY,IAAIC,gBAAiBC,cAAcH,OAGnDc,EAAUO,UAAY,SAASV,GAC3BwG,EAAWxG,EAAMW,OAGrBR,EAAUb,YAAYhB,OACnB,CACH,IAAIuB,EAAS,IAAIC,WACjBD,EAAOL,cAAclB,GACrBuB,EAAOE,OAAS,SAASC,GACrBwG,EAAWxG,EAAMC,OAAOC,UAxCpCrD,KAAK8E,SAAQ,SAASrD,GACdA,EAAKgF,OAAShF,EAAKiF,MACnBxE,EAAWT,EAAKgF,OAAO,SAASoD,GAC5B3H,EAAWT,EAAKiF,OAAO,SAASoD,GAC5BjJ,EAAS,CACL4F,MAAOoD,EACPnD,MAAOoD,UAIZrI,EAAKgF,MACZvE,EAAWT,EAAKgF,OAAO,SAASoD,GAC5BhJ,EAAS,CACL4F,MAAOoD,OAGRpI,EAAKiF,OACZxE,EAAWT,EAAKiF,OAAO,SAASoD,GAC5BjJ,EAAS,CACL6F,MAAOoD,WAsD3B9J,KAAK+J,YAAc,WACfrK,EAAUqK,YAAY,CAClBtD,MAAOzG,KAAKsI,cACZ5B,MAAO1G,KAAK+I,cACZV,IAAKrI,KAAKuJ,eAgBlBvJ,KAAKiF,KAAO,SAAS+E,IACjBA,EAAOA,GAAQ,CACXvD,OAAO,EACPC,OAAO,EACP2B,KAAK,IAGE5B,OAASzG,KAAKsI,eACrBtI,KAAKsI,cAAcrD,KAA2B,kBAAf+E,EAAKvD,MAAqBuD,EAAKvD,MAAQ,IAGpEuD,EAAKtD,OAAS1G,KAAK+I,eACrB/I,KAAK+I,cAAc9D,KAA2B,kBAAf+E,EAAKtD,MAAqBsD,EAAKtD,MAAQ,IAEpEsD,EAAK3B,KAAOrI,KAAKuJ,aACnBvJ,KAAKuJ,YAAYtE,KAAyB,kBAAb+E,EAAK3B,IAAmB2B,EAAK3B,IAAM,KA3tB5E3I,EAAU8E,QAAU,QAGhByF,EAAOtM,QAAU+B,OAIX,kBACF,OAAOA,GADL,QAAc,OAAd,aAKVA,EAAU0F,YAAc,SAAStF,EAAMe,GACnC,IAAKA,EACD,KAAM,yBAGVJ,QAAQC,IAAI,qBAAgC,QAATZ,EAAiB,QAAUA,EAAO,UAAY,eACjFuC,EAAY6H,OAAM,SAAS/H,EAASgI,GACnB,QAATrK,GAAkBqK,IAAUrK,EAAO,QAAUe,GAC7CA,EAASsB,GAGA,QAATrC,GAAkBe,GAClBA,EAASsB,EAASgI,EAAMC,QAAQ,OAAQ,SAiBpD1K,EAAUqK,YAAc,SAASM,GAC7B5J,QAAQC,IAAI,sCACZ2J,EAAUA,GAAW,IACT5D,OAAS4D,EAAQ3D,OAAS2D,EAAQhC,IAC1CgC,EAAQ5D,MAAMvE,YAAW,SAASoI,GAC9BD,EAAQ3D,MAAMxE,YAAW,SAASqI,GAC9BF,EAAQhC,IAAInG,YAAW,SAASsI,GAC5BnI,EAAYC,MAAM,CACdmI,UAAWH,EACXI,UAAWH,EACXI,QAASH,aAKlBH,EAAQ5D,OAAS4D,EAAQ3D,MAChC2D,EAAQ5D,MAAMvE,YAAW,SAASoI,GAC9BD,EAAQ3D,MAAMxE,YAAW,SAASqI,GAC9BlI,EAAYC,MAAM,CACdmI,UAAWH,EACXI,UAAWH,UAIhBF,EAAQ5D,OAAS4D,EAAQhC,IAChCgC,EAAQ5D,MAAMvE,YAAW,SAASoI,GAC9BD,EAAQhC,IAAInG,YAAW,SAASsI,GAC5BnI,EAAYC,MAAM,CACdmI,UAAWH,EACXK,QAASH,UAIdH,EAAQ3D,OAAS2D,EAAQhC,IAChCgC,EAAQ3D,MAAMxE,YAAW,SAASqI,GAC9BF,EAAQhC,IAAInG,YAAW,SAASsI,GAC5BnI,EAAYC,MAAM,CACdoI,UAAWH,EACXI,QAASH,UAIdH,EAAQ5D,MACf4D,EAAQ5D,MAAMvE,YAAW,SAASoI,GAC9BjI,EAAYC,MAAM,CACdmI,UAAWH,OAGZD,EAAQ3D,MACf2D,EAAQ3D,MAAMxE,YAAW,SAASqI,GAC9BlI,EAAYC,MAAM,CACdoI,UAAWH,OAGZF,EAAQhC,KACfgC,EAAQhC,IAAInG,YAAW,SAASsI,GAC5BnI,EAAYC,MAAM,CACdqI,QAASH,QA2oBzBvC,EAAW7C,YAAc1F,EAAU0F,YAcnC6C,EAAW8B,YAAcrK,EAAUqK,YAG/BrK,EAAUuI,WAAaA,EAG3B,IAEU2C,KAwFW,qBAAXC,EAAyBA,EAAS,OAnFlB,qBAAXC,QAIW,qBAAXD,IAIXA,EAAO/H,UAAY,CACfiI,UAhBmB,sFAiBnBC,aAAc,cAGbH,EAAOpK,UACRoK,EAAOpK,QAAU,IAGa,qBAAvBoK,EAAOpK,QAAQC,KAAuD,qBAAzBmK,EAAOpK,QAAQwK,QACnEJ,EAAOpK,QAAQwK,MAAQJ,EAAOpK,QAAQC,IAAMmK,EAAOpK,QAAQC,KAAO,WAC9DD,QAAQC,IAAIwK,aAII,qBAAbC,WAEPP,EAAKO,SAAW,CACZC,gBAAiB,CACbC,YAAa,WACT,MAAO,MAKnBF,SAAShN,cAAgBgN,SAASG,cAAgBH,SAASI,iBAAmB,WAC1E,IAAIC,EAAM,CACNC,WAAY,WACR,OAAOD,GAEXE,KAAM,aACN/G,MAAO,aACPgH,UAAW,aACXC,UAAW,WACP,MAAO,IAEXC,MAAO,IAEX,OAAOL,GAGXZ,EAAKkB,iBAAmB,cAGJ,qBAAbC,WAEPnB,EAAKmB,SAAW,CACZC,SAAU,QACVC,KAAM,GACNC,KAAM,KAIQ,qBAAXC,SAEPvB,EAAKuB,OAAS,CACVC,MAAO,EACPC,OAAQ,IAIG,qBAARxK,IAEP+I,EAAK/I,IAAM,CACPC,gBAAiB,WACb,MAAO,IAEX6B,gBAAiB,WACb,MAAO,MAMnBiH,EAAKE,OAASD,GASlB,IAAIyB,EAAwBxB,OAAOwB,sBACnC,GAAqC,qBAA1BA,EACP,GAA2C,qBAAhCC,4BAEPD,EAAwBC,iCACrB,GAAwC,qBAA7BC,yBAEdF,EAAwBE,8BACrB,GAAuC,qBAA5BC,wBAEdH,EAAwBG,6BACrB,GAAqC,qBAA1BH,EAAuC,CAErD,IAAII,EAAW,EAGfJ,EAAwB,SAASzL,EAAU8L,GACvC,IAAIC,GAAW,IAAIC,MAAOC,UACtBC,EAAaC,KAAKC,IAAI,EAAG,IAAML,EAAWF,IAC1CQ,EAAKlM,YAAW,WAChBH,EAAS+L,EAAWG,KACrBA,GAEH,OADAL,EAAWE,EAAWG,EACfG,GAMnB,IAAIC,EAAuBrC,OAAOqC,qBACE,qBAAzBA,IACmC,qBAA/BC,2BAEPD,EAAuBC,2BACmB,qBAA5BC,wBAEdF,EAAuBE,wBACkB,qBAA3BC,uBAEdH,EAAuBG,uBACgB,qBAAzBH,IAEdA,EAAuB,SAASD,GAC5BK,aAAaL,MAMzB,IAAIM,EAAe1C,OAAO0C,aAEE,qBAAjBA,IAC2B,qBAAvBC,qBAEPD,EAAeC,oBAGY,qBAApBC,kBAEPF,EAAeE,kBAKvB,IAAI7L,EAAMiJ,OAAOjJ,IAEE,qBAARA,GAA4C,qBAAd+H,YAErC/H,EAAM+H,WAGe,qBAAd9G,WAA+D,qBAA3BA,UAAUkI,eACT,qBAAjClI,UAAU6K,qBACjB7K,UAAUkI,aAAelI,UAAU6K,oBAGE,qBAA9B7K,UAAUC,kBACjBD,UAAUkI,aAAelI,UAAUC,kBAI3C,IAAI0E,GAAkD,IAAzC3E,UAAUiI,UAAU6C,QAAQ,YAAqB9K,UAAU+K,cAAgB/K,UAAUgL,kBAC9FpG,IAAYoD,OAAOiD,QAAkD,IAAzCjL,UAAUiI,UAAU6C,QAAQ,QACxDhF,EAAY9F,UAAUiI,UAAUiD,cAAcJ,QAAQ,YAAc,GAAM,aAAc9C,QAAW,OAAOmD,KAAKnL,UAAUiI,WACzHvD,GAAaE,IAAYD,KAAY3E,UAAU6K,oBAAuBO,MAA0E,IAA1DpL,UAAUiI,UAAUiD,cAAcJ,QAAQ,WAEhI5F,EAAW,iCAAiCiG,KAAKnL,UAAUiI,WAE3D/C,IAAaR,IAAsD,IAA1C1E,UAAUiI,UAAU6C,QAAQ,WACrD5F,GAAW,EACXR,GAAW,GAGf,IAAIqB,EAAciC,OAAOjC,YA2BzB,SAASnH,EAAYyM,GAGjB,GAAc,IAAVA,EACA,MAAO,UAEX,IAAI1I,EAAI2I,SAASpB,KAAKqB,MAAMrB,KAAKtM,IAAIyN,GAASnB,KAAKtM,IAL3C,MAKoD,IAC5D,OAAQyN,EAAQnB,KAAKsB,IANb,IAMoB7I,IAAI8I,YAAY,GAAK,IALrC,CAAC,QAAS,KAAM,KAAM,KAAM,MAKqB9I,GAUjE,SAASN,EAAmBqJ,EAAMtJ,GAC9B,IAAKsJ,EACD,KAAM,2BAGV,IAAKA,EAAK1O,KACN,IACI0O,EAAK1O,KAAO,aACd,MAAOiC,IAGb,IAAI0M,GAAiBD,EAAK1O,MAAQ,cAAcuH,MAAM,KAAK,GAE3D,GAAInC,IAAuC,IAA3BA,EAAS0I,QAAQ,KAAa,CAC1C,IAAIc,EAAWxJ,EAASmC,MAAM,KAC9BnC,EAAWwJ,EAAS,GACpBD,EAAgBC,EAAS,GAG7B,IAAIC,GAAgBzJ,GAAa8H,KAAK4B,MAAsB,WAAhB5B,KAAK6B,UAAyB,WAAc,IAAMJ,EAE9F,GAA0C,qBAA/B3L,UAAUgL,iBACjB,OAAOhL,UAAUgL,iBAAiBU,EAAMG,GACrC,GAAoC,qBAAzB7L,UAAU+K,WACxB,OAAO/K,UAAU+K,WAAWW,EAAMG,GAGtC,IAAIG,EAAY3D,SAAShN,cAAc,KACvC2Q,EAAU7C,KAAOpK,EAAIC,gBAAgB0M,GACrCM,EAAUC,SAAWJ,EAErBG,EAAUjD,MAAQ,6CACjBV,SAAS6D,MAAQ7D,SAASC,iBAAiBC,YAAYyD,GAEzB,oBAApBA,EAAUG,MACjBH,EAAUG,SAEVH,EAAU1L,OAAS,SACnB0L,EAAUI,cAAc,IAAIC,WAAW,QAAS,CAC5CC,KAAMtE,OACNuE,SAAS,EACTC,YAAY,MAIpBzN,EAAI8B,gBAAgBmL,EAAU7C,MAMlC,SAASiC,IAEL,MAAsB,qBAAXpD,QAAoD,kBAAnBA,OAAOyE,SAAgD,aAAxBzE,OAAOyE,QAAQzP,SAKnE,qBAAZyP,GAAuD,kBAArBA,EAAQC,WAA2BD,EAAQC,SAASC,WAKxE,kBAAd3M,WAAyD,kBAAxBA,UAAUiI,WAA0BjI,UAAUiI,UAAU6C,QAAQ,aAAe,GAO/H,SAAS3G,EAAUyI,EAAQC,GACvB,OAAKD,GAAWA,EAAOzI,UAIhByI,EAAOzI,YAAY2I,QAAO,SAASC,GACtC,OAAOA,EAAEF,QAAUA,GAAQ,YAJpB,GAQf,SAASG,EAAaJ,EAAQ/C,GACtB,cAAeA,EACfA,EAAQoD,UAAYL,EACb,iBAAkB/C,EACzBA,EAAQqD,aAAeN,EAEvB/C,EAAQoD,UAAYL,EAhID,qBAAhB7G,GAA4D,qBAAtBoH,oBAC7CpH,EAAcoH,mBAIS,qBAAhBpH,GAEmC,qBAA/BA,EAAY1B,UAAUjG,OAC7B2H,EAAY1B,UAAUjG,KAAO,WACzBlB,KAAKiH,YAAY1F,SAAQ,SAAS2O,GAC9BA,EAAMhP,YA8JlBxB,EAAUyF,mBAAqBA,EAC/BzF,EAAUuH,UAAYA,EACtBvH,EAAUyQ,gBA/Bd,SAAyBC,EAAWvP,GAEhC,GAAoB,qBAATwP,KACP,MAAM,IAAIC,MAAM,0DAGpB,IAAItN,EAAS,IAAIqN,KAAKE,OAClBC,EAAU,IAAIH,KAAKI,QACnBC,EAAQL,KAAKK,MAEbC,EAAa,IAAI1N,WACrB0N,EAAWzN,OAAS,SAASnB,GACVyO,EAAQI,OAAO5Q,KAAKqD,QAC1B9B,SAAQ,SAASoL,GACtB3J,EAAO6N,KAAKlE,MAEhB3J,EAAO9B,OACP,IAAI4P,EAAqBJ,EAAMK,qBAAqB/N,EAAOgO,UAAWhO,EAAO2C,SAAU3C,EAAOiO,MAC1FjC,EAAOhP,KAAKqD,OAAO6N,MAAMlO,EAAOmO,cAChCC,EAAU,IAAI5N,KAAK,CAACsN,EAAoB9B,GAAO,CAC/ClP,KAAM,eAGVe,EAASuQ,IAEbT,EAAWU,kBAAkBjB,IAO7B1Q,EAAUgC,YAAcA,EACxBhC,EAAUwO,WAAaA,EAgB3B,IAAI9H,EAAU,GAYd,SAASwB,IACL,GAAIgB,GAAaZ,GAAYP,EACzB,OAAO,EAGA3E,UAAUwO,WAArB,IAIgBC,EAAWC,EAHvBC,EAAO3O,UAAUiI,UACjB2G,EAAc,GAAKC,WAAW7O,UAAUwO,YACxCM,EAAexD,SAAStL,UAAUwO,WAAY,IAwBlD,OArBI9J,GAAYE,KACZ6J,EAAYE,EAAK7D,QAAQ,UACzB8D,EAAcD,EAAKI,UAAUN,EAAY,KAIJ,KAApCC,EAAKE,EAAY9D,QAAQ,QAC1B8D,EAAcA,EAAYG,UAAU,EAAGL,KAGF,KAApCA,EAAKE,EAAY9D,QAAQ,QAC1B8D,EAAcA,EAAYG,UAAU,EAAGL,IAG3CI,EAAexD,SAAS,GAAKsD,EAAa,IAEtCI,MAAMF,KACNF,EAAc,GAAKC,WAAW7O,UAAUwO,YACxCM,EAAexD,SAAStL,UAAUwO,WAAY,KAG3CM,GAAgB,GAqC3B,SAAS5K,EAAoBrH,EAAaC,GACtC,IAAIG,EAAOC,KAEX,GAA2B,qBAAhBL,EACP,KAAM,4CAGV,GAA6B,qBAAlBuH,cACP,KAAM,6HAQV,GAAoB,WALpBtH,EAASA,GAAU,CAEfwH,SAAU,eAGHtH,KAAkB,CAErB,IAAI4P,EADR,GAAIzI,EAAUtH,EAAa,SAAS6F,QAAUyB,EAAUtH,EAAa,SAAS6F,OAEpE1C,UAAUC,iBACZ2M,EAAS,IAAI7G,GACNC,SAAS7B,EAAUtH,EAAa,SAAS,IAGhD+P,EAAS,IAAI7G,EAAY5B,EAAUtH,EAAa,UAEpDA,EAAc+P,EAGb9P,EAAOwH,WAA2E,IAA/DxH,EAAOwH,SAAS3D,WAAWuK,cAAcJ,QAAQ,WACrEhO,EAAOwH,SAAWI,EAAW,aAAe,aAG5C5H,EAAOwH,UAAyD,cAA7CxH,EAAOwH,SAAS3D,WAAWuK,eAAmClL,UAAUC,kBAE3FnD,EAAOwH,SAAW,aAI1B,IA4TI/G,EA5TA0R,EAAe,GAgNnB,SAASC,IACLjS,EAAKkS,WAAWvM,MAAK,IAAImH,MAAOC,WAEE,oBAAvBlN,EAAO6I,aACd7I,EAAO6I,YAAY1I,EAAKkS,WAAWlS,EAAKkS,WAAWzM,OAAS,GAAIzF,EAAKkS,YAI7E,SAASC,EAAYC,GACjB,OAAI9R,GAAiBA,EAAc+G,SACxB/G,EAAc+G,SAGlB+K,EAAa/K,UAAY,aAwFpC,SAASgL,IACLL,EAAe,GACf1R,EAAgB,KAChBN,EAAKkS,WAAa,GA9StBjS,KAAKqS,gBAAkB,WACnB,OAAON,GAUX/R,KAAKM,OAAS,WAEVP,EAAK0B,KAAO,KACZ1B,EAAK0E,oBACL1E,EAAKkS,WAAa,GAClBK,EAAY,GACZP,EAAe,GAEf,IAAIQ,EAAgB3S,EAEfA,EAAOY,aACRC,QAAQC,IAAI,mDAAoD6R,GAGhElS,IAEAA,EAAgB,MAGhBmH,IAAaI,MAEb2K,EAAgB,aAGyB,oBAAlCrL,cAAcW,iBAAkC0K,EAAcnL,WAChEF,cAAcW,gBAAgB0K,EAAcnL,YACxCxH,EAAOY,aACRC,QAAQQ,KAAK,qDAAsDsR,EAAcnL,UAGrFmL,EAAcnL,SAA2B,UAAhBxH,EAAOE,KAAmB,aAAe,eAK1E,IACIO,EAAgB,IAAI6G,cAAcvH,EAAa4S,GAG/C3S,EAAOwH,SAAWmL,EAAcnL,SAClC,MAAOrF,GAEL1B,EAAgB,IAAI6G,cAAcvH,GAIlC4S,EAAcnL,WAAaF,cAAcW,iBAAmB,sBAAuBxH,IAA6E,IAA5DA,EAAcmS,kBAAkBD,EAAcnL,YAC7IxH,EAAOY,aACRC,QAAQQ,KAAK,qDAAsDsR,EAAcnL,WAKzF/G,EAAcoS,gBAAkB,SAAS1Q,GAKrC,GAJIA,EAAE+B,MACFwO,EAAU5M,KAAK,oBAAsBhE,EAAYK,EAAE+B,KAAKnC,OAG5B,kBAArB/B,EAAO4I,WAgBbzG,EAAE+B,OAAS/B,EAAE+B,KAAKnC,MAAQI,EAAE+B,KAAKnC,KAAO,KAAO5B,EAAK0B,KAGjD1B,EAAK2S,oBACL3S,EAAK2S,kBAAkB,IAAIlP,KAAK,GAAI,CAChC1D,KAAMoS,EAAYK,MAEtBxS,EAAK2S,kBAAoB,OAKjC3S,EAAK0B,KAAO7B,EAAO+S,cAAgB5Q,EAAE+B,KAAO,IAAIN,KAAK,CAACzB,EAAE+B,MAAO,CAC3DhE,KAAMoS,EAAYK,KAGlBxS,EAAK2S,oBACL3S,EAAK2S,kBAAkB3S,EAAK0B,MAC5B1B,EAAK2S,kBAAoB,YAjCzB,GAAI3Q,EAAE+B,MAAQ/B,EAAE+B,KAAKnC,MAAQI,EAAE+B,KAAKnC,KAAO,MACvCoQ,EAAarM,KAAK3D,EAAE+B,MACpBkO,IAEsC,oBAA3BpS,EAAO6S,iBAAgC,CAE9C,IAAIhR,EAAO7B,EAAO+S,cAAgB5Q,EAAE+B,KAAO,IAAIN,KAAK,CAACzB,EAAE+B,MAAO,CAC1DhE,KAAMoS,EAAYK,KAEtB3S,EAAO6S,gBAAgBhR,KA4BvCpB,EAAcuS,QAAU,WACpBN,EAAU5M,KAAK,YAGnBrF,EAAcwS,QAAU,WACpBP,EAAU5M,KAAK,WAGnBrF,EAAcyS,SAAW,WACrBR,EAAU5M,KAAK,YAGnBrF,EAAc0S,OAAS,WACnBT,EAAU5M,KAAK,YAGnBrF,EAAc2S,QAAU,SAAS/H,GACxBA,IAIAA,EAAMxL,OACPwL,EAAMxL,KAAO,gBAGjB6S,EAAU5M,KAAK,UAAYuF,GAEtBrL,EAAOY,eAE6D,IAAjEyK,EAAMxL,KAAKgE,WAAWuK,cAAcJ,QAAQ,gBAC5CnN,QAAQwK,MAAM,iGAAkGA,IACxC,IAAjEA,EAAMxL,KAAKgE,WAAWuK,cAAcJ,QAAQ,gBACnDnN,QAAQwK,MAAM,cAAesH,EAAcnL,SAAU,sBAAuB6D,IACR,IAA7DA,EAAMxL,KAAKgE,WAAWuK,cAAcJ,QAAQ,YACnDnN,QAAQwK,MAAM,+BAAgCA,GAI1B,gBAAfA,EAAMxL,KACXgB,QAAQwK,MAAM,4IAA6IA,GACrI,8BAAfA,EAAMxL,KACbgB,QAAQwK,MAAM,sQAAuQA,GAC/P,wBAAfA,EAAMxL,KACbgB,QAAQwK,MAAM,yJAA0JA,GAClJ,iBAAfA,EAAMxL,KACbgB,QAAQwK,MAAM,+EAAgFA,GAE9FxK,QAAQwK,MAAM,sBAAuBA,IAI7C,SAAUgI,GACN,IAAKlT,EAAKmT,iBAAmB7S,GAAyC,aAAxBA,EAAcS,MAKxD,cAJOlB,EAAOuT,eAGd9S,EAAc+S,MAAM,KAIxBpS,gBATJ,EASuB,KATvB,GAY4B,aAAxBX,EAAcS,OAAgD,YAAxBT,EAAcS,OACpDT,EAAca,SAIU,kBAArBtB,EAAO4I,WACdwJ,IACA3R,EAAc+S,MAAMxT,EAAO4I,YAK3BnI,EAAc+S,MAAM,MAGpBxT,EAAOM,cACPN,EAAOM,gBAUfF,KAAKiS,WAAa,GA4BlBjS,KAAKkB,KAAO,SAASL,GACjBA,EAAWA,GAAY,aAEvBd,EAAKmT,iBAAkB,EAElB7S,IAILL,KAAK0S,kBAAoB7R,EAEG,cAAxBR,EAAcS,OACdT,EAAca,OAGc,kBAArBtB,EAAO4I,WACdxH,YAAW,WACPjB,EAAK0B,KAAO,IAAI+B,KAAKuO,EAAc,CAC/BjS,KAAMoS,EAAYtS,KAGtBG,EAAK2S,kBAAkB3S,EAAK0B,QAC7B,OAWXzB,KAAK2E,MAAQ,WACJtE,GAIuB,cAAxBA,EAAcS,OACdT,EAAcsE,SAWtB3E,KAAK4E,OAAS,WACLvE,GAIuB,WAAxBA,EAAcS,OACdT,EAAcuE,UAWtB5E,KAAKyE,kBAAoB,WACjBpE,GAAyC,cAAxBA,EAAcS,OAC/Bf,EAAKmB,KAAKkR,GAGdA,KAuBJpS,KAAKgF,oBAAsB,WACvB,OAAO3E,GAwBXL,KAAKyB,KAAO,KAWZzB,KAAKiG,SAAW,WACZ,OAAK5F,GAIEA,EAAcS,OAHV,YAOf,IAAIwR,EAAY,GAUhBtS,KAAKqT,aAAe,WAChB,OAAOf,GAOkC,qBAAlC1S,EAAO0T,yBACd1T,EAAO0T,wBAAyB,GAGhCvT,EAAOC,MAIX,SAAUiT,IACN,GAAK5S,IAAmD,IAAlCT,EAAO0T,uBAI7B,OAA8B,IAxElC,WACI,GAAI,WAAY3T,GACZ,IAAKA,EAAY4T,OACb,OAAO,OAER,GAAI,UAAW5T,GACdA,EAAY6T,MACZ,OAAO,EAGf,OAAO,EA8DHC,IACK7T,EAAOY,aACRC,QAAQC,IAAI,mCAEhBX,EAAKmB,aAITF,WAAWiS,EAAQ,KAbvB,GAiBAjT,KAAKP,KAAO,sBACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAkCpB,SAASsH,EAAoBpH,EAAaC,GACtC,IAAKqH,EAAUtH,EAAa,SAAS6F,OACjC,KAAM,mCAKV,IAOIkO,EAPA3T,EAAOC,KAGP2T,EAAc,GACdC,EAAe,GACfC,GAAY,EACZC,EAAkB,EAGlBvL,EAAwB,EAYxBwL,GAvBJnU,EAASA,GAAU,IAuBUmU,gBA2B7B,SAASN,IACL,IAAsC,IAAlC7T,EAAO0T,uBAEP,OAAO,EAGX,GAAI,WAAY3T,GACZ,IAAKA,EAAY4T,OACb,OAAO,OAER,GAAI,UAAW5T,GACdA,EAAY6T,MACZ,OAAO,EAGf,OAAO,EAyBX,SAASQ,EAAsBpU,EAAQiB,GACnC,SAASoT,EAAkBrU,EAAQsU,GAC/B,IA2FIC,EA3FA5L,EAAwB3I,EAAO2I,sBAG/B6L,EAAcxU,EAAOwU,YAAYlD,MAAM,GACvCmD,EAAezU,EAAOyU,aAAanD,MAAM,GACzCpL,EAAalG,EAAOkG,WACpBwO,EAA4B1U,EAAO0U,0BACnCP,EAAkBnU,EAAOmU,gBA2B7B,SAASQ,EAAiBzQ,EAAM0Q,EAAeC,GAC3C,IAAIC,EAAW1H,KAAK4B,MAAM9K,EAAK0B,QAAUgP,EAAgBC,IACrDE,EAAU,GACVC,EAAeC,QAAQ/Q,EAAK0B,OAAS,IAAMkP,EAAW,IAC1DC,EAAQ,GAAK7Q,EAAK,GAClB,IAAK,IAAI2B,EAAI,EAAGA,EAAIiP,EAAW,EAAGjP,IAAK,CACnC,IAAIqP,EAAMrP,EAAImP,EACVG,EAASF,OAAO7H,KAAKqB,MAAMyG,IAAME,UACjCC,EAAQJ,OAAO7H,KAAKkI,KAAKJ,IAAME,UAC/BG,EAAUL,EAAMC,EACpBJ,EAAQlP,GAAK2P,EAAkBtR,EAAKiR,GAASjR,EAAKmR,GAAQE,GAG9D,OADAR,EAAQD,EAAW,GAAK5Q,EAAKA,EAAK0B,OAAS,GACpCmP,EAGX,SAASS,EAAkBL,EAAQE,EAAOE,GACtC,OAAOJ,GAAUE,EAAQF,GAAUI,EAGvC,SAASE,EAAaC,EAAeC,GAKjC,IAJA,IAAIlS,EAAS,IAAImS,aAAaD,GAC1BE,EAAS,EACTC,EAAMJ,EAAc9P,OAEfC,EAAI,EAAGA,EAAIiQ,EAAKjQ,IAAK,CAC1B,IAAIM,EAASuP,EAAc7P,GAC3BpC,EAAOsS,IAAI5P,EAAQ0P,GACnBA,GAAU1P,EAAOP,OAGrB,OAAOnC,EAkBX,SAASuS,EAAcxG,EAAMqG,EAAQI,GAEjC,IADA,IAAIH,EAAMG,EAAOrQ,OACRC,EAAI,EAAGA,EAAIiQ,EAAKjQ,IACrB2J,EAAK0G,SAASL,EAAShQ,EAAGoQ,EAAOE,WAAWtQ,IA7EtB,IAA1B8C,IACA6L,EAAciB,EAAajB,EAAaE,GACxCD,EAAegB,EAAahB,EAAcC,GAEtCP,IACAK,EAAcG,EAAiBH,EAAaL,EAAiBjO,GAC7DuO,EAAeE,EAAiBF,EAAcN,EAAiBjO,KAIzC,IAA1ByC,IACA6L,EAAciB,EAAajB,EAAaE,GAEpCP,IACAK,EAAcG,EAAiBH,EAAaL,EAAiBjO,KAKjEiO,IACAjO,EAAaiO,GAgEa,IAA1BxL,IACA4L,EA1BJ,SAAoB6B,EAAaC,GAO7B,IANA,IAAIzQ,EAASwQ,EAAYxQ,OAASyQ,EAAazQ,OAE3CnC,EAAS,IAAImS,aAAahQ,GAE1B0Q,EAAa,EAERC,EAAQ,EAAGA,EAAQ3Q,GACxBnC,EAAO8S,KAAWH,EAAYE,GAC9B7S,EAAO8S,KAAWF,EAAaC,GAC/BA,IAEJ,OAAO7S,EAcO+S,CAAWhC,EAAaC,IAGZ,IAA1B9L,IACA4L,EAAcC,GAGlB,IAAIiC,EAAoBlC,EAAY3O,OAKhCO,EAAS,IAAIuQ,YAFW,GAAyB,EAApBD,GAI7BjH,EAAO,IAAImH,SAASxQ,GAGxB6P,EAAcxG,EAAM,EAAG,QAIvBA,EAAKoH,UAAU,EAAG,GAAyB,EAApBH,GAAuB,GAG9CT,EAAcxG,EAAM,EAAG,QAIvBwG,EAAcxG,EAAM,GAAI,QAGxBA,EAAKoH,UAAU,GAAI,IAAI,GAGvBpH,EAAKqH,UAAU,GAAI,GAAG,GAGtBrH,EAAKqH,UAAU,GAAIlO,GAAuB,GAG1C6G,EAAKoH,UAAU,GAAI1Q,GAAY,GAG/BsJ,EAAKoH,UAAU,GAAiB,EAAb1Q,GAAgB,GAGnCsJ,EAAKqH,UAAU,GAA4B,EAAxBlO,GAA2B,GAG9C6G,EAAKqH,UAAU,GAAI,IAAI,GAIvBb,EAAcxG,EAAM,GAAI,QAGxBA,EAAKoH,UAAU,GAAwB,EAApBH,GAAuB,GAM1C,IAHA,IAAIX,EAAMW,EACNF,EAAQ,GAEH1Q,EAAI,EAAGA,EAAIiQ,EAAKjQ,IACrB2J,EAAKsH,SAASP,EAAO,MAAAhC,EAAY1O,IAAwB,GACzD0Q,GAAS,EAGb,GAAIjC,EACA,OAAOA,EAAG,CACNnO,OAAQA,EACRqJ,KAAMA,IAId3M,YAAY,CACRsD,OAAQA,EACRqJ,KAAMA,IAId,GAAIxP,EAAO+W,SACP1C,EAAkBrU,GAAQ,SAASkE,GAC/BjD,EAASiD,EAAKiC,OAAQjC,EAAKsL,aAFnC,CAQA,IAAI9L,EAeR,SAA4BC,GACxB,IAAIqT,EAAY/U,EAAIC,gBAAgB,IAAI0B,KAAK,CAACD,EAAUE,WACpD,sCAAwCF,EAAU9D,KAAO,gBAC1D,CACCK,KAAM,4BAGN4D,EAAS,IAAIb,OAAO+T,GAExB,OADAlT,EAAOkT,UAAYA,EACZlT,EAxBSE,CAAmBqQ,GAEnC3Q,EAAUO,UAAY,SAASV,GAC3BtC,EAASsC,EAAMW,KAAKiC,OAAQ5C,EAAMW,KAAKsL,MAGvCvN,EAAI8B,gBAAgBL,EAAUsT,WAG9BtT,EAAUuT,aAGdvT,EAAUb,YAAY7C,KApQC,IAAvBA,EAAOoW,cACPzN,EAAwB,GAGS,IAAjC3I,EAAO2I,wBACPA,EAAwB,KAGvBA,GAAyBA,EAAwB,KAClDA,EAAwB,GAGvB3I,EAAOY,aACRC,QAAQC,IAAI,4DAA8D6H,GAOjC,qBAAlC3I,EAAO0T,yBACd1T,EAAO0T,wBAAyB,GA4BpCtT,KAAKM,OAAS,WACV,IAA8B,IAA1BmT,IACA,KAAM,0CAGVqD,IAEAC,EAAwBC,GAAW,EACnCnD,GAAY,EAEoB,qBAArBjU,EAAO4I,WACdyK,KAiORjT,KAAKkB,KAAO,SAASL,GACjBA,EAAWA,GAAY,aAGvBgT,GAAY,EAEZG,EAAsB,CAClBD,gBAAiBA,EACjBjO,WAAYA,EACZyC,sBAAuBA,EACvB+L,0BAA2BR,EAC3BM,YAAaT,EACbU,aAAwC,IAA1B9L,EAA8B,GAAKqL,EACjD+C,SAAU/W,EAAO+W,WAClB,SAAS5Q,EAAQqJ,GAShBrP,EAAK0B,KAAO,IAAI+B,KAAK,CAAC4L,GAAO,CACzBtP,KAAM,cAWVC,EAAKgG,OAAS,IAAIuQ,YAAYlH,EAAKrJ,OAAOkR,YAU1ClX,EAAKqP,KAAOA,EAEZrP,EAAK+F,WAAaiO,GAAmBjO,EACrC/F,EAAK8F,WAAaA,EAGlB9F,EAAKyF,OAASsO,EAEdiD,GAAwB,EAEpBlW,GACAA,EAASd,EAAK0B,UAKO,qBAAtB/B,EAAU0G,UACjB1G,EAAU0G,QAAU,CAChBC,wBAAyB,KACzBmH,aAAc1C,OAAO0C,cAAgB1C,OAAO2C,qBAI/C/N,EAAU0G,QAAQC,yBAA+E,WAApD3G,EAAU0G,QAAQC,wBAAwBvF,QACxFpB,EAAU0G,QAAQC,wBAA0B,IAAI3G,EAAU0G,QAAQoH,cAGtE,IAAI0J,EAAUxX,EAAU0G,QAAQC,wBAG5B8Q,EAAaD,EAAQE,wBAAwBzX,GAE7C0X,EAAoB,CAAC,EAAG,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,OAmB1DxR,EAA0C,qBAAtBjG,EAAOiG,WAA6B,KAAOjG,EAAOiG,WAQ1E,IAN+C,IAA3CwR,EAAkBzJ,QAAQ/H,KACrBjG,EAAOY,aACRC,QAAQC,IAAI,oCAAsC4W,KAAKC,UAAUF,EAAmB,KAAM,QAI9FH,EAAQM,qBACR9D,EAAcwD,EAAQM,qBAAqB3R,EAAY0C,EAAuBA,OAC3E,KAAI2O,EAAQO,sBAGf,KAAM,+CAFN/D,EAAcwD,EAAQO,sBAAsB5R,EAAY0C,EAAuBA,GAMnF4O,EAAWO,QAAQhE,GAEd9T,EAAOiG,aACRA,EAAa6N,EAAY7N,YAoB7B,IAAIC,EAA0C,qBAAtBlG,EAAOkG,WAA6BlG,EAAOkG,WAAaoR,EAAQpR,YAAc,OAElGA,EAAa,OAASA,EAAa,QAE9BlG,EAAOY,aACRC,QAAQC,IAAI,qDAIfd,EAAOY,aACJZ,EAAOmU,iBACPtT,QAAQC,IAAI,wBAA0Bd,EAAOmU,iBAIrD,IAAIiD,GAAW,EAoDf,SAASF,IACLnD,EAAc,GACdC,EAAe,GACfE,EAAkB,EAClBiD,GAAwB,EACxBlD,GAAY,EACZmD,GAAW,EACXE,EAAU,KAEVnX,EAAK4T,YAAcA,EACnB5T,EAAK6T,aAAeA,EACpB7T,EAAKwI,sBAAwBA,EAC7BxI,EAAKgU,gBAAkBA,EACvBhU,EAAK+F,WAAaA,EAClB/F,EAAK+T,gBAAkBA,EAEvB6D,EAAwB,CACpBC,KAAM,GACN7Y,MAAO,GACP+U,gBAAiB,GAIzB,SAAS1B,IACDsB,IACAA,EAAYmE,eAAiB,KAC7BnE,EAAYoE,aACZpE,EAAc,MAGdyD,IACAA,EAAWW,aACXX,EAAa,MAGjBL,IA/EJ9W,KAAK2E,MAAQ,WACTqS,GAAW,GAUfhX,KAAK4E,OAAS,WACV,IAA8B,IAA1B6O,IACA,KAAM,0CAGV,IAAKI,EAKD,OAJKjU,EAAOY,aACRC,QAAQC,IAAI,4CAEhBV,KAAKM,SAIT0W,GAAW,GAUfhX,KAAKyE,kBAAoB,WACrB7E,EAAO0T,wBAAyB,EAE5BO,GACA7T,KAAKkB,KAAKkR,GAGdA,KA0CJpS,KAAKP,KAAO,sBACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAGhB,IAAIsX,GAAwB,EAoE5BrD,EAAYmE,eAlEZ,SAAqC9V,GACjC,IAAIiV,EAYJ,IAR8B,IAA1BvD,MACK7T,EAAOY,aACRC,QAAQC,IAAI,8BAEhBgT,EAAYoE,aACZjE,GAAY,GAGXA,EAAL,CAeKkD,IACDA,GAAwB,EACpBnX,EAAOmY,uBACPnY,EAAOmY,wBAGPnY,EAAOM,cACPN,EAAOM,gBAIf,IAAI0X,EAAO7V,EAAEiW,YAAYC,eAAe,GAGpCC,EAAS,IAAIC,aAAaP,GAG9B,GAFAjE,EAAYjO,KAAKwS,GAEa,IAA1B3P,EAA6B,CAC7B,IAAIxJ,EAAQgD,EAAEiW,YAAYC,eAAe,GACrCG,EAAU,IAAID,aAAapZ,GAC/B6U,EAAalO,KAAK0S,GAGtBtE,GAAmBjO,EAGnB9F,EAAK+T,gBAAkBA,EAES,qBAArBlU,EAAO4I,YACdmP,EAAsB7D,iBAAmBjO,EACzC8R,EAAsBC,KAAKlS,KAAKwS,GAEF,IAA1B3P,GACAoP,EAAsB5Y,MAAM2G,KAAK0S,SA/CjCjB,IACAA,EAAWW,aACXX,EAAa,OAqDrBD,EAAQmB,6BACR3E,EAAYgE,QAAQR,EAAQmB,gCAE5B3E,EAAYgE,QAAQR,EAAQoB,aAIhCtY,KAAK2T,YAAcA,EACnB3T,KAAK4T,aAAeA,EACpB5T,KAAKuI,sBAAwBA,EAC7BvI,KAAK+T,gBAAkBA,EACvB/T,KAAK8F,WAAaA,EAClB/F,EAAK+T,gBAAkBA,EAGvB,IAAI6D,EAAwB,CACxBC,KAAM,GACN7Y,MAAO,GACP+U,gBAAiB,GAIrB,SAASb,IACAY,GAA+C,oBAA3BjU,EAAO6S,iBAA8D,qBAArB7S,EAAO4I,YAI5EmP,EAAsBC,KAAKpS,QAC3BwO,EAAsB,CAClBD,gBAAiBA,EACjBjO,WAAYA,EACZyC,sBAAuBA,EACvB+L,0BAA2BqD,EAAsB7D,gBACjDM,YAAauD,EAAsBC,KACnCvD,aAAwC,IAA1B9L,EAA8B,GAAKoP,EAAsB5Y,QACxE,SAASgH,EAAQqJ,GAChB,IAAI3N,EAAO,IAAI+B,KAAK,CAAC4L,GAAO,CACxBtP,KAAM,cAEVF,EAAO6S,gBAAgBhR,GAEvBT,WAAWiS,EAAQrT,EAAO4I,cAG9BmP,EAAwB,CACpBC,KAAM,GACN7Y,MAAO,GACP+U,gBAAiB,IAGrB9S,WAAWiS,EAAQrT,EAAO4I,aA8BtC,SAAS5B,EAAe2R,EAAa3Y,GACjC,GAA2B,qBAAhB4Y,YACP,KAAM,gEAGV5Y,EAASA,GAAU,IACPqJ,gBACRrJ,EAAOqJ,cAAgB,IAI3B,IAAIwP,GAAkC,EACtC,CAAC,gBAAiB,mBAAoB,uBAAuBlX,SAAQ,SAASmX,GACtEA,KAAQvN,SAAShN,cAAc,YAC/Bsa,GAAkC,MAI1C,IAgBIE,EAAcC,EAoBdC,EApCAC,KAAehO,OAAOiO,2BAA6BjO,OAAO6C,uBAAyB7C,OAAOkO,OAE1FC,EAAgB,GAChBC,EAAapW,UAAUiI,UAAUoO,MAAM,4BAe3C,GAdIL,GAAaI,GAAcA,EAAW,KACtCD,EAAgB7K,SAAS8K,EAAW,GAAI,KAGxCJ,GAAaG,EAAgB,KAC7BR,GAAkC,GAGlC7Y,EAAOwZ,oBACPX,GAAkC,GAKlCA,EAKA,GAJK7Y,EAAOY,aACRC,QAAQC,IAAI,yEAGZ6X,aAAuBc,kBACvBV,EAAeJ,MACZ,MAAIA,aAAuBe,0BAG9B,KAAM,oEAFNX,EAAeJ,EAAYvP,YAItBlG,UAAUC,kBACdnD,EAAOY,aACRC,QAAQwK,MAAM,kDAatBjL,KAAKM,OAAS,WAGV,GAFAuY,GAAc,EAEVJ,IAAoC7Y,EAAOwZ,kBAAmB,CAE9D,IAAIG,EACA,kBAAmBZ,EACnBY,EAAoBZ,EAAarN,cAAc,IACxC,qBAAsBqN,EAC7BY,EAAoBZ,EAAapN,iBAAiB,IAC3C,wBAAyBoN,IAChCY,EAAoBZ,EAAaa,oBAAoB,KAGzD,IACI,IAAIC,EAAW,IAAI5Q,EACnB4Q,EAAS3Q,SAAS7B,EAAUsS,EAAmB,SAAS,IACxDA,EAAoBE,EACtB,MAAO1X,IAET,IAAKwX,EACD,KAAM,wCAKVX,EAAsB,IAAI5R,EAAoBuS,EAAmB,CAC7DnS,SAAUxH,EAAOwH,UAAY,gBAEb9G,cAEpBoZ,EAAOC,OAAS,GAChBjN,GAAW,IAAIG,MAAOC,UACtB8M,IAGAha,EAAOM,cACPN,EAAOM,gBAIfF,KAAK6Z,cAAgB,SAAShZ,GAC1B,GAA2C,WAAvC0X,EAAYuB,SAAS9L,cAAzB,CAKA,IAAI+L,EAAeL,EAAOC,OAAOnU,OACjCkU,EAAOC,OAAOpY,SAAQ,SAASyY,EAAOC,GAClC,IAAIC,EAAkBH,EAAeE,EAChCra,EAAOY,aACRC,QAAQC,IAAIwZ,EAAkB,IAAMH,EAAe,qBAGnDna,EAAOua,oBACPva,EAAOua,mBAAmBD,EAAiBH,GAG/C,IAAIK,EAAOJ,EAAMpU,MAAMgG,UAAU,aAAc,GAC/C8N,EAAOC,OAAOM,GAAKrU,MAAQwU,KAG1Bxa,EAAOY,aACRC,QAAQC,IAAI,mBAGhBG,SAvBIA,KAoCRb,KAAKkB,KAAO,SAASL,GACjBgY,GAAc,EAEd,IAAIjO,EAAO5K,KAEPyY,GAAmCG,EACnCA,EAAoB1X,KAAKL,GAI7Bb,KAAK6Z,eAAc,WASfH,EAAOW,SAAQ,SAAS5Y,GACf7B,EAAOY,aACRC,QAAQC,IAAI,uBAGhBkK,EAAKnJ,KAAOA,EAERmJ,EAAKnJ,KAAKF,UACVqJ,EAAKnJ,KAAO,IAAI+B,KAAK,GAAI,CACrB1D,KAAM,gBAIVe,GACAA,EAAS+J,EAAKnJ,MAGlBiY,EAAOC,OAAS,UAK5B,IAAIW,GAAoB,EAoDxB,SAASlI,IACLsH,EAAOC,OAAS,GAChBd,GAAc,EACdyB,GAAoB,EASxB,SAASC,IAEL,IAAIC,EAAYrP,SAAShN,cAAc,UACnC+Y,EAAUsD,EAAU/O,WAAW,MAUnC,OAPA+O,EAAUpO,MAAQmM,EAAYnM,MAC9BoO,EAAUnO,OAASkM,EAAYlM,OAG/B6K,EAAQvL,UAAU4M,EAAa,EAAG,GAG3BiC,EAGX,SAASZ,IACL,GAAIU,EAEA,OADA5N,GAAW,IAAIG,MAAOC,UACf9L,WAAW4Y,EAAiB,KAGvC,GAA2C,WAAvCrB,EAAYuB,SAAS9L,cAA4B,CACjD,IAAIrI,GAAW,IAAIkH,MAAOC,UAAYJ,EAYtC,OAVAA,GAAW,IAAIG,MAAOC,UAEtB4M,EAAOC,OAAOjU,KAAK,CACfE,MAAO2U,IACP5U,SAAUA,SAGVkT,GACA7X,WAAW4Y,EAAiBha,EAAOqJ,gBAK3CuP,YAAYD,EAAa,CACrBkC,UAA8C,qBAA5B7a,EAAO8a,kBAAoC9a,EAAO8a,iBACpEC,WAAY,SAAS3R,GACjB,IAAIrD,GAAW,IAAIkH,MAAOC,UAAYJ,EACtC,IAAK/G,EACD,OAAO3E,WAAW4Y,EAAiBha,EAAOqJ,eAI9CyD,GAAW,IAAIG,MAAOC,UAEtB4M,EAAOC,OAAOjU,KAAK,CACfE,MAAOoD,EAAO4C,UAAU,aAAc,GACtCjG,SAAUA,IAGVkT,GACA7X,WAAW4Y,EAAiBha,EAAOqJ,kBA9GnDjJ,KAAK2E,MAAQ,WACT2V,GAAoB,EAEhB1B,aAA+B5R,GAC/B4R,EAAoBjU,SAY5B3E,KAAK4E,OAAS,WACV0V,GAAoB,EAEhB1B,aAA+B5R,EAC/B4R,EAAoBhU,SAInBiU,GACD7Y,KAAKM,UAWbN,KAAKyE,kBAAoB,WACjBoU,GACA7Y,KAAKkB,KAAKkR,GAEdA,KAUJpS,KAAKP,KAAO,iBACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAgEhB,IAAIiN,GAAW,IAAIG,MAAOC,UAEtB4M,EAAS,IAAIkB,EAAOC,MAAM,KA4BlC,SAASlU,EAAehH,EAAaC,GAuFjC,SAASkb,EAAW7R,GAChBA,EAAyC,qBAAlBA,EAAgCA,EAAgB,GAEvE,IAAItD,GAAW,IAAIkH,MAAOC,UAAYJ,EACtC,OAAK/G,EAID2U,GACA5N,GAAW,IAAIG,MAAOC,UACf9L,WAAW8Z,EAAY,OAIlCpO,GAAW,IAAIG,MAAOC,UAElBpG,EAAMqU,QAGNrU,EAAMgF,OAGVwL,EAAQvL,UAAUjF,EAAO,EAAG,EAAGsC,EAAOoD,MAAOpD,EAAOqD,QACpDqN,EAAOC,OAAOjU,KAAK,CACfC,SAAUA,EACVC,MAAOoD,EAAO4C,UAAU,qBAGvBoP,GACDha,WAAW8Z,EAAY7R,EAAeA,KAxB/BjI,WAAW8Z,EAAY7R,EAAeA,GAwDrD,SAASgS,EAAgBC,EAASC,EAAgBC,EAAeC,EAAiBxa,GAC9E,IAAIya,EAAcnQ,SAAShN,cAAc,UACzCmd,EAAYlP,MAAQpD,EAAOoD,MAC3BkP,EAAYjP,OAASrD,EAAOqD,OAC5B,IAAIkP,EAAYD,EAAY7P,WAAW,MACnC+P,EAAe,GAEfC,GAAyC,IAApBN,EACrBO,EAAiBP,GAAkBA,EAAiB,GAAKA,GAAkBD,EAAQ1V,OACnF2V,EAAiBD,EAAQ1V,OACzBmW,EACG,EADHA,EAEG,EAFHA,EAGG,EAEHC,EAAqB5O,KAAK6O,KAC1B7O,KAAKsB,IAAI,IAAK,GACdtB,KAAKsB,IAAI,IAAK,GACdtB,KAAKsB,IAAI,IAAK,IAEdwN,EAAeV,GAAiBA,GAAiB,GAAKA,GAAiB,EAAIA,EAAgB,EAC3FW,EAAiBV,GAAmBA,GAAmB,GAAKA,GAAmB,EAAIA,EAAkB,EACrGW,GAAiB,GAlDzB,SAAmBC,GACf,IAAIxW,GAAK,EACLD,EAASyW,EAAEzW,QAEf,SAAU0W,MACNzW,IACUD,EAMVxE,YAAW,WACPib,EAAEE,eAAeD,EAAMzW,KACxB,GAPCwW,EAAEpb,WAHV,GAgDAub,CAAU,CACN5W,OAAQkW,EACRS,eAAgB,SAASD,EAAMG,GAC3B,IAAIC,EAAeC,EAAaC,EAE5BC,EAAc,YACTT,GAAkBQ,EAAcF,GAAiBE,EAAcT,IAI5DN,IACAO,GAAiB,GAErBR,EAAa9V,KAAKwV,EAAQmB,KAE9BH,KAGJ,GAAKF,EA6BDS,QA7BiB,CACjB,IAAI7W,EAAQ,IAAI8W,MAChB9W,EAAM1C,OAAS,WACXqY,EAAU5P,UAAU/F,EAAO,EAAG,EAAGoD,EAAOoD,MAAOpD,EAAOqD,QACtD,IAAIsQ,EAAYpB,EAAUqB,aAAa,EAAG,EAAG5T,EAAOoD,MAAOpD,EAAOqD,QAClEiQ,EAAgB,EAChBC,EAAcI,EAAU7Y,KAAK0B,OAC7BgX,EAAcG,EAAU7Y,KAAK0B,OAAS,EAEtC,IAAK,IAAIqX,EAAM,EAAGA,EAAMN,EAAaM,GAAO,EAAG,CAC3C,IAAIC,EAAe,CACfC,EAAGJ,EAAU7Y,KAAK+Y,GAClBG,EAAGL,EAAU7Y,KAAK+Y,EAAM,GACxBI,EAAGN,EAAU7Y,KAAK+Y,EAAM,IAEN7P,KAAK6O,KACvB7O,KAAKsB,IAAIwO,EAAaC,EAAIpB,EAAe,GACzC3O,KAAKsB,IAAIwO,EAAaE,EAAIrB,EAAe,GACzC3O,KAAKsB,IAAIwO,EAAaG,EAAItB,EAAe,KAGtBC,EAAqBE,GACxCQ,IAGRG,KAEJ7W,EAAMsX,IAAMhC,EAAQmB,GAAGzW,QAK/B/E,SAAU,YACN2a,EAAeA,EAAa2B,OAAOjC,EAAQhK,MAAMwK,KAEhClW,QAAU,GAGvBgW,EAAa9V,KAAKwV,EAAQA,EAAQ1V,OAAS,IAE/C3E,EAAS2a,OApOrB5b,EAASA,GAAU,IAEPqJ,gBACRrJ,EAAOqJ,cAAgB,IAGtBrJ,EAAOY,aACRC,QAAQC,IAAI,yBAA0Bd,EAAOqJ,eAUjDjJ,KAAKM,OAAS,WACLV,EAAOwM,QACRxM,EAAOwM,MAAQ,KAGdxM,EAAOyM,SACRzM,EAAOyM,OAAS,KAGfzM,EAAO8G,QACR9G,EAAO8G,MAAQ,CACX0F,MAAOxM,EAAOwM,MACdC,OAAQzM,EAAOyM,SAIlBzM,EAAOoJ,SACRpJ,EAAOoJ,OAAS,CACZoD,MAAOxM,EAAOwM,MACdC,OAAQzM,EAAOyM,SAIvBrD,EAAOoD,MAAQxM,EAAOoJ,OAAOoD,OAAS,IACtCpD,EAAOqD,OAASzM,EAAOoJ,OAAOqD,QAAU,IAExC6K,EAAUlO,EAAOyC,WAAW,MAGxB7L,EAAO8G,OAAS9G,EAAO8G,iBAAiBoF,kBACxCpF,EAAQ9G,EAAO8G,MAAM0W,YAEjBxd,EAAOM,cACPN,EAAOM,iBAGXwG,EAAQyE,SAAShN,cAAc,SAE/B2R,EAAanQ,EAAa+G,GAE1BA,EAAM2W,iBAAmB,WACjBzd,EAAOM,cACPN,EAAOM,gBAIfwG,EAAM0F,MAAQxM,EAAO8G,MAAM0F,MAC3B1F,EAAM2F,OAASzM,EAAO8G,MAAM2F,QAGhC3F,EAAM4W,OAAQ,EACd5W,EAAMgF,OAENgB,GAAW,IAAIG,MAAOC,UACtB4M,EAAS,IAAIkB,EAAOC,MAEfjb,EAAOY,cACRC,QAAQC,IAAI,qBAAsBsI,EAAOoD,MAAO,IAAKpD,EAAOqD,QAC5D5L,QAAQC,IAAI,qBAAsBgG,EAAM0F,OAASpD,EAAOoD,MAAO,IAAK1F,EAAM2F,QAAUrD,EAAOqD,SAG/FyO,EAAWlb,EAAOqJ,gBA2JtB,IAAI+R,GAAgB,EAYpBhb,KAAKkB,KAAO,SAASL,GACjBA,EAAWA,GAAY,aAEvBma,GAAgB,EAEhB,IAAIuC,EAAQvd,KAEZgB,YAAW,WAIPia,EAAgBvB,EAAOC,QAAS,EAAG,KAAM,MAAM,SAASA,GACpDD,EAAOC,OAASA,EAGZ/Z,EAAO2F,eAAiB3F,EAAO2F,cAAcC,SAC7CkU,EAAOC,OAAS/Z,EAAO2F,cAAc4X,OAAOzD,EAAOC,SAWvDD,EAAOW,SAAQ,SAAS5Y,GACpB8b,EAAM9b,KAAOA,EAET8b,EAAM9b,KAAKF,UACXgc,EAAM9b,KAAO,IAAI+B,KAAK,GAAI,CACtB1D,KAAM,gBAIVe,GACAA,EAAS0c,EAAM9b,cAI5B,KAGP,IAAI6Y,GAAoB,EA0CxB,SAASlI,IACLsH,EAAOC,OAAS,GAChBqB,GAAgB,EAChBV,GAAoB,EApCxBta,KAAK2E,MAAQ,WACT2V,GAAoB,GAUxBta,KAAK4E,OAAS,WACV0V,GAAoB,EAEhBU,GACAhb,KAAKM,UAWbN,KAAKyE,kBAAoB,WAChBuW,GACDhb,KAAKkB,KAAKkR,GAEdA,KAUJpS,KAAKP,KAAO,iBACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAGhB,IAGIiH,EACAgG,EACAgN,EALA1Q,EAASmC,SAAShN,cAAc,UAChC+Y,EAAUlO,EAAOyC,WAAW,MAj7DR,qBAAjB+B,EACPpH,EAAQoH,aAAeA,EACc,qBAAvBC,qBACdrH,EAAQoH,aAAeC,oBAIvB/N,EAAU0G,QAAUA,EAuhBpB1G,EAAUsH,oBAAsBA,EA+sBhCtH,EAAUqH,oBAAsBA,EAkVhCrH,EAAUkH,eAAiBA,EA0X3BlH,EAAUiH,eAAiBA,EAyB/B,IAAIiU,EAAU,WAGV,SAAS4C,EAAY7X,GACjB3F,KAAK2Z,OAAS,GACd3Z,KAAK2F,SAAWA,GAAY,EAC5B3F,KAAKwJ,QAAU,GA2CnB,SAASiU,EAAkB9D,GAkHvB,SAAS+D,EAAeC,EAAiBC,EAAgBC,GACrD,MAAO,CAAC,CACJ,KAAQF,EACR,GAAM,MACPR,OAAOU,EAAcC,KAAI,SAAS1D,GACjC,IAAI2D,EA6GZ,SAAyBja,GACrB,IAAIka,EAAQ,EAERla,EAAKma,WACLD,GAAS,KAGTla,EAAKoa,YACLF,GAAS,GAGTla,EAAKqa,SACLH,GAAUla,EAAKqa,QAAU,GAGzBra,EAAKsa,cACLJ,GAAS,GAGb,GAAIla,EAAKua,SAAW,IAChB,KAAM,kCAOV,MAJU,CAAiB,IAAhBva,EAAKua,SAAiBva,EAAKwa,UAAY,EAAmB,IAAhBxa,EAAKwa,SAAiBN,GAAOF,KAAI,SAAS/b,GAC3F,OAAOwc,OAAOC,aAAazc,MAC5B0c,KAAK,IAAM3a,EAAKkW,MAtIH0E,CAAgB,CACxBN,YAAa,EACbpE,MAAOI,EAAKtW,KAAKoN,MAAM,GACvBgN,UAAW,EACXD,SAAU,EACVE,OAAQ,EACRE,SAAU,EACVC,SAAUtR,KAAK4B,MAAMgP,KAGzB,OADAA,GAAkBxD,EAAKzU,SAChB,CACH7B,KAAMia,EACN7Q,GAAI,SA6BhB,SAASyR,EAAYC,GAEjB,IADA,IAAIC,EAAQ,GACLD,EAAM,GACTC,EAAMnZ,KAAW,IAANkZ,GACXA,IAAa,EAEjB,OAAO,IAAIE,WAAWD,EAAME,WAShC,SAASC,EAAaC,GAClB,IAAInb,EAAO,GAEXmb,GADWA,EAAKzZ,OAAS,EAAM,IAAIsC,MAAM,EAASmX,EAAKzZ,OAAS,GAAKiZ,KAAK,KAAO,IACpEQ,EACb,IAAK,IAAIxZ,EAAI,EAAGA,EAAIwZ,EAAKzZ,OAAQC,GAAK,EAClC3B,EAAK4B,KAAK0I,SAAS6Q,EAAKC,OAAOzZ,EAAG,GAAI,IAE1C,OAAO,IAAIqZ,WAAWhb,GAmG1B,SAASqb,EAAatJ,EAAQJ,GAC1B,OAAOrH,SAASyH,EAAOqJ,OAAOzJ,EAAS,EAAG,GAAGpO,MAAM,IAAIyW,KAAI,SAASrY,GAChE,IAAI2Z,EAAW3Z,EAAEsQ,WAAW,GAAGtS,SAAS,GACxC,OAAQ,IAAIqE,MAAM,EAAIsX,EAAS5Z,OAAS,GAAIiZ,KAAK,KAAOW,KACzDX,KAAK,IAAK,GA8BjB,IAAIY,EAAO,IA1TX,SAAqB1F,GACjB,IAAI2F,EAwIR,SAAqB3F,GACjB,IAAKA,EAAO,GAIR,YAHAlX,YAAY,CACRwI,MAAO,qFASf,IAJA,IAAImB,EAAQuN,EAAO,GAAGvN,MAClBC,EAASsN,EAAO,GAAGtN,OACnB1G,EAAWgU,EAAO,GAAGhU,SAEhBF,EAAI,EAAGA,EAAIkU,EAAOnU,OAAQC,IAC/BE,GAAYgU,EAAOlU,GAAGE,SAE1B,MAAO,CACHA,SAAUA,EACVyG,MAAOA,EACPC,OAAQA,GA1JDkT,CAAY5F,GACvB,IAAK2F,EACD,MAAO,GAwFX,IArFA,IA6SoBV,EA3ShBvO,EAAO,CAAC,CACR,GAAM,UACN,KAAQ,CAAC,CACL,KAAQ,EACR,GAAM,OACP,CACC,KAAQ,EACR,GAAM,OACP,CACC,KAAQ,EACR,GAAM,OACP,CACC,KAAQ,EACR,GAAM,OACP,CACC,KAAQ,OACR,GAAM,OACP,CACC,KAAQ,EACR,GAAM,OACP,CACC,KAAQ,EACR,GAAM,SAEX,CACC,GAAM,UACN,KAAQ,CAAC,CACL,GAAM,UACN,KAAQ,CAAC,CACL,KAAQ,IACR,GAAM,SACP,CACC,KAAQ,SACR,GAAM,OACP,CACC,KAAQ,SACR,GAAM,OACP,CACC,MAqQQuO,EArQeU,EAAK3Z,SAsQjC,GAAGuL,MAAMlP,KACZ,IAAI8c,WAAY,IAAItJ,aAAa,CAACoJ,IAAO7Y,QAAS,GAAG+X,KAAI,SAAS/b,GAClE,OAAOwc,OAAOC,aAAazc,MAC5Bgd,UAAUN,KAAK,KAxQN,GAAM,SAEX,CACC,GAAM,UACN,KAAQ,CAAC,CACL,GAAM,IACN,KAAQ,CAAC,CACL,KAAQ,EACR,GAAM,KACP,CACC,KAAQ,EACR,GAAM,OACP,CACC,KAAQ,EACR,GAAM,KACP,CACC,KAAQ,MACR,GAAM,SACP,CACC,KAAQ,QACR,GAAM,KACP,CACC,KAAQ,MACR,GAAM,SACP,CACC,KAAQ,EACR,GAAM,KACP,CACC,GAAM,IACN,KAAQ,CAAC,CACL,KAAQa,EAAKlT,MACb,GAAM,KACP,CACC,KAAQkT,EAAKjT,OACb,GAAM,cAQtBmT,EAAc,EACd7B,EAAkB,EACf6B,EAAc7F,EAAOnU,QAAQ,CAEhC,IAAIqY,EAAgB,GAChB4B,EAAkB,EACtB,GACI5B,EAAcnY,KAAKiU,EAAO6F,IAC1BC,GAAmB9F,EAAO6F,GAAa7Z,SACvC6Z,UACKA,EAAc7F,EAAOnU,QAAUia,EA7FnB,KA+FrB,IACIC,EAAU,CACV,GAAM,UACN,KAAQhC,EAAeC,EAHN,EAGuCE,IAE5DxN,EAAK,GAAGvM,KAAK4B,KAAKga,GAClB/B,GAAmB8B,EAGvB,OA0EJ,SAASE,EAAaC,GAElB,IADA,IAAIC,EAAO,GACFpa,EAAI,EAAGA,EAAIma,EAAKpa,OAAQC,IAAK,CAClC,IAAI3B,EAAO8b,EAAKna,GAAG3B,KAEC,kBAATA,IACPA,EAAO6b,EAAa7b,IAGJ,kBAATA,IACPA,EAAOkb,EAAalb,EAAKL,SAAS,KAGlB,kBAATK,IACPA,EA7BD,IAAIgb,WA6BgBhb,EA7BDuD,MAAM,IAAIyW,KAAI,SAAS/b,GAC7C,OAAOA,EAAEgU,WAAW,QA+BpB,IAAI+J,EAAMhc,EAAKnC,MAAQmC,EAAKmT,YAAcnT,EAAK0B,OAC3Cua,EAAS/S,KAAKkI,KAAKlI,KAAKkI,KAAKlI,KAAKtM,IAAIof,GAAO9S,KAAKtM,IAAI,IAAM,GAC5Dsf,EAAeF,EAAIrc,SAAS,GAC5Bwc,EAAU,IAAInY,MAAgB,EAATiY,EAAa,EAAI,EAAKC,EAAaxa,QAASiZ,KAAK,KAAOuB,EAC7Ere,EAAQ,IAAImG,MAAMiY,GAAStB,KAAK,KAAO,IAAMwB,EAEjDJ,EAAKna,KAAKiZ,EAAYiB,EAAKna,GAAGyH,KAC9B2S,EAAKna,KAAKsZ,EAAard,IACvBke,EAAKna,KAAK5B,GAGd,OAAO,IAAIN,KAAKqc,EAAM,CAClB/f,KAAM,eAvGH6f,CAAatP,GA4Mb,CAAgBsJ,EAAOmE,KAAI,SAAS9D,GAC3C,IAAII,EA1DR,SAAmB8F,GAIf,IAHA,IAAIC,EAAMD,EAAKE,KAAK,GAAGC,KAAK,GAExBC,EAAaH,EAAIvS,QAAQ,aACpBnI,EAAI,EAAG8a,EAAI,GAAI9a,EAAI,EAAGA,IAC3B8a,EAAE9a,GAAK0a,EAAIpK,WAAWuK,EAAa,EAAI7a,GAU3C,MAAO,CACH2G,MAJU,OADPmU,EAAE,IAAM,EAAKA,EAAE,IAMlBlU,OAHW,OADRkU,EAAE,IAAM,EAAKA,EAAE,IAKlBzc,KAAMqc,EACND,KAAMA,GAuCCM,CA5Bf,SAASC,EAAU5K,GAIf,IAHA,IAAIJ,EAAS,EACTiL,EAAS,GAENjL,EAASI,EAAOrQ,QAAQ,CAC3B,IAAI0H,EAAK2I,EAAOqJ,OAAOzJ,EAAQ,GAC3BqK,EAAMX,EAAatJ,EAAQJ,GAC3B3R,EAAO+R,EAAOqJ,OAAOzJ,EAAS,EAAI,EAAGqK,GACzCrK,GAAU,EAAQqK,EAClBY,EAAOxT,GAAMwT,EAAOxT,IAAO,GAEhB,SAAPA,GAAwB,SAAPA,EACjBwT,EAAOxT,GAAIxH,KAAK+a,EAAU3c,IAE1B4c,EAAOxT,GAAIxH,KAAK5B,GAGxB,OAAO4c,EAWcD,CAAUE,KAAK3G,EAAMpU,MAAMsL,MAAM,OAEtD,OADAkJ,EAAKzU,SAAWqU,EAAMrU,SACfyU,MAGX3X,YAAY4c,GA4BhB,OA3XA7B,EAAYrW,UAAUyZ,IAAM,SAAS5G,EAAOrU,GASxC,GARI,WAAYqU,IACZA,EAAQA,EAAMhR,QAGd,cAAegR,IACfA,EAAQA,EAAMpO,UAAU,aAAc5L,KAAKwJ,WAGzC,8BAA+ByE,KAAK+L,GACtC,KAAM,kFAEVha,KAAK2Z,OAAOjU,KAAK,CACbE,MAAOoU,EACPrU,SAAUA,GAAY3F,KAAK2F,YA+VnC6X,EAAYrW,UAAUkT,QAAU,SAASxZ,GACrC,IAAIyC,EA5VR,SAA4BC,GACxB,IAAI9B,EAAOI,EAAIC,gBAAgB,IAAI0B,KAAK,CAACD,EAAUE,WAC/C,qCAAuCF,EAAU9D,KAAO,gBACzD,CACCK,KAAM,4BAGN4D,EAAS,IAAIb,OAAOpB,GAExB,OADAI,EAAI8B,gBAAgBlC,GACbiC,EAmVSE,CAAmB6Z,GAEnCna,EAAUO,UAAY,SAASV,GACvBA,EAAMW,KAAKmH,MACXxK,QAAQwK,MAAM9H,EAAMW,KAAKmH,OAG7BpK,EAASsC,EAAMW,OAGnBR,EAAUb,YAAYzC,KAAK2Z,SAGxB,CAUHkB,MAAO2C,GAxZD,GA6ZV9d,EAAUkb,OAASA,EAiCvB,IAAIvY,EAAc,CASdwe,KAAM,WACF,IAAI9gB,EAAOC,KAEX,GAAyB,qBAAd8gB,WAAuD,qBAAnBA,UAAUC,KAAzD,CAKA,IAEIC,EADAC,EAASjhB,KAAKihB,QAAUlV,SAASE,KAAK7B,QAAQ,qBAAsB,IAEpE8W,EAAUJ,UAAUC,KAAKE,EAHb,GAqChBC,EAAQlO,QAAUjT,EAAKohB,QAEvBD,EAAQE,UAAY,aAChBJ,EAAKE,EAAQ7d,QACV2P,QAAUjT,EAAKohB,QAEdH,EAAGK,YA3CK,IA4CJL,EAAGxc,QACcwc,EAAGK,WA7ChB,GA8COD,UAAY,WACnBE,EAAkBN,GAClBO,KAGJA,IAGJA,KAGRL,EAAQM,gBAAkB,SAASre,GAC/Bme,EAAkBne,EAAMC,OAAOC,cA9D/B5C,QAAQwK,MAAM,oDASlB,SAASqW,EAAkBG,GACvBA,EAASH,kBAAkBvhB,EAAK2hB,eAGpC,SAASH,IACL,IAAII,EAAcX,EAAGW,YAAY,CAAC5hB,EAAK2hB,eAAgB,aAcvD,SAASE,EAAaC,GAClBF,EAAYG,YAAY/hB,EAAK2hB,eAAe5jB,IAAI+jB,GAAaT,UAAY,SAASje,GAC1EpD,EAAKc,UACLd,EAAKc,SAASsC,EAAMC,OAAOC,OAAQwe,IAf3C9hB,EAAK2K,WACLiX,EAAYG,YAAY/hB,EAAK2hB,eAAeK,IAAIhiB,EAAK2K,UAAW,aAGhE3K,EAAK4K,SACLgX,EAAYG,YAAY/hB,EAAK2hB,eAAeK,IAAIhiB,EAAK4K,QAAS,WAG9D5K,EAAK0K,WACLkX,EAAYG,YAAY/hB,EAAK2hB,eAAeK,IAAIhiB,EAAK0K,UAAW,aAWpEmX,EAAa,aACbA,EAAa,aACbA,EAAa,aAuCrB1X,MAAO,SAASrJ,GAIZ,OAHAb,KAAKa,SAAWA,EAChBb,KAAK6gB,OAEE7gB,MAcXsC,MAAO,SAAS1C,GAOZ,OANAI,KAAKyK,UAAY7K,EAAO6K,UACxBzK,KAAK0K,UAAY9K,EAAO8K,UACxB1K,KAAK2K,QAAU/K,EAAO+K,QAEtB3K,KAAK6gB,OAEE7gB,MAYXmhB,QAAS,SAASlW,GACdxK,QAAQwK,MAAMqM,KAAKC,UAAUtM,EAAO,KAAM,QAU9CyW,cAAe,YACfT,OAAQ,MA2BZ,SAASna,EAAYnH,EAAaC,GAC9B,GAA0B,qBAAfoiB,WAA4B,CACnC,IAAIC,EAAS9W,SAAShN,cAAc,UACpC8jB,EAAO/E,IAAM,qDACZ/R,SAAS6D,MAAQ7D,SAASC,iBAAiBC,YAAY4W,GAG5DriB,EAASA,GAAU,GAEnB,IAAIsiB,EAAeviB,aAAuB2Z,0BAA4B3Z,aAAuB0Z,kBAS7FrZ,KAAKM,OAAS,WACgB,qBAAf0hB,YAKNG,GAKAD,IACItiB,EAAOwM,QACRxM,EAAOwM,MAAQ1F,EAAM0b,aAAe,KAGnCxiB,EAAOyM,SACRzM,EAAOyM,OAAS3F,EAAM2b,cAAgB,KAGrCziB,EAAO8G,QACR9G,EAAO8G,MAAQ,CACX0F,MAAOxM,EAAOwM,MACdC,OAAQzM,EAAOyM,SAIlBzM,EAAOoJ,SACRpJ,EAAOoJ,OAAS,CACZoD,MAAOxM,EAAOwM,MACdC,OAAQzM,EAAOyM,SAIvBrD,EAAOoD,MAAQxM,EAAOoJ,OAAOoD,OAAS,IACtCpD,EAAOqD,OAASzM,EAAOoJ,OAAOqD,QAAU,IAExC3F,EAAM0F,MAAQxM,EAAO8G,MAAM0F,OAAS,IACpC1F,EAAM2F,OAASzM,EAAO8G,MAAM2F,QAAU,MAI1CiW,EAAa,IAAIN,YAKNO,UAAU,GAMrBD,EAAWE,SAAS5iB,EAAOwJ,WAAa,KASxCkZ,EAAWG,WAAW7iB,EAAO4J,SAAW,IAIxC8Y,EAAWlP,QAEiC,oBAAjCxT,EAAO8iB,uBACd9iB,EAAO8iB,wBAGC7V,KAAK8V,MA0CjBC,EAAqBtW,GAxCrB,SAASuW,EAAeC,GACpB,IAAiC,IAA7B/iB,EAAKgjB,oBAAT,CAIA,GAAIzI,EACA,OAAOtZ,YAAW,WACd6hB,EAAeC,KAChB,KAGPF,EAAqBtW,EAAsBuW,QAEdG,WAAlBC,IACPA,EAAgBH,GAIhBA,EAAOG,EAAgB,MAItBf,GAAgBxb,EAAMqU,QAGvBrU,EAAMgF,OAGLwW,GACDhL,EAAQvL,UAAUjF,EAAO,EAAG,EAAGsC,EAAOoD,MAAOpD,EAAOqD,QAGpDzM,EAAOsjB,cACPtjB,EAAOsjB,aAAala,EAAO4C,UAAU,cAGzC0W,EAAWa,SAASjM,GACpB+L,EAAgBH,OAKhBljB,EAAOM,cACPN,EAAOM,gBAnHPc,WAAWjB,EAAKO,OAAQ,MAiIhCN,KAAKkB,KAAO,SAASL,GACjBA,EAAWA,GAAY,aAEnB+hB,GACAzV,EAAqByV,GAGf/V,KAAK8V,MAUf3iB,KAAKyB,KAAO,IAAI+B,KAAK,CAAC,IAAIsb,WAAWwD,EAAW5S,SAAS0T,MAAO,CAC5DtjB,KAAM,cAGVe,EAASb,KAAKyB,MAGd6gB,EAAW5S,SAAS0T,IAAM,IAG9B,IAAI9I,GAAoB,EASxBta,KAAK2E,MAAQ,WACT2V,GAAoB,GAUxBta,KAAK4E,OAAS,WACV0V,GAAoB,GAUxBta,KAAKyE,kBAAoB,WACrB1E,EAAKgjB,qBAAsB,EAKvBT,IACAA,EAAW5S,SAAS0T,IAAM,KAKlCpjB,KAAKP,KAAO,cACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAGhB,IAAIuJ,EAASmC,SAAShN,cAAc,UAChC+Y,EAAUlO,EAAOyC,WAAW,MAE5ByW,IACIviB,aAAuB2Z,yBAEvBtQ,GADAkO,EAAUvX,GACOqJ,OACVrJ,aAAuB0Z,oBAC9BnC,EAAUvX,EAAY8L,WAAW,MACjCzC,EAASrJ,IAIjB,IAAIwiB,GAAmB,EAEvB,IAAKD,EAAc,CACf,IAAIxb,EAAQyE,SAAShN,cAAc,SACnCuI,EAAM4W,OAAQ,EACd5W,EAAM2c,UAAW,EACjB3c,EAAM4c,aAAc,EAEpBnB,GAAmB,EACnBzb,EAAM2W,iBAAmB,WACrB8E,GAAmB,GAGvBrS,EAAanQ,EAAa+G,GAE1BA,EAAMgF,OAGV,IACwBuX,EAEpBX,EAHAM,EAAqB,KAKrB7iB,EAAOC,KAmBf,SAASujB,EAAkBC,EAAqBC,GAoG5CA,EAAeA,GAAgB,sBAE/B,IAAIC,EAAS,GACTC,GAAsB,EAEtB3a,EAASmC,SAAShN,cAAc,UAChC+Y,EAAUlO,EAAOyC,WAAW,MAChCzC,EAAO6C,MAAM+X,QAAU,EACvB5a,EAAO6C,MAAM/M,SAAW,WACxBkK,EAAO6C,MAAMgY,QAAU,EACvB7a,EAAO6C,MAAM7M,IAAM,UACnBgK,EAAO6C,MAAM+L,KAAO,UACpB5O,EAAO1J,UAAYmkB,GAClBtY,SAAS6D,MAAQ7D,SAASC,iBAAiBC,YAAYrC,GAExDhJ,KAAKQ,aAAc,EACnBR,KAAKiJ,cAAgB,GAErBjJ,KAAKoM,MAAQ,IACbpM,KAAKqM,OAAS,IAGdrM,KAAK8jB,aAAc,EAEnB,IAAI/jB,EAAOC,KAMPwN,EAAe1C,OAAO0C,aAEE,qBAAjBA,IAC2B,qBAAvBC,qBAEPD,EAAeC,oBAGY,qBAApBC,kBAEPF,EAAeE,kBAKvB,IAAI7L,EAAMiJ,OAAOjJ,IAEE,qBAARA,GAA4C,qBAAd+H,YAErC/H,EAAM+H,WAGe,qBAAd9G,WAA+D,qBAA3BA,UAAUkI,eACT,qBAAjClI,UAAU6K,qBACjB7K,UAAUkI,aAAelI,UAAU6K,oBAGE,qBAA9B7K,UAAUC,kBACjBD,UAAUkI,aAAelI,UAAUC,kBAI3C,IAAI8F,EAAciC,OAAOjC,YAEE,qBAAhBA,GAA4D,qBAAtBoH,oBAC7CpH,EAAcoH,mBAIS,qBAAhBpH,GAEmC,qBAA/BA,EAAY1B,UAAUjG,OAC7B2H,EAAY1B,UAAUjG,KAAO,WACzBlB,KAAKiH,YAAY1F,SAAQ,SAAS2O,GAC9BA,EAAMhP,YAMtB,IAAIkF,EAAU,GAsBd,SAAS2d,IACL,IAAIJ,EAAJ,CAIA,IAAIK,EAAeN,EAAOle,OAEtBye,GAAa,EACbC,EAAY,GAchB,GAbAR,EAAOniB,SAAQ,SAASmF,GACfA,EAAMgJ,SACPhJ,EAAMgJ,OAAS,IAGfhJ,EAAMgJ,OAAOuU,WACbA,EAAavd,EAGbwd,EAAUxe,KAAKgB,MAInBud,EACAjb,EAAOoD,MAAQ6X,EAAWvU,OAAOtD,MACjCpD,EAAOqD,OAAS4X,EAAWvU,OAAOrD,YAC/B,GAAI6X,EAAU1e,OAAQ,CACzBwD,EAAOoD,MAAQ4X,EAAe,EAAyB,EAArBE,EAAU,GAAG9X,MAAY8X,EAAU,GAAG9X,MAExE,IAAIC,EAAS,EACQ,IAAjB2X,GAAuC,IAAjBA,IACtB3X,EAAS,GAEQ,IAAjB2X,GAAuC,IAAjBA,IACtB3X,EAAS,GAEQ,IAAjB2X,GAAuC,IAAjBA,IACtB3X,EAAS,GAEQ,IAAjB2X,GAAuC,KAAjBA,IACtB3X,EAAS,GAEbrD,EAAOqD,OAAS6X,EAAU,GAAG7X,OAASA,OAEtCrD,EAAOoD,MAAQrM,EAAKqM,OAAS,IAC7BpD,EAAOqD,OAAStM,EAAKsM,QAAU,IAG/B4X,GAAcA,aAAsBnY,kBACpCH,EAAUsY,GAGdC,EAAU3iB,SAAQ,SAASmF,EAAOuT,GAC9BtO,EAAUjF,EAAOuT,MAGrBjZ,WAAW+iB,EAAoBhkB,EAAKkJ,gBAGxC,SAAS0C,EAAUjF,EAAOuT,GACtB,IAAI0J,EAAJ,CAIA,IAAIQ,EAAI,EACJC,EAAI,EACJhY,EAAQ1F,EAAM0F,MACdC,EAAS3F,EAAM2F,OAEP,IAAR4N,IACAkK,EAAIzd,EAAM0F,OAGF,IAAR6N,IACAmK,EAAI1d,EAAM2F,QAGF,IAAR4N,IACAkK,EAAIzd,EAAM0F,MACVgY,EAAI1d,EAAM2F,QAGF,IAAR4N,IACAmK,EAAmB,EAAf1d,EAAM2F,QAGF,IAAR4N,IACAkK,EAAIzd,EAAM0F,MACVgY,EAAmB,EAAf1d,EAAM2F,QAGF,IAAR4N,IACAmK,EAAmB,EAAf1d,EAAM2F,QAGF,IAAR4N,IACAkK,EAAIzd,EAAM0F,MACVgY,EAAmB,EAAf1d,EAAM2F,QAGmB,qBAAtB3F,EAAMgJ,OAAOkI,OACpBuM,EAAIzd,EAAMgJ,OAAOkI,MAGW,qBAArBlR,EAAMgJ,OAAO1Q,MACpBolB,EAAI1d,EAAMgJ,OAAO1Q,KAGa,qBAAvB0H,EAAMgJ,OAAOtD,QACpBA,EAAQ1F,EAAMgJ,OAAOtD,OAGU,qBAAxB1F,EAAMgJ,OAAOrD,SACpBA,EAAS3F,EAAMgJ,OAAOrD,QAG1B6K,EAAQvL,UAAUjF,EAAOyd,EAAGC,EAAGhY,EAAOC,GAED,oBAA1B3F,EAAMgJ,OAAO2U,UACpB3d,EAAMgJ,OAAO2U,SAASnN,EAASiN,EAAGC,EAAGhY,EAAOC,EAAQ4N,IAyG5D,SAASqK,EAAS5U,GACd,IAAIhJ,EAAQyE,SAAShN,cAAc,SAcnC,OA5PJ,SAAsBuR,EAAQ/C,GACtB,cAAeA,EACfA,EAAQoD,UAAYL,EACb,iBAAkB/C,EACzBA,EAAQqD,aAAeN,EAEvB/C,EAAQoD,UAAYL,EA0OxBI,CAAaJ,EAAQhJ,GAErBA,EAAMpH,UAAYmkB,EAElB/c,EAAM4W,OAAQ,EACd5W,EAAM6d,OAAS,EAEf7d,EAAM0F,MAAQsD,EAAOtD,OAASrM,EAAKqM,OAAS,IAC5C1F,EAAM2F,OAASqD,EAAOrD,QAAUtM,EAAKsM,QAAU,IAE/C3F,EAAMgF,OAEChF,EAsFX,SAAS8d,EAAkBC,GACvBf,EAAS,IACTe,EAAUA,GAAWjB,GAGbjiB,SAAQ,SAASmO,GACrB,GAAKA,EAAOzI,YAAY2I,QAAO,SAASC,GAChC,MAAkB,UAAXA,EAAEF,QACVnK,OAFP,CAMA,IAAIkB,EAAQ4d,EAAS5U,GACrBhJ,EAAMgJ,OAASA,EACfgU,EAAOhe,KAAKgB,OAtWQ,qBAAjB8G,EACPpH,EAAQoH,aAAeA,EACc,qBAAvBC,qBACdrH,EAAQoH,aAAeC,oBAa3BzN,KAAK0kB,mBAAqB,WACtBX,KAoPJ/jB,KAAK2kB,cAAgB,SAASF,GAC1B,IAAKA,EACD,KAAM,+BAGJA,aAAmB3c,QACrB2c,EAAU,CAACA,IAGfA,EAAQljB,SAAQ,SAASmO,GACrB,IAAIhH,EAAY,IAAIG,EAEpB,GAAI6G,EAAOzI,YAAY2I,QAAO,SAASC,GAC/B,MAAkB,UAAXA,EAAEF,QACVnK,OAAQ,CACX,IAAIkB,EAAQ4d,EAAS5U,GACrBhJ,EAAMgJ,OAASA,EACfgU,EAAOhe,KAAKgB,GAEZgC,EAAUI,SAAS4G,EAAOzI,YAAY2I,QAAO,SAASC,GAClD,MAAkB,UAAXA,EAAEF,QACV,IAGP,GAAID,EAAOzI,YAAY2I,QAAO,SAASC,GAC/B,MAAkB,UAAXA,EAAEF,QACVnK,OAAQ,CACX,IAAIof,EAAc7kB,EAAK8kB,aAAazN,wBAAwB1H,GAC5D3P,EAAK+kB,iBAAmB/kB,EAAK8kB,aAAaxM,+BAC1CuM,EAAYlN,QAAQ3X,EAAK+kB,kBAEzBpc,EAAUI,SAAS/I,EAAK+kB,iBAAiBpV,OAAOzI,YAAY2I,QAAO,SAASC,GACxE,MAAkB,UAAXA,EAAEF,QACV,IAGP6T,EAAoB9d,KAAKgD,OAIjC1I,KAAK+kB,eAAiB,WAClBrB,EAAS,GACTC,GAAsB,EAElB5jB,EAAKilB,WACLjlB,EAAKilB,SAASlN,aACd/X,EAAKilB,SAAW,MAGhBjlB,EAAKklB,aAAazf,SAClBzF,EAAKklB,aAAa1jB,SAAQ,SAAS2jB,GAC/BA,EAAOpN,gBAEX/X,EAAKklB,aAAe,IAGpBllB,EAAK+kB,mBACL/kB,EAAK+kB,iBAAiBhN,aACtB/X,EAAK+kB,iBAAmB,MAGxB/kB,EAAK8kB,cACL9kB,EAAK8kB,aAAave,QAGtBvG,EAAK8kB,aAAe,KAEpB3N,EAAQiO,UAAU,EAAG,EAAGnc,EAAOoD,MAAOpD,EAAOqD,QAEzCrD,EAAO0G,SACP1G,EAAO0G,OAAOxO,OACd8H,EAAO0G,OAAS,OAIxB1P,KAAKwkB,kBAAoB,SAASC,IAC1BA,GAAaA,aAAmB3c,QAChC2c,EAAU,CAACA,IAGfD,EAAkBC,IAsBtBzkB,KAAKP,KAAO,oBACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAGhBO,KAAKolB,eAlOL,WACIzB,GAAsB,EACtB,IAAI0B,EAyBR,WAGI,IAAIC,EAFJd,IAII,kBAAmBxb,EACnBsc,EAAiBtc,EAAOsC,gBACjB,qBAAsBtC,EAC7Bsc,EAAiBtc,EAAOuC,mBAChBxL,EAAKS,aACbC,QAAQwK,MAAM,qHAGlB,IAAIsa,EAAc,IAAI1c,EAUtB,OARAyc,EAAere,YAAY2I,QAAO,SAASC,GACvC,MAAkB,UAAXA,EAAEF,QACVpO,SAAQ,SAAS2O,GAChBqV,EAAYzc,SAASoH,MAGzBlH,EAAO0G,OAAS6V,EAETA,EAhDgBC,GAEnBC,EAiDR,WAESrf,EAAQC,0BACTD,EAAQC,wBAA0B,IAAID,EAAQoH,cAGlDzN,EAAK8kB,aAAeze,EAAQC,wBAE5BtG,EAAKklB,aAAe,IAEK,IAArBllB,EAAK+jB,cACL/jB,EAAKilB,SAAWjlB,EAAK8kB,aAAaa,aAClC3lB,EAAKilB,SAAStN,QAAQ3X,EAAK8kB,aAAavM,aACxCvY,EAAKilB,SAASW,KAAK/nB,MAAQ,GAG/B,IAAIgoB,EAAoB,EAmBxB,GAlBApC,EAAoBjiB,SAAQ,SAASmO,GACjC,GAAKA,EAAOzI,YAAY2I,QAAO,SAASC,GAChC,MAAkB,UAAXA,EAAEF,QACVnK,OAFP,CAMAogB,IAEA,IAAIhB,EAAc7kB,EAAK8kB,aAAazN,wBAAwB1H,IAEnC,IAArB3P,EAAK+jB,aACLc,EAAYlN,QAAQ3X,EAAKilB,UAG7BjlB,EAAKklB,aAAavf,KAAKkf,QAGtBgB,EAGD,OAOJ,OAJA7lB,EAAK+kB,iBAAmB/kB,EAAK8kB,aAAaxM,+BAC1CtY,EAAKklB,aAAa1jB,SAAQ,SAASqjB,GAC/BA,EAAYlN,QAAQ3X,EAAK+kB,qBAEtB/kB,EAAK+kB,iBAAiBpV,OA9FNmW,GAoBvB,OAnBIJ,GACAA,EAAiBxe,YAAY2I,QAAO,SAASC,GACzC,MAAkB,UAAXA,EAAEF,QACVpO,SAAQ,SAAS2O,GAChBmV,EAAiBvc,SAASoH,MAKlCsT,EAAoBjiB,SAAQ,SAASmO,GAC7BA,EAAOuU,aACM,KAQdoB,GAyPf,SAAStd,EAAoByb,EAAqBnZ,GAC9CmZ,EAAsBA,GAAuB,GAC7C,IAEIsC,EACAzlB,EAHAN,EAAOC,MAKXqK,EAAUA,GAAW,CACjBoZ,aAAc,sBACdrc,SAAU,aACVV,MAAO,CACH0F,MAAO,IACPC,OAAQ,OAIHpD,gBACToB,EAAQpB,cAAgB,IAGvBoB,EAAQ3D,QACT2D,EAAQ3D,MAAQ,IAGf2D,EAAQ3D,MAAM0F,QACf/B,EAAQ3D,MAAM0F,MAAQ,KAGrB/B,EAAQ3D,MAAM2F,SACfhC,EAAQ3D,MAAM2F,OAAS,KAU3BrM,KAAKM,OAAS,WAEVwlB,EAAQ,IAAIvC,EAAkBC,EAAqBnZ,EAAQoZ,cAAgB,uBAkB/E,WACI,IAAIsC,EAAS,GAMb,OALAvC,EAAoBjiB,SAAQ,SAASmO,GACjCzI,EAAUyI,EAAQ,SAASnO,SAAQ,SAAS2O,GACxC6V,EAAOrgB,KAAKwK,SAGb6V,EAvBHC,GAAoBxgB,SACpBsgB,EAAM7c,cAAgBoB,EAAQpB,eAAiB,GAC/C6c,EAAM1Z,MAAQ/B,EAAQ3D,MAAM0F,OAAS,IACrC0Z,EAAMzZ,OAAShC,EAAQ3D,MAAM2F,QAAU,IACvCyZ,EAAMpB,sBAGNra,EAAQ4b,eAAkD,oBAA1B5b,EAAQ4b,eACxC5b,EAAQ4b,cAAcH,EAAMV,mBAIhC/kB,EAAgB,IAAI2G,EAAoB8e,EAAMV,iBAAkB/a,IAClD/J,UAuBlBN,KAAKkB,KAAO,SAASL,GACZR,GAILA,EAAca,MAAK,SAASO,GACxB1B,EAAK0B,KAAOA,EAEZZ,EAASY,GAET1B,EAAK0E,wBAWbzE,KAAK2E,MAAQ,WACLtE,GACAA,EAAcsE,SAWtB3E,KAAK4E,OAAS,WACNvE,GACAA,EAAcuE,UAWtB5E,KAAKyE,kBAAoB,WACjBpE,IACAA,EAAcoE,oBACdpE,EAAgB,MAGhBylB,IACAA,EAAMf,iBACNe,EAAQ,OAYhB9lB,KAAKkmB,WAAa,SAASzB,GACvB,IAAKA,EACD,KAAM,+BAGJA,aAAmB3c,QACrB2c,EAAU,CAACA,IAGfjB,EAAoBrG,OAAOsH,GAEtBpkB,GAAkBylB,IAIvBA,EAAMnB,cAAcF,GAEhBpa,EAAQ4b,eAAkD,oBAA1B5b,EAAQ4b,eACxC5b,EAAQ4b,cAAcH,EAAMV,oBAYpCplB,KAAKwkB,kBAAoB,SAASC,GACzBqB,KAIDrB,GAAaA,aAAmB3c,QAChC2c,EAAU,CAACA,IAGfqB,EAAMtB,kBAAkBC,KAW5BzkB,KAAKmmB,SAAW,WACZ,OAAOL,GAIX9lB,KAAKP,KAAO,sBACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAmTpB,SAASoH,EAAoB6I,EAAQ9P,GAqBjC,SAASwmB,IACL,OAAO,IAAIze,eAAe,CACtByL,MAAO,SAASiT,GACZ,IAAIC,EAAMnb,SAAShN,cAAc,UAC7BuI,EAAQyE,SAAShN,cAAc,SACnCuI,EAAMqJ,UAAYL,EAClBhJ,EAAM6f,UAAY,WACdD,EAAIla,MAAQxM,EAAOwM,MACnBka,EAAIja,OAASzM,EAAOyM,OACpB,IAAIma,EAAMF,EAAI7a,WAAW,MACrBgb,EAAe,IAAO7mB,EAAOwJ,UACjCpI,YAAW,SAASqb,IAChBmK,EAAI7a,UAAUjF,EAAO,EAAG,GACxB2f,EAAWK,QACPF,EAAI5J,aAAa,EAAG,EAAGhd,EAAOwM,MAAOxM,EAAOyM,SAEhDrL,WAAWqb,EAAGoK,KACfA,IAEP/f,EAAMgF,UAKlB,IAAIhI,EA0EAsT,EApH0B,qBAAnBrP,gBAA4D,qBAAnBgf,gBAEhDlmB,QAAQwK,MAAM,4HAGlBrL,EAASA,GAAU,IAEZwM,MAAQxM,EAAOwM,OAAS,IAC/BxM,EAAOyM,OAASzM,EAAOyM,QAAU,IACjCzM,EAAOwJ,UAAYxJ,EAAOwJ,WAAa,GACvCxJ,EAAOyJ,QAAUzJ,EAAOyJ,SAAW,KA+FnCrJ,KAAKM,OAAS,WACVsmB,EAAiB,GACjB5P,GAAW,EACXhX,KAAKyB,KAAO,KAhEhB,SAAS6C,EAAeoL,EAAQ3J,GAC5B,GAAKnG,EAAOsJ,YAAenD,EAA3B,CAYA,IAAKnG,EAAOsJ,YAAcnD,aAAkBuQ,YAAa,CACrD,IAAI7U,EAAO,IAAI+B,KAAK,CAACuC,GAAS,CAC1BjG,KAAM,oBAEVF,EAAOsJ,WAAarH,EAAIC,gBAAgBL,GAGvC7B,EAAOsJ,YACRzI,QAAQwK,MAAM,qCAGlBvH,EAAS,IAAIb,OAAOjD,EAAOsJ,aAEpBzG,YAAY7C,EAAOuJ,iBAAmB,0DAC7CzF,EAAOmjB,iBAAiB,WAAW,SAAS1jB,GACrB,UAAfA,EAAMW,MACNJ,EAAOjB,YAAY,CACf2J,MAAOxM,EAAOwM,MACdC,OAAQzM,EAAOyM,OACfhD,QAASzJ,EAAOyJ,SAAW,KAC3Byd,YAAalnB,EAAOwJ,WAAa,GACjC2d,UAAU,IAGdX,IAAeY,OAAO,IAAIL,eAAe,CACrCM,MAAO,SAASrhB,GACPlC,GAILA,EAAOjB,YAAYmD,EAAM9B,KAAKiC,OAAQ,CAACH,EAAM9B,KAAKiC,cAGjD5C,EAAMW,OACVkT,GACD4P,EAAelhB,KAAKvC,EAAMW,eA7ClCojB,MACI,0DACFC,MAAK,SAASpK,GACZA,EAAEqK,cAAcD,MAAK,SAASphB,GAC1BzB,EAAeoL,EAAQ3J,SA0DnCzB,CAAeoL,GAEoB,oBAAxB9P,EAAOM,cACdN,EAAOM,gBAafF,KAAK2E,MAAQ,WACTqS,GAAW,GAUfhX,KAAK4E,OAAS,WACVoS,GAAW,GAaf,IAAI4P,EAAiB,GAYrB5mB,KAAKkB,KAAO,SAASL,GArBZ6C,IAILA,EAAOjB,YAAY,MACnBiB,EAAOmT,YACPnT,EAAS,MAkBT1D,KAAKyB,KAAO,IAAI+B,KAAKojB,EAAgB,CACjC9mB,KAAM,eAGVe,EAASb,KAAKyB,OAIlBzB,KAAKP,KAAO,sBACZO,KAAKyD,SAAW,WACZ,OAAOzD,KAAKP,MAUhBO,KAAKyE,kBAAoB,WACrBmiB,EAAiB,GACjB5P,GAAW,EACXhX,KAAKyB,KAAO,MAahBzB,KAAKyB,KAAO,KA7kDZ/B,EAAU2C,YAAcA,EA+RxB3C,EAAUoH,YAAcA,EAozBxBpH,EAAUqI,oBAAsBA,EAuRhCrI,EAAU2nB,yBA3Pd,SAAkC1nB,EAAa0K,GAC3C,IAAKrK,KACD,KAAM,uCAGV,GAA2B,qBAAhBL,EACP,KAAM,4CAGV,IAAII,EAAOC,KAUXD,EAAKunB,UAAY,IAAI5nB,EAAUC,EAAa0K,GAW5CrK,KAAKsE,eAAiB,WAClB,OAAO,IAAIijB,SAAQ,SAASC,EAASC,GACjC,IACI1nB,EAAKunB,UAAUhjB,iBACfkjB,IACF,MAAOzlB,GACL0lB,EAAO1lB,QAcnB/B,KAAKY,cAAgB,WACjB,OAAO,IAAI2mB,SAAQ,SAASC,EAASC,GACjC,IACI1nB,EAAKunB,UAAU1mB,eAAc,SAASgB,GAClC7B,EAAK0B,KAAO1B,EAAKunB,UAAUxiB,UAEtB/E,EAAK0B,MAAS1B,EAAK0B,KAAKE,KAK7B6lB,EAAQ5lB,GAJJ6lB,EAAO,cAAe1nB,EAAK0B,SAMrC,MAAOM,GACL0lB,EAAO1lB,QAcnB/B,KAAK0E,eAAiB,WAClB,OAAO,IAAI6iB,SAAQ,SAASC,EAASC,GACjC,IACI1nB,EAAKunB,UAAU5iB,iBACf8iB,IACF,MAAOzlB,GACL0lB,EAAO1lB,QAcnB/B,KAAKe,gBAAkB,WACnB,OAAO,IAAIwmB,SAAQ,SAASC,EAASC,GACjC,IACI1nB,EAAKunB,UAAUvmB,kBACfymB,IACF,MAAOzlB,GACL0lB,EAAO1lB,QAgBnB/B,KAAKkC,WAAa,SAASrB,GACvB,OAAO,IAAI0mB,SAAQ,SAASC,EAASC,GACjC,IACI1nB,EAAKunB,UAAUplB,YAAW,SAASC,GAC/BqlB,EAAQrlB,MAEd,MAAOJ,GACL0lB,EAAO1lB,QAcnB/B,KAAK8E,QAAU,WACX,OAAO,IAAIyiB,SAAQ,SAASC,EAASC,GACjC,IACID,EAAQznB,EAAKunB,UAAUxiB,WACzB,MAAO/C,GACL0lB,EAAO1lB,QAiBnB/B,KAAKgF,oBAAsB,WACvB,OAAO,IAAIuiB,SAAQ,SAASC,EAASC,GACjC,IACID,EAAQznB,EAAKunB,UAAUtiB,uBACzB,MAAOjD,GACL0lB,EAAO1lB,QAanB/B,KAAKgG,MAAQ,WACT,OAAO,IAAIuhB,SAAQ,SAASC,EAASC,GACjC,IACID,EAAQznB,EAAKunB,UAAUthB,SACzB,MAAOjE,GACL0lB,EAAO1lB,QAYnB/B,KAAKkG,QAAU,WACX,OAAO,IAAIqhB,SAAQ,SAASC,EAASC,GACjC,IACID,EAAQznB,EAAKunB,UAAUphB,WACzB,MAAOnE,GACL0lB,EAAO1lB,QAenB/B,KAAKiG,SAAW,WACZ,OAAO,IAAIshB,SAAQ,SAASC,EAASC,GACjC,IACID,EAAQznB,EAAKunB,UAAUrhB,YACzB,MAAOlE,GACL0lB,EAAO1lB,QAanB/B,KAAKyB,KAAO,KAWZzB,KAAKwE,QAAU,SA2Of9E,EAAUmH,oBAAsBA,I,yDC/gMpC,IAAItJ,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQK,aAAU,EAElB,IAAIC,EAASV,EAAuBC,EAAQ,IAIxCU,GAAW,EAFMX,EAAuBC,EAAQ,KAElBQ,SAASC,EAAOD,QAAQG,cAAcF,EAAOD,QAAQI,SAAU,KAAMH,EAAOD,QAAQG,cAAc,OAAQ,CAC1IG,KAAM,OACND,EAAG,kBACDJ,EAAOD,QAAQG,cAAc,OAAQ,CACvCE,EAAG,uSACA,UAELV,EAAQK,QAAUE,G,kIClBdwpB,EAAe,GAEfC,EAAa,EAEbC,EAAmB,SAA0BC,GAC/C,IAAIC,EAAWD,EACXE,EAAQL,EAAaI,KAAcJ,EAAaI,GAAY,IAEhE,GAAIC,EAAMF,GAAU,OAAOE,EAAMF,GAEjC,IAAIG,EAAoBC,IAAa5N,QAAQwN,GAO7C,OALIF,EAXW,MAYbI,EAAMF,GAAWG,EACjBL,KAGKK,GAiBME,EAXI,WACjB,IAAIL,EAAU3c,UAAU1F,OAAS,QAAsBwd,IAAjB9X,UAAU,GAAmBA,UAAU,GAAK,IAC9Eid,EAASjd,UAAU1F,OAAS,QAAsBwd,IAAjB9X,UAAU,GAAmBA,UAAU,GAAK,GAEjF,GAAgB,MAAZ2c,EACF,OAAOA,EAET,IAAIO,EAAYR,EAAiBC,GACjC,OAAOO,EAAUD,EAAQ,CAAEE,QAAQ,KCjCjCC,EAAW7qB,OAAO8qB,QAAU,SAAUnlB,GAAU,IAAK,IAAIqC,EAAI,EAAGA,EAAIyF,UAAU1F,OAAQC,IAAK,CAAE,IAAIyf,EAASha,UAAUzF,GAAI,IAAK,IAAIjE,KAAO0jB,EAAcznB,OAAO0J,UAAUqhB,eAAexmB,KAAKkjB,EAAQ1jB,KAAQ4B,EAAO5B,GAAO0jB,EAAO1jB,IAAY,OAAO4B,GAEvP,SAASqlB,EAAgBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,qCAEhH,SAASC,EAA2B9oB,EAAMiC,GAAQ,IAAKjC,EAAQ,MAAM,IAAI+oB,eAAe,6DAAgE,OAAO9mB,GAAyB,kBAATA,GAAqC,oBAATA,EAA8BjC,EAAPiC,EAgBlO,IAAI+mB,EAAW,SAAUC,GAGvB,SAASD,IAGP,OAFAN,EAAgBzoB,KAAM+oB,GAEfF,EAA2B7oB,KAAMgpB,EAAiBC,MAAMjpB,KAAMkL,YA+DvE,OAnFF,SAAmBge,EAAUC,GAAc,GAA0B,oBAAfA,GAA4C,OAAfA,EAAuB,MAAM,IAAIP,UAAU,kEAAoEO,GAAeD,EAAS/hB,UAAY1J,OAAO2rB,OAAOD,GAAcA,EAAWhiB,UAAW,CAAExG,YAAa,CAAE/C,MAAOsrB,EAAUrrB,YAAY,EAAOwrB,UAAU,EAAMC,cAAc,KAAeH,IAAY1rB,OAAO8rB,eAAiB9rB,OAAO8rB,eAAeL,EAAUC,GAAcD,EAASM,UAAYL,GAe/dM,CAAUV,EAAUC,GAQpBD,EAAS5hB,UAAUuiB,SAAW,WAC5B,OAAO1pB,KAAKkX,QAAQyS,QAAU3pB,KAAKkX,QAAQyS,OAAOC,eAGpDb,EAAS5hB,UAAU0iB,mBAAqB,WACtCC,IAAU9pB,KAAKkX,QAAQyS,OAAQ,oDAE3B3pB,KAAK0pB,YAAY1pB,KAAK+pB,WAG5BhB,EAAS5hB,UAAU6iB,kBAAoB,WAChChqB,KAAK0pB,YAAY1pB,KAAK+pB,WAG7BhB,EAAS5hB,UAAU8iB,mBAAqB,SAA4BC,GAClE,IAAIC,EAASC,YAAeF,EAAUG,IAClCC,EAASF,YAAepqB,KAAKb,MAAMkrB,IAEnCE,YAAkBJ,EAAQG,GAC5BE,KAAQ,EAAO,kEAA0EF,EAAOG,SAAWH,EAAOI,OAAS,KAI7H1qB,KAAK+pB,WAGPhB,EAAS5hB,UAAUwjB,UAAY,SAAmBC,GAChD,IAAIC,EAAgBD,EAAKC,cACrBR,EAAKO,EAAKP,GAEd,OAAIQ,EACgB,kBAAPR,EACFnC,EAAamC,EAAIQ,EAAc1C,QAE/BG,EAAS,GAAI+B,EAAI,CACtBI,SAAUvC,EAAamC,EAAGI,SAAUI,EAAc1C,UAKjDkC,GAGTtB,EAAS5hB,UAAU4iB,QAAU,WAC3B,IAAIe,EAAU9qB,KAAKkX,QAAQyS,OAAOmB,QAC9BplB,EAAO1F,KAAKb,MAAMuG,KAElB2kB,EAAKrqB,KAAK2qB,UAAU3qB,KAAKb,OAEzBuG,EACFolB,EAAQplB,KAAK2kB,GAEbS,EAAQ1gB,QAAQigB,IAIpBtB,EAAS5hB,UAAU4jB,OAAS,WAC1B,OAAO,MAGFhC,EArEM,CAsEbiC,IAAMC,WAERlC,EAASmC,UAAY,CACnBL,cAAeM,IAAUC,OACzB1lB,KAAMylB,IAAUE,KAChBC,KAAMH,IAAUtV,OAChBwU,GAAIc,IAAUI,UAAU,CAACJ,IAAUtV,OAAQsV,IAAUC,SAASI,YAEhEzC,EAAS0C,aAAe,CACtB/lB,MAAM,GAERqjB,EAAS2C,aAAe,CACtB/B,OAAQwB,IAAUQ,MAAM,CACtBb,QAASK,IAAUQ,MAAM,CACvBjmB,KAAMylB,IAAUS,KAAKJ,WACrBphB,QAAS+gB,IAAUS,KAAKJ,aACvBA,WACH5B,cAAeuB,IAAUC,SACxBI,YAIUzC,QC7GAA","file":"static/js/47.222ce357.chunk.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function get() {\n    return _Drawer.default;\n  }\n});\n\nvar _Drawer = _interopRequireDefault(require(\"./Drawer\"));","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(\"path\", {\n  d: \"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"\n}), _react.default.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0z\"\n})), 'ChevronRight');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(\"path\", {\n  d: \"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"\n}), _react.default.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0z\"\n})), 'ChevronLeft');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(\"path\", {\n  d: \"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"\n}), _react.default.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0z\"\n})), 'Person');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function get() {\n    return _ListItemSecondaryAction.default;\n  }\n});\n\nvar _ListItemSecondaryAction = _interopRequireDefault(require(\"./ListItemSecondaryAction\"));","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.styles = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _withStyles = _interopRequireDefault(require(\"../styles/withStyles\"));\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    position: 'absolute',\n    right: 4,\n    top: '50%',\n    transform: 'translateY(-50%)'\n  }\n};\n/**\n * Must be used as the last child of ListItem to function properly.\n */\n\nexports.styles = styles;\n\nfunction ListItemSecondaryAction(props) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      other = (0, _objectWithoutProperties2.default)(props, [\"children\", \"classes\", \"className\"]);\n  return _react.default.createElement(\"div\", (0, _extends2.default)({\n    className: (0, _classnames.default)(classes.root, className)\n  }, other), children);\n}\n\nprocess.env.NODE_ENV !== \"production\" ? ListItemSecondaryAction.propTypes = {\n  /**\n   * The content of the component, normally an `IconButton` or selection control.\n   */\n  children: _propTypes.default.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css-api) below for more details.\n   */\n  classes: _propTypes.default.object.isRequired,\n\n  /**\n   * @ignore\n   */\n  className: _propTypes.default.string\n} : void 0;\nListItemSecondaryAction.muiName = 'ListItemSecondaryAction';\n\nvar _default = (0, _withStyles.default)(styles, {\n  name: 'MuiListItemSecondaryAction'\n})(ListItemSecondaryAction);\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(\"path\", {\n  d: \"M2.01 21L23 12 2.01 3 2 10l15 2-15 2z\"\n}), _react.default.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0z\"\n})), 'Send');\n\nexports.default = _default;","'use strict';\r\n\r\n// Last time updated: 2020-02-26 1:11:47 PM UTC\r\n\r\n// ________________\r\n// RecordRTC v5.5.9\r\n\r\n// Open-Sourced: https://github.com/muaz-khan/RecordRTC\r\n\r\n// --------------------------------------------------\r\n// Muaz Khan     - www.MuazKhan.com\r\n// MIT License   - www.WebRTC-Experiment.com/licence\r\n// --------------------------------------------------\r\n\r\n// ____________\r\n// RecordRTC.js\r\n\r\n/**\r\n * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. \r\n * @summary Record audio, video or screen inside the browser.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef RecordRTC\r\n * @class\r\n * @example\r\n * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {\r\n *     type: 'video', // audio or video or gif or canvas\r\n *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc\r\n * });\r\n * recorder.startRecording();\r\n * @see For further information:\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\r\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}\r\n */\r\n\r\nfunction RecordRTC(mediaStream, config) {\r\n    if (!mediaStream) {\r\n        throw 'First parameter is required.';\r\n    }\r\n\r\n    config = config || {\r\n        type: 'video'\r\n    };\r\n\r\n    config = new RecordRTCConfiguration(mediaStream, config);\r\n\r\n    // a reference to user's recordRTC object\r\n    var self = this;\r\n\r\n    function startRecording(config2) {\r\n        if (!config.disableLogs) {\r\n            console.log('RecordRTC version: ', self.version);\r\n        }\r\n\r\n        if (!!config2) {\r\n            // allow users to set options using startRecording method\r\n            // config2 is similar to main \"config\" object (second parameter over RecordRTC constructor)\r\n            config = new RecordRTCConfiguration(mediaStream, config2);\r\n        }\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('started recording ' + config.type + ' stream.');\r\n        }\r\n\r\n        if (mediaRecorder) {\r\n            mediaRecorder.clearRecordedData();\r\n            mediaRecorder.record();\r\n\r\n            setState('recording');\r\n\r\n            if (self.recordingDuration) {\r\n                handleRecordingDuration();\r\n            }\r\n            return self;\r\n        }\r\n\r\n        initRecorder(function() {\r\n            if (self.recordingDuration) {\r\n                handleRecordingDuration();\r\n            }\r\n        });\r\n\r\n        return self;\r\n    }\r\n\r\n    function initRecorder(initCallback) {\r\n        if (initCallback) {\r\n            config.initCallback = function() {\r\n                initCallback();\r\n                initCallback = config.initCallback = null; // recorder.initRecorder should be call-backed once.\r\n            };\r\n        }\r\n\r\n        var Recorder = new GetRecorderType(mediaStream, config);\r\n\r\n        mediaRecorder = new Recorder(mediaStream, config);\r\n        mediaRecorder.record();\r\n\r\n        setState('recording');\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('Initialized recorderType:', mediaRecorder.constructor.name, 'for output-type:', config.type);\r\n        }\r\n    }\r\n\r\n    function stopRecording(callback) {\r\n        callback = callback || function() {};\r\n\r\n        if (!mediaRecorder) {\r\n            warningLog();\r\n            return;\r\n        }\r\n\r\n        if (self.state === 'paused') {\r\n            self.resumeRecording();\r\n\r\n            setTimeout(function() {\r\n                stopRecording(callback);\r\n            }, 1);\r\n            return;\r\n        }\r\n\r\n        if (self.state !== 'recording' && !config.disableLogs) {\r\n            console.warn('Recording state should be: \"recording\", however current state is: ', self.state);\r\n        }\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('Stopped recording ' + config.type + ' stream.');\r\n        }\r\n\r\n        if (config.type !== 'gif') {\r\n            mediaRecorder.stop(_callback);\r\n        } else {\r\n            mediaRecorder.stop();\r\n            _callback();\r\n        }\r\n\r\n        setState('stopped');\r\n\r\n        function _callback(__blob) {\r\n            if (!mediaRecorder) {\r\n                if (typeof callback.call === 'function') {\r\n                    callback.call(self, '');\r\n                } else {\r\n                    callback('');\r\n                }\r\n                return;\r\n            }\r\n\r\n            Object.keys(mediaRecorder).forEach(function(key) {\r\n                if (typeof mediaRecorder[key] === 'function') {\r\n                    return;\r\n                }\r\n\r\n                self[key] = mediaRecorder[key];\r\n            });\r\n\r\n            var blob = mediaRecorder.blob;\r\n\r\n            if (!blob) {\r\n                if (__blob) {\r\n                    mediaRecorder.blob = blob = __blob;\r\n                } else {\r\n                    throw 'Recording failed.';\r\n                }\r\n            }\r\n\r\n            if (blob && !config.disableLogs) {\r\n                console.log(blob.type, '->', bytesToSize(blob.size));\r\n            }\r\n\r\n            if (callback) {\r\n                var url;\r\n\r\n                try {\r\n                    url = URL.createObjectURL(blob);\r\n                } catch (e) {}\r\n\r\n                if (typeof callback.call === 'function') {\r\n                    callback.call(self, url);\r\n                } else {\r\n                    callback(url);\r\n                }\r\n            }\r\n\r\n            if (!config.autoWriteToDisk) {\r\n                return;\r\n            }\r\n\r\n            getDataURL(function(dataURL) {\r\n                var parameter = {};\r\n                parameter[config.type + 'Blob'] = dataURL;\r\n                DiskStorage.Store(parameter);\r\n            });\r\n        }\r\n    }\r\n\r\n    function pauseRecording() {\r\n        if (!mediaRecorder) {\r\n            warningLog();\r\n            return;\r\n        }\r\n\r\n        if (self.state !== 'recording') {\r\n            if (!config.disableLogs) {\r\n                console.warn('Unable to pause the recording. Recording state: ', self.state);\r\n            }\r\n            return;\r\n        }\r\n\r\n        setState('paused');\r\n\r\n        mediaRecorder.pause();\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('Paused recording.');\r\n        }\r\n    }\r\n\r\n    function resumeRecording() {\r\n        if (!mediaRecorder) {\r\n            warningLog();\r\n            return;\r\n        }\r\n\r\n        if (self.state !== 'paused') {\r\n            if (!config.disableLogs) {\r\n                console.warn('Unable to resume the recording. Recording state: ', self.state);\r\n            }\r\n            return;\r\n        }\r\n\r\n        setState('recording');\r\n\r\n        // not all libs have this method yet\r\n        mediaRecorder.resume();\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('Resumed recording.');\r\n        }\r\n    }\r\n\r\n    function readFile(_blob) {\r\n        postMessage(new FileReaderSync().readAsDataURL(_blob));\r\n    }\r\n\r\n    function getDataURL(callback, _mediaRecorder) {\r\n        if (!callback) {\r\n            throw 'Pass a callback function over getDataURL.';\r\n        }\r\n\r\n        var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;\r\n\r\n        if (!blob) {\r\n            if (!config.disableLogs) {\r\n                console.warn('Blob encoder did not finish its job yet.');\r\n            }\r\n\r\n            setTimeout(function() {\r\n                getDataURL(callback, _mediaRecorder);\r\n            }, 1000);\r\n            return;\r\n        }\r\n\r\n        if (typeof Worker !== 'undefined' && !navigator.mozGetUserMedia) {\r\n            var webWorker = processInWebWorker(readFile);\r\n\r\n            webWorker.onmessage = function(event) {\r\n                callback(event.data);\r\n            };\r\n\r\n            webWorker.postMessage(blob);\r\n        } else {\r\n            var reader = new FileReader();\r\n            reader.readAsDataURL(blob);\r\n            reader.onload = function(event) {\r\n                callback(event.target.result);\r\n            };\r\n        }\r\n\r\n        function processInWebWorker(_function) {\r\n            try {\r\n                var blob = URL.createObjectURL(new Blob([_function.toString(),\r\n                    'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\r\n                ], {\r\n                    type: 'application/javascript'\r\n                }));\r\n\r\n                var worker = new Worker(blob);\r\n                URL.revokeObjectURL(blob);\r\n                return worker;\r\n            } catch (e) {}\r\n        }\r\n    }\r\n\r\n    function handleRecordingDuration(counter) {\r\n        counter = counter || 0;\r\n\r\n        if (self.state === 'paused') {\r\n            setTimeout(function() {\r\n                handleRecordingDuration(counter);\r\n            }, 1000);\r\n            return;\r\n        }\r\n\r\n        if (self.state === 'stopped') {\r\n            return;\r\n        }\r\n\r\n        if (counter >= self.recordingDuration) {\r\n            stopRecording(self.onRecordingStopped);\r\n            return;\r\n        }\r\n\r\n        counter += 1000; // 1-second\r\n\r\n        setTimeout(function() {\r\n            handleRecordingDuration(counter);\r\n        }, 1000);\r\n    }\r\n\r\n    function setState(state) {\r\n        if (!self) {\r\n            return;\r\n        }\r\n\r\n        self.state = state;\r\n\r\n        if (typeof self.onStateChanged.call === 'function') {\r\n            self.onStateChanged.call(self, state);\r\n        } else {\r\n            self.onStateChanged(state);\r\n        }\r\n    }\r\n\r\n    var WARNING = 'It seems that recorder is destroyed or \"startRecording\" is not invoked for ' + config.type + ' recorder.';\r\n\r\n    function warningLog() {\r\n        if (config.disableLogs === true) {\r\n            return;\r\n        }\r\n\r\n        console.warn(WARNING);\r\n    }\r\n\r\n    var mediaRecorder;\r\n\r\n    var returnObject = {\r\n        /**\r\n         * This method starts the recording.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * var recorder = RecordRTC(mediaStream, {\r\n         *     type: 'video'\r\n         * });\r\n         * recorder.startRecording();\r\n         */\r\n        startRecording: startRecording,\r\n\r\n        /**\r\n         * This method stops the recording. It is strongly recommended to get \"blob\" or \"URI\" inside the callback to make sure all recorders finished their job.\r\n         * @param {function} callback - Callback to get the recorded blob.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     // use either \"this\" or \"recorder\" object; both are identical\r\n         *     video.src = this.toURL();\r\n         *     var blob = this.getBlob();\r\n         * });\r\n         */\r\n        stopRecording: stopRecording,\r\n\r\n        /**\r\n         * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo Firefox is unable to pause the recording. Fix it.\r\n         * @example\r\n         * recorder.pauseRecording();  // pause the recording\r\n         * recorder.resumeRecording(); // resume again\r\n         */\r\n        pauseRecording: pauseRecording,\r\n\r\n        /**\r\n         * This method resumes the recording.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.pauseRecording();  // first of all, pause the recording\r\n         * recorder.resumeRecording(); // now resume it\r\n         */\r\n        resumeRecording: resumeRecording,\r\n\r\n        /**\r\n         * This method initializes the recording.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo This method should be deprecated.\r\n         * @example\r\n         * recorder.initRecorder();\r\n         */\r\n        initRecorder: initRecorder,\r\n\r\n        /**\r\n         * Ask RecordRTC to auto-stop the recording after 5 minutes.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * var fiveMinutes = 5 * 1000 * 60;\r\n         * recorder.setRecordingDuration(fiveMinutes, function() {\r\n         *    var blob = this.getBlob();\r\n         *    video.src = this.toURL();\r\n         * });\r\n         * \r\n         * // or otherwise\r\n         * recorder.setRecordingDuration(fiveMinutes).onRecordingStopped(function() {\r\n         *    var blob = this.getBlob();\r\n         *    video.src = this.toURL();\r\n         * });\r\n         */\r\n        setRecordingDuration: function(recordingDuration, callback) {\r\n            if (typeof recordingDuration === 'undefined') {\r\n                throw 'recordingDuration is required.';\r\n            }\r\n\r\n            if (typeof recordingDuration !== 'number') {\r\n                throw 'recordingDuration must be a number.';\r\n            }\r\n\r\n            self.recordingDuration = recordingDuration;\r\n            self.onRecordingStopped = callback || function() {};\r\n\r\n            return {\r\n                onRecordingStopped: function(callback) {\r\n                    self.onRecordingStopped = callback;\r\n                }\r\n            };\r\n        },\r\n\r\n        /**\r\n         * This method can be used to clear/reset all the recorded data.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo Figure out the difference between \"reset\" and \"clearRecordedData\" methods.\r\n         * @example\r\n         * recorder.clearRecordedData();\r\n         */\r\n        clearRecordedData: function() {\r\n            if (!mediaRecorder) {\r\n                warningLog();\r\n                return;\r\n            }\r\n\r\n            mediaRecorder.clearRecordedData();\r\n\r\n            if (!config.disableLogs) {\r\n                console.log('Cleared old recorded data.');\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Get the recorded blob. Use this method inside the \"stopRecording\" callback.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     var blob = this.getBlob();\r\n         *\r\n         *     var file = new File([blob], 'filename.webm', {\r\n         *         type: 'video/webm'\r\n         *     });\r\n         *\r\n         *     var formData = new FormData();\r\n         *     formData.append('file', file); // upload \"File\" object rather than a \"Blob\"\r\n         *     uploadToServer(formData);\r\n         * });\r\n         * @returns {Blob} Returns recorded data as \"Blob\" object.\r\n         */\r\n        getBlob: function() {\r\n            if (!mediaRecorder) {\r\n                warningLog();\r\n                return;\r\n            }\r\n\r\n            return mediaRecorder.blob;\r\n        },\r\n\r\n        /**\r\n         * Get data-URI instead of Blob.\r\n         * @param {function} callback - Callback to get the Data-URI.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     recorder.getDataURL(function(dataURI) {\r\n         *         video.src = dataURI;\r\n         *     });\r\n         * });\r\n         */\r\n        getDataURL: getDataURL,\r\n\r\n        /**\r\n         * Get virtual/temporary URL. Usage of this URL is limited to current tab.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     video.src = this.toURL();\r\n         * });\r\n         * @returns {String} Returns a virtual/temporary URL for the recorded \"Blob\".\r\n         */\r\n        toURL: function() {\r\n            if (!mediaRecorder) {\r\n                warningLog();\r\n                return;\r\n            }\r\n\r\n            return URL.createObjectURL(mediaRecorder.blob);\r\n        },\r\n\r\n        /**\r\n         * Get internal recording object (i.e. internal module) e.g. MutliStreamRecorder, MediaStreamRecorder, StereoAudioRecorder or WhammyRecorder etc.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * var internalRecorder = recorder.getInternalRecorder();\r\n         * if(internalRecorder instanceof MultiStreamRecorder) {\r\n         *     internalRecorder.addStreams([newAudioStream]);\r\n         *     internalRecorder.resetVideoStreams([screenStream]);\r\n         * }\r\n         * @returns {Object} Returns internal recording object.\r\n         */\r\n        getInternalRecorder: function() {\r\n            return mediaRecorder;\r\n        },\r\n\r\n        /**\r\n         * Invoke save-as dialog to save the recorded blob into your disk.\r\n         * @param {string} fileName - Set your own file name.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     this.save('file-name');\r\n         *\r\n         *     // or manually:\r\n         *     invokeSaveAsDialog(this.getBlob(), 'filename.webm');\r\n         * });\r\n         */\r\n        save: function(fileName) {\r\n            if (!mediaRecorder) {\r\n                warningLog();\r\n                return;\r\n            }\r\n\r\n            invokeSaveAsDialog(mediaRecorder.blob, fileName);\r\n        },\r\n\r\n        /**\r\n         * This method gets a blob from indexed-DB storage.\r\n         * @param {function} callback - Callback to get the recorded blob.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.getFromDisk(function(dataURL) {\r\n         *     video.src = dataURL;\r\n         * });\r\n         */\r\n        getFromDisk: function(callback) {\r\n            if (!mediaRecorder) {\r\n                warningLog();\r\n                return;\r\n            }\r\n\r\n            RecordRTC.getFromDisk(config.type, callback);\r\n        },\r\n\r\n        /**\r\n         * This method appends an array of webp images to the recorded video-blob. It takes an \"array\" object.\r\n         * @type {Array.<Array>}\r\n         * @param {Array} arrayOfWebPImages - Array of webp images.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo This method should be deprecated.\r\n         * @example\r\n         * var arrayOfWebPImages = [];\r\n         * arrayOfWebPImages.push({\r\n         *     duration: index,\r\n         *     image: 'data:image/webp;base64,...'\r\n         * });\r\n         * recorder.setAdvertisementArray(arrayOfWebPImages);\r\n         */\r\n        setAdvertisementArray: function(arrayOfWebPImages) {\r\n            config.advertisement = [];\r\n\r\n            var length = arrayOfWebPImages.length;\r\n            for (var i = 0; i < length; i++) {\r\n                config.advertisement.push({\r\n                    duration: i,\r\n                    image: arrayOfWebPImages[i]\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * It is equivalent to <code class=\"str\">\"recorder.getBlob()\"</code> method. Usage of \"getBlob\" is recommended, though.\r\n         * @property {Blob} blob - Recorded Blob can be accessed using this property.\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     var blob = this.blob;\r\n         *\r\n         *     // below one is recommended\r\n         *     var blob = this.getBlob();\r\n         * });\r\n         */\r\n        blob: null,\r\n\r\n        /**\r\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\r\n         * @property {number} bufferSize - Buffer-size used to encode the WAV container\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     alert('Recorder used this buffer-size: ' + this.bufferSize);\r\n         * });\r\n         */\r\n        bufferSize: 0,\r\n\r\n        /**\r\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\r\n         * @property {number} sampleRate - Sample-rates used to encode the WAV container\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     alert('Recorder used these sample-rates: ' + this.sampleRate);\r\n         * });\r\n         */\r\n        sampleRate: 0,\r\n\r\n        /**\r\n         * {recorderType:StereoAudioRecorder} returns ArrayBuffer object.\r\n         * @property {ArrayBuffer} buffer - Audio ArrayBuffer, supported only in Chrome.\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     var arrayBuffer = this.buffer;\r\n         *     alert(arrayBuffer.byteLength);\r\n         * });\r\n         */\r\n        buffer: null,\r\n\r\n        /**\r\n         * This method resets the recorder. So that you can reuse single recorder instance many times.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.reset();\r\n         * recorder.startRecording();\r\n         */\r\n        reset: function() {\r\n            if (self.state === 'recording' && !config.disableLogs) {\r\n                console.warn('Stop an active recorder.');\r\n            }\r\n\r\n            if (mediaRecorder && typeof mediaRecorder.clearRecordedData === 'function') {\r\n                mediaRecorder.clearRecordedData();\r\n            }\r\n            mediaRecorder = null;\r\n            setState('inactive');\r\n            self.blob = null;\r\n        },\r\n\r\n        /**\r\n         * This method is called whenever recorder's state changes. Use this as an \"event\".\r\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.onStateChanged = function(state) {\r\n         *     console.log('Recorder state: ', state);\r\n         * };\r\n         */\r\n        onStateChanged: function(state) {\r\n            if (!config.disableLogs) {\r\n                console.log('Recorder state changed:', state);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * A recorder can have inactive, recording, paused or stopped states.\r\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\r\n         * @memberof RecordRTC\r\n         * @static\r\n         * @readonly\r\n         * @example\r\n         * // this looper function will keep you updated about the recorder's states.\r\n         * (function looper() {\r\n         *     document.querySelector('h1').innerHTML = 'Recorder\\'s state is: ' + recorder.state;\r\n         *     if(recorder.state === 'stopped') return; // ignore+stop\r\n         *     setTimeout(looper, 1000); // update after every 3-seconds\r\n         * })();\r\n         * recorder.startRecording();\r\n         */\r\n        state: 'inactive',\r\n\r\n        /**\r\n         * Get recorder's readonly state.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @example\r\n         * var state = recorder.getState();\r\n         * @returns {String} Returns recording state.\r\n         */\r\n        getState: function() {\r\n            return self.state;\r\n        },\r\n\r\n        /**\r\n         * Destroy RecordRTC instance. Clear all recorders and objects.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @example\r\n         * recorder.destroy();\r\n         */\r\n        destroy: function() {\r\n            var disableLogsCache = config.disableLogs;\r\n\r\n            config = {\r\n                disableLogs: true\r\n            };\r\n            self.reset();\r\n            setState('destroyed');\r\n            returnObject = self = null;\r\n\r\n            if (Storage.AudioContextConstructor) {\r\n                Storage.AudioContextConstructor.close();\r\n                Storage.AudioContextConstructor = null;\r\n            }\r\n\r\n            config.disableLogs = disableLogsCache;\r\n\r\n            if (!config.disableLogs) {\r\n                console.log('RecordRTC is destroyed.');\r\n            }\r\n        },\r\n\r\n        /**\r\n         * RecordRTC version number\r\n         * @property {String} version - Release version number.\r\n         * @memberof RecordRTC\r\n         * @static\r\n         * @readonly\r\n         * @example\r\n         * alert(recorder.version);\r\n         */\r\n        version: '5.5.9'\r\n    };\r\n\r\n    if (!this) {\r\n        self = returnObject;\r\n        return returnObject;\r\n    }\r\n\r\n    // if someone wants to use RecordRTC with the \"new\" keyword.\r\n    for (var prop in returnObject) {\r\n        this[prop] = returnObject[prop];\r\n    }\r\n\r\n    self = this;\r\n\r\n    return returnObject;\r\n}\r\n\r\nRecordRTC.version = '5.5.9';\r\n\r\nif (typeof module !== 'undefined' /* && !!module.exports*/ ) {\r\n    module.exports = RecordRTC;\r\n}\r\n\r\nif (typeof define === 'function' && define.amd) {\r\n    define('RecordRTC', [], function() {\r\n        return RecordRTC;\r\n    });\r\n}\n\r\nRecordRTC.getFromDisk = function(type, callback) {\r\n    if (!callback) {\r\n        throw 'callback is mandatory.';\r\n    }\r\n\r\n    console.log('Getting recorded ' + (type === 'all' ? 'blobs' : type + ' blob ') + ' from disk!');\r\n    DiskStorage.Fetch(function(dataURL, _type) {\r\n        if (type !== 'all' && _type === type + 'Blob' && callback) {\r\n            callback(dataURL);\r\n        }\r\n\r\n        if (type === 'all' && callback) {\r\n            callback(dataURL, _type.replace('Blob', ''));\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * This method can be used to store recorded blobs into IndexedDB storage.\r\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\r\n * @method\r\n * @memberof RecordRTC\r\n * @example\r\n * RecordRTC.writeToDisk({\r\n *     audio: audioBlob,\r\n *     video: videoBlob,\r\n *     gif  : gifBlob\r\n * });\r\n */\r\nRecordRTC.writeToDisk = function(options) {\r\n    console.log('Writing recorded blob(s) to disk!');\r\n    options = options || {};\r\n    if (options.audio && options.video && options.gif) {\r\n        options.audio.getDataURL(function(audioDataURL) {\r\n            options.video.getDataURL(function(videoDataURL) {\r\n                options.gif.getDataURL(function(gifDataURL) {\r\n                    DiskStorage.Store({\r\n                        audioBlob: audioDataURL,\r\n                        videoBlob: videoDataURL,\r\n                        gifBlob: gifDataURL\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    } else if (options.audio && options.video) {\r\n        options.audio.getDataURL(function(audioDataURL) {\r\n            options.video.getDataURL(function(videoDataURL) {\r\n                DiskStorage.Store({\r\n                    audioBlob: audioDataURL,\r\n                    videoBlob: videoDataURL\r\n                });\r\n            });\r\n        });\r\n    } else if (options.audio && options.gif) {\r\n        options.audio.getDataURL(function(audioDataURL) {\r\n            options.gif.getDataURL(function(gifDataURL) {\r\n                DiskStorage.Store({\r\n                    audioBlob: audioDataURL,\r\n                    gifBlob: gifDataURL\r\n                });\r\n            });\r\n        });\r\n    } else if (options.video && options.gif) {\r\n        options.video.getDataURL(function(videoDataURL) {\r\n            options.gif.getDataURL(function(gifDataURL) {\r\n                DiskStorage.Store({\r\n                    videoBlob: videoDataURL,\r\n                    gifBlob: gifDataURL\r\n                });\r\n            });\r\n        });\r\n    } else if (options.audio) {\r\n        options.audio.getDataURL(function(audioDataURL) {\r\n            DiskStorage.Store({\r\n                audioBlob: audioDataURL\r\n            });\r\n        });\r\n    } else if (options.video) {\r\n        options.video.getDataURL(function(videoDataURL) {\r\n            DiskStorage.Store({\r\n                videoBlob: videoDataURL\r\n            });\r\n        });\r\n    } else if (options.gif) {\r\n        options.gif.getDataURL(function(gifDataURL) {\r\n            DiskStorage.Store({\r\n                gifBlob: gifDataURL\r\n            });\r\n        });\r\n    }\r\n};\n\r\n// __________________________\r\n// RecordRTC-Configuration.js\r\n\r\n/**\r\n * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.\r\n * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid \"config\" object.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef RecordRTCConfiguration\r\n * @class\r\n * @example\r\n * var options = RecordRTCConfiguration(mediaStream, options);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}\r\n */\r\n\r\nfunction RecordRTCConfiguration(mediaStream, config) {\r\n    if (!config.recorderType && !config.type) {\r\n        if (!!config.audio && !!config.video) {\r\n            config.type = 'video';\r\n        } else if (!!config.audio && !config.video) {\r\n            config.type = 'audio';\r\n        }\r\n    }\r\n\r\n    if (config.recorderType && !config.type) {\r\n        if (config.recorderType === WhammyRecorder || config.recorderType === CanvasRecorder || (typeof WebAssemblyRecorder !== 'undefined' && config.recorderType === WebAssemblyRecorder)) {\r\n            config.type = 'video';\r\n        } else if (config.recorderType === GifRecorder) {\r\n            config.type = 'gif';\r\n        } else if (config.recorderType === StereoAudioRecorder) {\r\n            config.type = 'audio';\r\n        } else if (config.recorderType === MediaStreamRecorder) {\r\n            if (getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {\r\n                config.type = 'video';\r\n            } else if (!getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {\r\n                config.type = 'video';\r\n            } else if (getTracks(mediaStream, 'audio').length && !getTracks(mediaStream, 'video').length) {\r\n                config.type = 'audio';\r\n            } else {\r\n                // config.type = 'UnKnown';\r\n            }\r\n        }\r\n    }\r\n\r\n    if (typeof MediaStreamRecorder !== 'undefined' && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {\r\n        if (!config.mimeType) {\r\n            config.mimeType = 'video/webm';\r\n        }\r\n\r\n        if (!config.type) {\r\n            config.type = config.mimeType.split('/')[0];\r\n        }\r\n\r\n        if (!config.bitsPerSecond) {\r\n            // config.bitsPerSecond = 128000;\r\n        }\r\n    }\r\n\r\n    // consider default type=audio\r\n    if (!config.type) {\r\n        if (config.mimeType) {\r\n            config.type = config.mimeType.split('/')[0];\r\n        }\r\n        if (!config.type) {\r\n            config.type = 'audio';\r\n        }\r\n    }\r\n\r\n    return config;\r\n}\n\r\n// __________________\r\n// GetRecorderType.js\r\n\r\n/**\r\n * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.\r\n * @summary It returns best recorder-type available for your browser.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef GetRecorderType\r\n * @class\r\n * @example\r\n * var RecorderType = GetRecorderType(options);\r\n * var recorder = new RecorderType(options);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\r\n */\r\n\r\nfunction GetRecorderType(mediaStream, config) {\r\n    var recorder;\r\n\r\n    // StereoAudioRecorder can work with all three: Edge, Firefox and Chrome\r\n    // todo: detect if it is Edge, then auto use: StereoAudioRecorder\r\n    if (isChrome || isEdge || isOpera) {\r\n        // Media Stream Recording API has not been implemented in chrome yet;\r\n        // That's why using WebAudio API to record stereo audio in WAV format\r\n        recorder = StereoAudioRecorder;\r\n    }\r\n\r\n    if (typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype && !isChrome) {\r\n        recorder = MediaStreamRecorder;\r\n    }\r\n\r\n    // video recorder (in WebM format)\r\n    if (config.type === 'video' && (isChrome || isOpera)) {\r\n        recorder = WhammyRecorder;\r\n\r\n        if (typeof WebAssemblyRecorder !== 'undefined' && typeof ReadableStream !== 'undefined') {\r\n            recorder = WebAssemblyRecorder;\r\n        }\r\n    }\r\n\r\n    // video recorder (in Gif format)\r\n    if (config.type === 'gif') {\r\n        recorder = GifRecorder;\r\n    }\r\n\r\n    // html2canvas recording!\r\n    if (config.type === 'canvas') {\r\n        recorder = CanvasRecorder;\r\n    }\r\n\r\n    if (isMediaRecorderCompatible() && recorder !== CanvasRecorder && recorder !== GifRecorder && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {\r\n        if (getTracks(mediaStream, 'video').length || getTracks(mediaStream, 'audio').length) {\r\n            // audio-only recording\r\n            if (config.type === 'audio') {\r\n                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('audio/webm')) {\r\n                    recorder = MediaStreamRecorder;\r\n                }\r\n                // else recorder = StereoAudioRecorder;\r\n            } else {\r\n                // video or screen tracks\r\n                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('video/webm')) {\r\n                    recorder = MediaStreamRecorder;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (mediaStream instanceof Array && mediaStream.length) {\r\n        recorder = MultiStreamRecorder;\r\n    }\r\n\r\n    if (config.recorderType) {\r\n        recorder = config.recorderType;\r\n    }\r\n\r\n    if (!config.disableLogs && !!recorder && !!recorder.name) {\r\n        console.log('Using recorderType:', recorder.name || recorder.constructor.name);\r\n    }\r\n\r\n    if (!recorder && isSafari) {\r\n        recorder = MediaStreamRecorder;\r\n    }\r\n\r\n    return recorder;\r\n}\n\r\n// _____________\r\n// MRecordRTC.js\r\n\r\n/**\r\n * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.\r\n * @summary MRecordRTC stands for \"Multiple-RecordRTC\".\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef MRecordRTC\r\n * @class\r\n * @example\r\n * var recorder = new MRecordRTC();\r\n * recorder.addStream(MediaStream);\r\n * recorder.mediaType = {\r\n *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder\r\n *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\r\n *     gif: true    // or GifRecorder\r\n * };\r\n * // mimeType is optional and should be set only in advance cases.\r\n * recorder.mimeType = {\r\n *     audio: 'audio/wav',\r\n *     video: 'video/webm',\r\n *     gif:   'image/gif'\r\n * };\r\n * recorder.startRecording();\r\n * @see For further information:\r\n * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @requires {@link RecordRTC}\r\n */\r\n\r\nfunction MRecordRTC(mediaStream) {\r\n\r\n    /**\r\n     * This method attaches MediaStream object to {@link MRecordRTC}.\r\n     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded or WebAudio API.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.addStream(MediaStream);\r\n     */\r\n    this.addStream = function(_mediaStream) {\r\n        if (_mediaStream) {\r\n            mediaStream = _mediaStream;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.\r\n     * @property {object} mediaType - {audio: true, video: true, gif: true}\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * var recorder = new MRecordRTC();\r\n     * recorder.mediaType = {\r\n     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder\r\n     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\r\n     *     gif  : true  // TRUE or GifRecorder\r\n     * };\r\n     */\r\n    this.mediaType = {\r\n        audio: true,\r\n        video: true\r\n    };\r\n\r\n    /**\r\n     * This method starts recording.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.startRecording();\r\n     */\r\n    this.startRecording = function() {\r\n        var mediaType = this.mediaType;\r\n        var recorderType;\r\n        var mimeType = this.mimeType || {\r\n            audio: null,\r\n            video: null,\r\n            gif: null\r\n        };\r\n\r\n        if (typeof mediaType.audio !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'audio').length) {\r\n            mediaType.audio = false;\r\n        }\r\n\r\n        if (typeof mediaType.video !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {\r\n            mediaType.video = false;\r\n        }\r\n\r\n        if (typeof mediaType.gif !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {\r\n            mediaType.gif = false;\r\n        }\r\n\r\n        if (!mediaType.audio && !mediaType.video && !mediaType.gif) {\r\n            throw 'MediaStream must have either audio or video tracks.';\r\n        }\r\n\r\n        if (!!mediaType.audio) {\r\n            recorderType = null;\r\n            if (typeof mediaType.audio === 'function') {\r\n                recorderType = mediaType.audio;\r\n            }\r\n\r\n            this.audioRecorder = new RecordRTC(mediaStream, {\r\n                type: 'audio',\r\n                bufferSize: this.bufferSize,\r\n                sampleRate: this.sampleRate,\r\n                numberOfAudioChannels: this.numberOfAudioChannels || 2,\r\n                disableLogs: this.disableLogs,\r\n                recorderType: recorderType,\r\n                mimeType: mimeType.audio,\r\n                timeSlice: this.timeSlice,\r\n                onTimeStamp: this.onTimeStamp\r\n            });\r\n\r\n            if (!mediaType.video) {\r\n                this.audioRecorder.startRecording();\r\n            }\r\n        }\r\n\r\n        if (!!mediaType.video) {\r\n            recorderType = null;\r\n            if (typeof mediaType.video === 'function') {\r\n                recorderType = mediaType.video;\r\n            }\r\n\r\n            var newStream = mediaStream;\r\n\r\n            if (isMediaRecorderCompatible() && !!mediaType.audio && typeof mediaType.audio === 'function') {\r\n                var videoTrack = getTracks(mediaStream, 'video')[0];\r\n\r\n                if (isFirefox) {\r\n                    newStream = new MediaStream();\r\n                    newStream.addTrack(videoTrack);\r\n\r\n                    if (recorderType && recorderType === WhammyRecorder) {\r\n                        // Firefox does NOT supports webp-encoding yet\r\n                        // But Firefox do supports WebAssemblyRecorder\r\n                        recorderType = MediaStreamRecorder;\r\n                    }\r\n                } else {\r\n                    newStream = new MediaStream();\r\n                    newStream.addTrack(videoTrack);\r\n                }\r\n            }\r\n\r\n            this.videoRecorder = new RecordRTC(newStream, {\r\n                type: 'video',\r\n                video: this.video,\r\n                canvas: this.canvas,\r\n                frameInterval: this.frameInterval || 10,\r\n                disableLogs: this.disableLogs,\r\n                recorderType: recorderType,\r\n                mimeType: mimeType.video,\r\n                timeSlice: this.timeSlice,\r\n                onTimeStamp: this.onTimeStamp,\r\n                workerPath: this.workerPath,\r\n                webAssemblyPath: this.webAssemblyPath,\r\n                frameRate: this.frameRate, // used by WebAssemblyRecorder; values: usually 30; accepts any.\r\n                bitrate: this.bitrate // used by WebAssemblyRecorder; values: 0 to 1000+\r\n            });\r\n\r\n            if (!mediaType.audio) {\r\n                this.videoRecorder.startRecording();\r\n            }\r\n        }\r\n\r\n        if (!!mediaType.audio && !!mediaType.video) {\r\n            var self = this;\r\n\r\n            var isSingleRecorder = isMediaRecorderCompatible() === true;\r\n\r\n            if (mediaType.audio instanceof StereoAudioRecorder && !!mediaType.video) {\r\n                isSingleRecorder = false;\r\n            } else if (mediaType.audio !== true && mediaType.video !== true && mediaType.audio !== mediaType.video) {\r\n                isSingleRecorder = false;\r\n            }\r\n\r\n            if (isSingleRecorder === true) {\r\n                self.audioRecorder = null;\r\n                self.videoRecorder.startRecording();\r\n            } else {\r\n                self.videoRecorder.initRecorder(function() {\r\n                    self.audioRecorder.initRecorder(function() {\r\n                        // Both recorders are ready to record things accurately\r\n                        self.videoRecorder.startRecording();\r\n                        self.audioRecorder.startRecording();\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        if (!!mediaType.gif) {\r\n            recorderType = null;\r\n            if (typeof mediaType.gif === 'function') {\r\n                recorderType = mediaType.gif;\r\n            }\r\n            this.gifRecorder = new RecordRTC(mediaStream, {\r\n                type: 'gif',\r\n                frameRate: this.frameRate || 200,\r\n                quality: this.quality || 10,\r\n                disableLogs: this.disableLogs,\r\n                recorderType: recorderType,\r\n                mimeType: mimeType.gif\r\n            });\r\n            this.gifRecorder.startRecording();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method stops recording.\r\n     * @param {function} callback - Callback function is invoked when all encoders finished their jobs.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.stopRecording(function(recording){\r\n     *     var audioBlob = recording.audio;\r\n     *     var videoBlob = recording.video;\r\n     *     var gifBlob   = recording.gif;\r\n     * });\r\n     */\r\n    this.stopRecording = function(callback) {\r\n        callback = callback || function() {};\r\n\r\n        if (this.audioRecorder) {\r\n            this.audioRecorder.stopRecording(function(blobURL) {\r\n                callback(blobURL, 'audio');\r\n            });\r\n        }\r\n\r\n        if (this.videoRecorder) {\r\n            this.videoRecorder.stopRecording(function(blobURL) {\r\n                callback(blobURL, 'video');\r\n            });\r\n        }\r\n\r\n        if (this.gifRecorder) {\r\n            this.gifRecorder.stopRecording(function(blobURL) {\r\n                callback(blobURL, 'gif');\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method pauses recording.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.pauseRecording();\r\n     */\r\n    this.pauseRecording = function() {\r\n        if (this.audioRecorder) {\r\n            this.audioRecorder.pauseRecording();\r\n        }\r\n\r\n        if (this.videoRecorder) {\r\n            this.videoRecorder.pauseRecording();\r\n        }\r\n\r\n        if (this.gifRecorder) {\r\n            this.gifRecorder.pauseRecording();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resumes recording.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.resumeRecording();\r\n     */\r\n    this.resumeRecording = function() {\r\n        if (this.audioRecorder) {\r\n            this.audioRecorder.resumeRecording();\r\n        }\r\n\r\n        if (this.videoRecorder) {\r\n            this.videoRecorder.resumeRecording();\r\n        }\r\n\r\n        if (this.gifRecorder) {\r\n            this.gifRecorder.resumeRecording();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method can be used to manually get all recorded blobs.\r\n     * @param {function} callback - All recorded blobs are passed back to the \"callback\" function.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.getBlob(function(recording){\r\n     *     var audioBlob = recording.audio;\r\n     *     var videoBlob = recording.video;\r\n     *     var gifBlob   = recording.gif;\r\n     * });\r\n     * // or\r\n     * var audioBlob = recorder.getBlob().audio;\r\n     * var videoBlob = recorder.getBlob().video;\r\n     */\r\n    this.getBlob = function(callback) {\r\n        var output = {};\r\n\r\n        if (this.audioRecorder) {\r\n            output.audio = this.audioRecorder.getBlob();\r\n        }\r\n\r\n        if (this.videoRecorder) {\r\n            output.video = this.videoRecorder.getBlob();\r\n        }\r\n\r\n        if (this.gifRecorder) {\r\n            output.gif = this.gifRecorder.getBlob();\r\n        }\r\n\r\n        if (callback) {\r\n            callback(output);\r\n        }\r\n\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Destroy all recorder instances.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.destroy();\r\n     */\r\n    this.destroy = function() {\r\n        if (this.audioRecorder) {\r\n            this.audioRecorder.destroy();\r\n            this.audioRecorder = null;\r\n        }\r\n\r\n        if (this.videoRecorder) {\r\n            this.videoRecorder.destroy();\r\n            this.videoRecorder = null;\r\n        }\r\n\r\n        if (this.gifRecorder) {\r\n            this.gifRecorder.destroy();\r\n            this.gifRecorder = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method can be used to manually get all recorded blobs' DataURLs.\r\n     * @param {function} callback - All recorded blobs' DataURLs are passed back to the \"callback\" function.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.getDataURL(function(recording){\r\n     *     var audioDataURL = recording.audio;\r\n     *     var videoDataURL = recording.video;\r\n     *     var gifDataURL   = recording.gif;\r\n     * });\r\n     */\r\n    this.getDataURL = function(callback) {\r\n        this.getBlob(function(blob) {\r\n            if (blob.audio && blob.video) {\r\n                getDataURL(blob.audio, function(_audioDataURL) {\r\n                    getDataURL(blob.video, function(_videoDataURL) {\r\n                        callback({\r\n                            audio: _audioDataURL,\r\n                            video: _videoDataURL\r\n                        });\r\n                    });\r\n                });\r\n            } else if (blob.audio) {\r\n                getDataURL(blob.audio, function(_audioDataURL) {\r\n                    callback({\r\n                        audio: _audioDataURL\r\n                    });\r\n                });\r\n            } else if (blob.video) {\r\n                getDataURL(blob.video, function(_videoDataURL) {\r\n                    callback({\r\n                        video: _videoDataURL\r\n                    });\r\n                });\r\n            }\r\n        });\r\n\r\n        function getDataURL(blob, callback00) {\r\n            if (typeof Worker !== 'undefined') {\r\n                var webWorker = processInWebWorker(function readFile(_blob) {\r\n                    postMessage(new FileReaderSync().readAsDataURL(_blob));\r\n                });\r\n\r\n                webWorker.onmessage = function(event) {\r\n                    callback00(event.data);\r\n                };\r\n\r\n                webWorker.postMessage(blob);\r\n            } else {\r\n                var reader = new FileReader();\r\n                reader.readAsDataURL(blob);\r\n                reader.onload = function(event) {\r\n                    callback00(event.target.result);\r\n                };\r\n            }\r\n        }\r\n\r\n        function processInWebWorker(_function) {\r\n            var blob = URL.createObjectURL(new Blob([_function.toString(),\r\n                'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\r\n            ], {\r\n                type: 'application/javascript'\r\n            }));\r\n\r\n            var worker = new Worker(blob);\r\n            var url;\r\n            if (typeof URL !== 'undefined') {\r\n                url = URL;\r\n            } else if (typeof webkitURL !== 'undefined') {\r\n                url = webkitURL;\r\n            } else {\r\n                throw 'Neither URL nor webkitURL detected.';\r\n            }\r\n            url.revokeObjectURL(blob);\r\n            return worker;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method can be used to ask {@link MRecordRTC} to write all recorded blobs into IndexedDB storage.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.writeToDisk();\r\n     */\r\n    this.writeToDisk = function() {\r\n        RecordRTC.writeToDisk({\r\n            audio: this.audioRecorder,\r\n            video: this.videoRecorder,\r\n            gif: this.gifRecorder\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method can be used to invoke a save-as dialog for all recorded blobs.\r\n     * @param {object} args - {audio: 'audio-name', video: 'video-name', gif: 'gif-name'}\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.save({\r\n     *     audio: 'audio-file-name',\r\n     *     video: 'video-file-name',\r\n     *     gif  : 'gif-file-name'\r\n     * });\r\n     */\r\n    this.save = function(args) {\r\n        args = args || {\r\n            audio: true,\r\n            video: true,\r\n            gif: true\r\n        };\r\n\r\n        if (!!args.audio && this.audioRecorder) {\r\n            this.audioRecorder.save(typeof args.audio === 'string' ? args.audio : '');\r\n        }\r\n\r\n        if (!!args.video && this.videoRecorder) {\r\n            this.videoRecorder.save(typeof args.video === 'string' ? args.video : '');\r\n        }\r\n        if (!!args.gif && this.gifRecorder) {\r\n            this.gifRecorder.save(typeof args.gif === 'string' ? args.gif : '');\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * This method can be used to get all recorded blobs from IndexedDB storage.\r\n * @param {string} type - 'all' or 'audio' or 'video' or 'gif'\r\n * @param {function} callback - Callback function to get all stored blobs.\r\n * @method\r\n * @memberof MRecordRTC\r\n * @example\r\n * MRecordRTC.getFromDisk('all', function(dataURL, type){\r\n *     if(type === 'audio') { }\r\n *     if(type === 'video') { }\r\n *     if(type === 'gif')   { }\r\n * });\r\n */\r\nMRecordRTC.getFromDisk = RecordRTC.getFromDisk;\r\n\r\n/**\r\n * This method can be used to store recorded blobs into IndexedDB storage.\r\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\r\n * @method\r\n * @memberof MRecordRTC\r\n * @example\r\n * MRecordRTC.writeToDisk({\r\n *     audio: audioBlob,\r\n *     video: videoBlob,\r\n *     gif  : gifBlob\r\n * });\r\n */\r\nMRecordRTC.writeToDisk = RecordRTC.writeToDisk;\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.MRecordRTC = MRecordRTC;\r\n}\n\r\nvar browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\r\n\r\n(function(that) {\r\n    if (!that) {\r\n        return;\r\n    }\r\n\r\n    if (typeof window !== 'undefined') {\r\n        return;\r\n    }\r\n\r\n    if (typeof global === 'undefined') {\r\n        return;\r\n    }\r\n\r\n    global.navigator = {\r\n        userAgent: browserFakeUserAgent,\r\n        getUserMedia: function() {}\r\n    };\r\n\r\n    if (!global.console) {\r\n        global.console = {};\r\n    }\r\n\r\n    if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {\r\n        global.console.error = global.console.log = global.console.log || function() {\r\n            console.log(arguments);\r\n        };\r\n    }\r\n\r\n    if (typeof document === 'undefined') {\r\n        /*global document:true */\r\n        that.document = {\r\n            documentElement: {\r\n                appendChild: function() {\r\n                    return '';\r\n                }\r\n            }\r\n        };\r\n\r\n        document.createElement = document.captureStream = document.mozCaptureStream = function() {\r\n            var obj = {\r\n                getContext: function() {\r\n                    return obj;\r\n                },\r\n                play: function() {},\r\n                pause: function() {},\r\n                drawImage: function() {},\r\n                toDataURL: function() {\r\n                    return '';\r\n                },\r\n                style: {}\r\n            };\r\n            return obj;\r\n        };\r\n\r\n        that.HTMLVideoElement = function() {};\r\n    }\r\n\r\n    if (typeof location === 'undefined') {\r\n        /*global location:true */\r\n        that.location = {\r\n            protocol: 'file:',\r\n            href: '',\r\n            hash: ''\r\n        };\r\n    }\r\n\r\n    if (typeof screen === 'undefined') {\r\n        /*global screen:true */\r\n        that.screen = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n    }\r\n\r\n    if (typeof URL === 'undefined') {\r\n        /*global screen:true */\r\n        that.URL = {\r\n            createObjectURL: function() {\r\n                return '';\r\n            },\r\n            revokeObjectURL: function() {\r\n                return '';\r\n            }\r\n        };\r\n    }\r\n\r\n    /*global window:true */\r\n    that.window = global;\r\n})(typeof global !== 'undefined' ? global : null);\n\r\n// _____________________________\r\n// Cross-Browser-Declarations.js\r\n\r\n// animation-frame used in WebM recording\r\n\r\n/*jshint -W079 */\r\nvar requestAnimationFrame = window.requestAnimationFrame;\r\nif (typeof requestAnimationFrame === 'undefined') {\r\n    if (typeof webkitRequestAnimationFrame !== 'undefined') {\r\n        /*global requestAnimationFrame:true */\r\n        requestAnimationFrame = webkitRequestAnimationFrame;\r\n    } else if (typeof mozRequestAnimationFrame !== 'undefined') {\r\n        /*global requestAnimationFrame:true */\r\n        requestAnimationFrame = mozRequestAnimationFrame;\r\n    } else if (typeof msRequestAnimationFrame !== 'undefined') {\r\n        /*global requestAnimationFrame:true */\r\n        requestAnimationFrame = msRequestAnimationFrame;\r\n    } else if (typeof requestAnimationFrame === 'undefined') {\r\n        // via: https://gist.github.com/paulirish/1579671\r\n        var lastTime = 0;\r\n\r\n        /*global requestAnimationFrame:true */\r\n        requestAnimationFrame = function(callback, element) {\r\n            var currTime = new Date().getTime();\r\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n            var id = setTimeout(function() {\r\n                callback(currTime + timeToCall);\r\n            }, timeToCall);\r\n            lastTime = currTime + timeToCall;\r\n            return id;\r\n        };\r\n    }\r\n}\r\n\r\n/*jshint -W079 */\r\nvar cancelAnimationFrame = window.cancelAnimationFrame;\r\nif (typeof cancelAnimationFrame === 'undefined') {\r\n    if (typeof webkitCancelAnimationFrame !== 'undefined') {\r\n        /*global cancelAnimationFrame:true */\r\n        cancelAnimationFrame = webkitCancelAnimationFrame;\r\n    } else if (typeof mozCancelAnimationFrame !== 'undefined') {\r\n        /*global cancelAnimationFrame:true */\r\n        cancelAnimationFrame = mozCancelAnimationFrame;\r\n    } else if (typeof msCancelAnimationFrame !== 'undefined') {\r\n        /*global cancelAnimationFrame:true */\r\n        cancelAnimationFrame = msCancelAnimationFrame;\r\n    } else if (typeof cancelAnimationFrame === 'undefined') {\r\n        /*global cancelAnimationFrame:true */\r\n        cancelAnimationFrame = function(id) {\r\n            clearTimeout(id);\r\n        };\r\n    }\r\n}\r\n\r\n// WebAudio API representer\r\nvar AudioContext = window.AudioContext;\r\n\r\nif (typeof AudioContext === 'undefined') {\r\n    if (typeof webkitAudioContext !== 'undefined') {\r\n        /*global AudioContext:true */\r\n        AudioContext = webkitAudioContext;\r\n    }\r\n\r\n    if (typeof mozAudioContext !== 'undefined') {\r\n        /*global AudioContext:true */\r\n        AudioContext = mozAudioContext;\r\n    }\r\n}\r\n\r\n/*jshint -W079 */\r\nvar URL = window.URL;\r\n\r\nif (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {\r\n    /*global URL:true */\r\n    URL = webkitURL;\r\n}\r\n\r\nif (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?\r\n    if (typeof navigator.webkitGetUserMedia !== 'undefined') {\r\n        navigator.getUserMedia = navigator.webkitGetUserMedia;\r\n    }\r\n\r\n    if (typeof navigator.mozGetUserMedia !== 'undefined') {\r\n        navigator.getUserMedia = navigator.mozGetUserMedia;\r\n    }\r\n}\r\n\r\nvar isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);\r\nvar isOpera = !!window.opera || navigator.userAgent.indexOf('OPR/') !== -1;\r\nvar isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && ('netscape' in window) && / rv:/.test(navigator.userAgent);\r\nvar isChrome = (!isOpera && !isEdge && !!navigator.webkitGetUserMedia) || isElectron() || navigator.userAgent.toLowerCase().indexOf('chrome/') !== -1;\r\n\r\nvar isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n\r\nif (isSafari && !isChrome && navigator.userAgent.indexOf('CriOS') !== -1) {\r\n    isSafari = false;\r\n    isChrome = true;\r\n}\r\n\r\nvar MediaStream = window.MediaStream;\r\n\r\nif (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\r\n    MediaStream = webkitMediaStream;\r\n}\r\n\r\n/*global MediaStream:true */\r\nif (typeof MediaStream !== 'undefined') {\r\n    // override \"stop\" method for all browsers\r\n    if (typeof MediaStream.prototype.stop === 'undefined') {\r\n        MediaStream.prototype.stop = function() {\r\n            this.getTracks().forEach(function(track) {\r\n                track.stop();\r\n            });\r\n        };\r\n    }\r\n}\r\n\r\n// below function via: http://goo.gl/B3ae8c\r\n/**\r\n * Return human-readable file size.\r\n * @param {number} bytes - Pass bytes and get formatted string.\r\n * @returns {string} - formatted string\r\n * @example\r\n * bytesToSize(1024*1024*5) === '5 GB'\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */\r\nfunction bytesToSize(bytes) {\r\n    var k = 1000;\r\n    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\r\n    if (bytes === 0) {\r\n        return '0 Bytes';\r\n    }\r\n    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);\r\n    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];\r\n}\r\n\r\n/**\r\n * @param {Blob} file - File or Blob object. This parameter is required.\r\n * @param {string} fileName - Optional file name e.g. \"Recorded-Video.webm\"\r\n * @example\r\n * invokeSaveAsDialog(blob or file, [optional] fileName);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */\r\nfunction invokeSaveAsDialog(file, fileName) {\r\n    if (!file) {\r\n        throw 'Blob object is required.';\r\n    }\r\n\r\n    if (!file.type) {\r\n        try {\r\n            file.type = 'video/webm';\r\n        } catch (e) {}\r\n    }\r\n\r\n    var fileExtension = (file.type || 'video/webm').split('/')[1];\r\n\r\n    if (fileName && fileName.indexOf('.') !== -1) {\r\n        var splitted = fileName.split('.');\r\n        fileName = splitted[0];\r\n        fileExtension = splitted[1];\r\n    }\r\n\r\n    var fileFullName = (fileName || (Math.round(Math.random() * 9999999999) + 888888888)) + '.' + fileExtension;\r\n\r\n    if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {\r\n        return navigator.msSaveOrOpenBlob(file, fileFullName);\r\n    } else if (typeof navigator.msSaveBlob !== 'undefined') {\r\n        return navigator.msSaveBlob(file, fileFullName);\r\n    }\r\n\r\n    var hyperlink = document.createElement('a');\r\n    hyperlink.href = URL.createObjectURL(file);\r\n    hyperlink.download = fileFullName;\r\n\r\n    hyperlink.style = 'display:none;opacity:0;color:transparent;';\r\n    (document.body || document.documentElement).appendChild(hyperlink);\r\n\r\n    if (typeof hyperlink.click === 'function') {\r\n        hyperlink.click();\r\n    } else {\r\n        hyperlink.target = '_blank';\r\n        hyperlink.dispatchEvent(new MouseEvent('click', {\r\n            view: window,\r\n            bubbles: true,\r\n            cancelable: true\r\n        }));\r\n    }\r\n\r\n    URL.revokeObjectURL(hyperlink.href);\r\n}\r\n\r\n/**\r\n * from: https://github.com/cheton/is-electron/blob/master/index.js\r\n **/\r\nfunction isElectron() {\r\n    // Renderer process\r\n    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\r\n        return true;\r\n    }\r\n\r\n    // Main process\r\n    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {\r\n        return true;\r\n    }\r\n\r\n    // Detect the user agent when the `nodeIntegration` option is set to true\r\n    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction getTracks(stream, kind) {\r\n    if (!stream || !stream.getTracks) {\r\n        return [];\r\n    }\r\n\r\n    return stream.getTracks().filter(function(t) {\r\n        return t.kind === (kind || 'audio');\r\n    });\r\n}\r\n\r\nfunction setSrcObject(stream, element) {\r\n    if ('srcObject' in element) {\r\n        element.srcObject = stream;\r\n    } else if ('mozSrcObject' in element) {\r\n        element.mozSrcObject = stream;\r\n    } else {\r\n        element.srcObject = stream;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {Blob} file - File or Blob object.\r\n * @param {function} callback - Callback function.\r\n * @example\r\n * getSeekableBlob(blob or file, callback);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */\r\nfunction getSeekableBlob(inputBlob, callback) {\r\n    // EBML.js copyrights goes to: https://github.com/legokichi/ts-ebml\r\n    if (typeof EBML === 'undefined') {\r\n        throw new Error('Please link: https://www.webrtc-experiment.com/EBML.js');\r\n    }\r\n\r\n    var reader = new EBML.Reader();\r\n    var decoder = new EBML.Decoder();\r\n    var tools = EBML.tools;\r\n\r\n    var fileReader = new FileReader();\r\n    fileReader.onload = function(e) {\r\n        var ebmlElms = decoder.decode(this.result);\r\n        ebmlElms.forEach(function(element) {\r\n            reader.read(element);\r\n        });\r\n        reader.stop();\r\n        var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);\r\n        var body = this.result.slice(reader.metadataSize);\r\n        var newBlob = new Blob([refinedMetadataBuf, body], {\r\n            type: 'video/webm'\r\n        });\r\n\r\n        callback(newBlob);\r\n    };\r\n    fileReader.readAsArrayBuffer(inputBlob);\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.invokeSaveAsDialog = invokeSaveAsDialog;\r\n    RecordRTC.getTracks = getTracks;\r\n    RecordRTC.getSeekableBlob = getSeekableBlob;\r\n    RecordRTC.bytesToSize = bytesToSize;\r\n    RecordRTC.isElectron = isElectron;\r\n}\n\r\n// __________ (used to handle stuff like http://goo.gl/xmE5eg) issue #129\r\n// Storage.js\r\n\r\n/**\r\n * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. \"new AudioContext\".\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @example\r\n * Storage.AudioContext === webkitAudioContext\r\n * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */\r\n\r\nvar Storage = {};\r\n\r\nif (typeof AudioContext !== 'undefined') {\r\n    Storage.AudioContext = AudioContext;\r\n} else if (typeof webkitAudioContext !== 'undefined') {\r\n    Storage.AudioContext = webkitAudioContext;\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.Storage = Storage;\r\n}\n\r\nfunction isMediaRecorderCompatible() {\r\n    if (isFirefox || isSafari || isEdge) {\r\n        return true;\r\n    }\r\n\r\n    var nVer = navigator.appVersion;\r\n    var nAgt = navigator.userAgent;\r\n    var fullVersion = '' + parseFloat(navigator.appVersion);\r\n    var majorVersion = parseInt(navigator.appVersion, 10);\r\n    var nameOffset, verOffset, ix;\r\n\r\n    if (isChrome || isOpera) {\r\n        verOffset = nAgt.indexOf('Chrome');\r\n        fullVersion = nAgt.substring(verOffset + 7);\r\n    }\r\n\r\n    // trim the fullVersion string at semicolon/space if present\r\n    if ((ix = fullVersion.indexOf(';')) !== -1) {\r\n        fullVersion = fullVersion.substring(0, ix);\r\n    }\r\n\r\n    if ((ix = fullVersion.indexOf(' ')) !== -1) {\r\n        fullVersion = fullVersion.substring(0, ix);\r\n    }\r\n\r\n    majorVersion = parseInt('' + fullVersion, 10);\r\n\r\n    if (isNaN(majorVersion)) {\r\n        fullVersion = '' + parseFloat(navigator.appVersion);\r\n        majorVersion = parseInt(navigator.appVersion, 10);\r\n    }\r\n\r\n    return majorVersion >= 49;\r\n}\n\r\n// ______________________\r\n// MediaStreamRecorder.js\r\n\r\n/**\r\n * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.\r\n * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://github.com/muaz-khan|Muaz Khan}\r\n * @typedef MediaStreamRecorder\r\n * @class\r\n * @example\r\n * var config = {\r\n *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis\r\n *     audioBitsPerSecond : 256 * 8 * 1024,\r\n *     videoBitsPerSecond : 256 * 8 * 1024,\r\n *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two\r\n *     checkForInactiveTracks: true,\r\n *     timeSlice: 1000, // concatenate intervals based blobs\r\n *     ondataavailable: function() {} // get intervals based blobs\r\n * }\r\n * var recorder = new MediaStreamRecorder(mediaStream, config);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n *\r\n *     // or\r\n *     var blob = recorder.blob;\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {disableLogs:true, initCallback: function, mimeType: \"video/webm\", timeSlice: 1000}\r\n * @throws Will throw an error if first argument \"MediaStream\" is missing. Also throws error if \"MediaRecorder API\" are not supported by the browser.\r\n */\r\n\r\nfunction MediaStreamRecorder(mediaStream, config) {\r\n    var self = this;\r\n\r\n    if (typeof mediaStream === 'undefined') {\r\n        throw 'First argument \"MediaStream\" is required.';\r\n    }\r\n\r\n    if (typeof MediaRecorder === 'undefined') {\r\n        throw 'Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.';\r\n    }\r\n\r\n    config = config || {\r\n        // bitsPerSecond: 256 * 8 * 1024,\r\n        mimeType: 'video/webm'\r\n    };\r\n\r\n    if (config.type === 'audio') {\r\n        if (getTracks(mediaStream, 'video').length && getTracks(mediaStream, 'audio').length) {\r\n            var stream;\r\n            if (!!navigator.mozGetUserMedia) {\r\n                stream = new MediaStream();\r\n                stream.addTrack(getTracks(mediaStream, 'audio')[0]);\r\n            } else {\r\n                // webkitMediaStream\r\n                stream = new MediaStream(getTracks(mediaStream, 'audio'));\r\n            }\r\n            mediaStream = stream;\r\n        }\r\n\r\n        if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf('audio') === -1) {\r\n            config.mimeType = isChrome ? 'audio/webm' : 'audio/ogg';\r\n        }\r\n\r\n        if (config.mimeType && config.mimeType.toString().toLowerCase() !== 'audio/ogg' && !!navigator.mozGetUserMedia) {\r\n            // forcing better codecs on Firefox (via #166)\r\n            config.mimeType = 'audio/ogg';\r\n        }\r\n    }\r\n\r\n    var arrayOfBlobs = [];\r\n\r\n    /**\r\n     * This method returns array of blobs. Use only with \"timeSlice\". Its useful to preview recording anytime, without using the \"stop\" method.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * var arrayOfBlobs = recorder.getArrayOfBlobs();\r\n     * @returns {Array} Returns array of recorded blobs.\r\n     */\r\n    this.getArrayOfBlobs = function() {\r\n        return arrayOfBlobs;\r\n    };\r\n\r\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        // set defaults\r\n        self.blob = null;\r\n        self.clearRecordedData();\r\n        self.timestamps = [];\r\n        allStates = [];\r\n        arrayOfBlobs = [];\r\n\r\n        var recorderHints = config;\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('Passing following config over MediaRecorder API.', recorderHints);\r\n        }\r\n\r\n        if (mediaRecorder) {\r\n            // mandatory to make sure Firefox doesn't fails to record streams 3-4 times without reloading the page.\r\n            mediaRecorder = null;\r\n        }\r\n\r\n        if (isChrome && !isMediaRecorderCompatible()) {\r\n            // to support video-only recording on stable\r\n            recorderHints = 'video/vp8';\r\n        }\r\n\r\n        if (typeof MediaRecorder.isTypeSupported === 'function' && recorderHints.mimeType) {\r\n            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {\r\n                if (!config.disableLogs) {\r\n                    console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);\r\n                }\r\n\r\n                recorderHints.mimeType = config.type === 'audio' ? 'audio/webm' : 'video/webm';\r\n            }\r\n        }\r\n\r\n        // using MediaRecorder API here\r\n        try {\r\n            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);\r\n\r\n            // reset\r\n            config.mimeType = recorderHints.mimeType;\r\n        } catch (e) {\r\n            // chrome-based fallback\r\n            mediaRecorder = new MediaRecorder(mediaStream);\r\n        }\r\n\r\n        // old hack?\r\n        if (recorderHints.mimeType && !MediaRecorder.isTypeSupported && 'canRecordMimeType' in mediaRecorder && mediaRecorder.canRecordMimeType(recorderHints.mimeType) === false) {\r\n            if (!config.disableLogs) {\r\n                console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);\r\n            }\r\n        }\r\n\r\n        // Dispatching OnDataAvailable Handler\r\n        mediaRecorder.ondataavailable = function(e) {\r\n            if (e.data) {\r\n                allStates.push('ondataavailable: ' + bytesToSize(e.data.size));\r\n            }\r\n\r\n            if (typeof config.timeSlice === 'number') {\r\n                if (e.data && e.data.size && e.data.size > 100) {\r\n                    arrayOfBlobs.push(e.data);\r\n                    updateTimeStamp();\r\n\r\n                    if (typeof config.ondataavailable === 'function') {\r\n                        // intervals based blobs\r\n                        var blob = config.getNativeBlob ? e.data : new Blob([e.data], {\r\n                            type: getMimeType(recorderHints)\r\n                        });\r\n                        config.ondataavailable(blob);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (!e.data || !e.data.size || e.data.size < 100 || self.blob) {\r\n                // make sure that stopRecording always getting fired\r\n                // even if there is invalid data\r\n                if (self.recordingCallback) {\r\n                    self.recordingCallback(new Blob([], {\r\n                        type: getMimeType(recorderHints)\r\n                    }));\r\n                    self.recordingCallback = null;\r\n                }\r\n                return;\r\n            }\r\n\r\n            self.blob = config.getNativeBlob ? e.data : new Blob([e.data], {\r\n                type: getMimeType(recorderHints)\r\n            });\r\n\r\n            if (self.recordingCallback) {\r\n                self.recordingCallback(self.blob);\r\n                self.recordingCallback = null;\r\n            }\r\n        };\r\n\r\n        mediaRecorder.onstart = function() {\r\n            allStates.push('started');\r\n        };\r\n\r\n        mediaRecorder.onpause = function() {\r\n            allStates.push('paused');\r\n        };\r\n\r\n        mediaRecorder.onresume = function() {\r\n            allStates.push('resumed');\r\n        };\r\n\r\n        mediaRecorder.onstop = function() {\r\n            allStates.push('stopped');\r\n        };\r\n\r\n        mediaRecorder.onerror = function(error) {\r\n            if (!error) {\r\n                return;\r\n            }\r\n\r\n            if (!error.name) {\r\n                error.name = 'UnknownError';\r\n            }\r\n\r\n            allStates.push('error: ' + error);\r\n\r\n            if (!config.disableLogs) {\r\n                // via: https://w3c.github.io/mediacapture-record/MediaRecorder.html#exception-summary\r\n                if (error.name.toString().toLowerCase().indexOf('invalidstate') !== -1) {\r\n                    console.error('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.', error);\r\n                } else if (error.name.toString().toLowerCase().indexOf('notsupported') !== -1) {\r\n                    console.error('MIME type (', recorderHints.mimeType, ') is not supported.', error);\r\n                } else if (error.name.toString().toLowerCase().indexOf('security') !== -1) {\r\n                    console.error('MediaRecorder security error', error);\r\n                }\r\n\r\n                // older code below\r\n                else if (error.name === 'OutOfMemory') {\r\n                    console.error('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\r\n                } else if (error.name === 'IllegalStreamModification') {\r\n                    console.error('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\r\n                } else if (error.name === 'OtherRecordingError') {\r\n                    console.error('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\r\n                } else if (error.name === 'GenericError') {\r\n                    console.error('The UA cannot provide the codec or recording option that has been requested.', error);\r\n                } else {\r\n                    console.error('MediaRecorder Error', error);\r\n                }\r\n            }\r\n\r\n            (function(looper) {\r\n                if (!self.manuallyStopped && mediaRecorder && mediaRecorder.state === 'inactive') {\r\n                    delete config.timeslice;\r\n\r\n                    // 10 minutes, enough?\r\n                    mediaRecorder.start(10 * 60 * 1000);\r\n                    return;\r\n                }\r\n\r\n                setTimeout(looper, 1000);\r\n            })();\r\n\r\n            if (mediaRecorder.state !== 'inactive' && mediaRecorder.state !== 'stopped') {\r\n                mediaRecorder.stop();\r\n            }\r\n        };\r\n\r\n        if (typeof config.timeSlice === 'number') {\r\n            updateTimeStamp();\r\n            mediaRecorder.start(config.timeSlice);\r\n        } else {\r\n            // default is 60 minutes; enough?\r\n            // use config => {timeSlice: 1000} otherwise\r\n\r\n            mediaRecorder.start(3.6e+6);\r\n        }\r\n\r\n        if (config.initCallback) {\r\n            config.initCallback(); // old code\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @property {Array} timestamps - Array of time stamps\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * console.log(recorder.timestamps);\r\n     */\r\n    this.timestamps = [];\r\n\r\n    function updateTimeStamp() {\r\n        self.timestamps.push(new Date().getTime());\r\n\r\n        if (typeof config.onTimeStamp === 'function') {\r\n            config.onTimeStamp(self.timestamps[self.timestamps.length - 1], self.timestamps);\r\n        }\r\n    }\r\n\r\n    function getMimeType(secondObject) {\r\n        if (mediaRecorder && mediaRecorder.mimeType) {\r\n            return mediaRecorder.mimeType;\r\n        }\r\n\r\n        return secondObject.mimeType || 'video/webm';\r\n    }\r\n\r\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        callback = callback || function() {};\r\n\r\n        self.manuallyStopped = true; // used inside the mediaRecorder.onerror\r\n\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        this.recordingCallback = callback;\r\n\r\n        if (mediaRecorder.state === 'recording') {\r\n            mediaRecorder.stop();\r\n        }\r\n\r\n        if (typeof config.timeSlice === 'number') {\r\n            setTimeout(function() {\r\n                self.blob = new Blob(arrayOfBlobs, {\r\n                    type: getMimeType(config)\r\n                });\r\n\r\n                self.recordingCallback(self.blob);\r\n            }, 100);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (mediaRecorder.state === 'recording') {\r\n            mediaRecorder.pause();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (mediaRecorder.state === 'paused') {\r\n            mediaRecorder.resume();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */\r\n    this.clearRecordedData = function() {\r\n        if (mediaRecorder && mediaRecorder.state === 'recording') {\r\n            self.stop(clearRecordedDataCB);\r\n        }\r\n\r\n        clearRecordedDataCB();\r\n    };\r\n\r\n    function clearRecordedDataCB() {\r\n        arrayOfBlobs = [];\r\n        mediaRecorder = null;\r\n        self.timestamps = [];\r\n    }\r\n\r\n    // Reference to \"MediaRecorder\" object\r\n    var mediaRecorder;\r\n\r\n    /**\r\n     * Access to native MediaRecorder API\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @instance\r\n     * @example\r\n     * var internal = recorder.getInternalRecorder();\r\n     * internal.ondataavailable = function() {}; // override\r\n     * internal.stream, internal.onpause, internal.onstop, etc.\r\n     * @returns {Object} Returns internal recording object.\r\n     */\r\n    this.getInternalRecorder = function() {\r\n        return mediaRecorder;\r\n    };\r\n\r\n    function isMediaStreamActive() {\r\n        if ('active' in mediaStream) {\r\n            if (!mediaStream.active) {\r\n                return false;\r\n            }\r\n        } else if ('ended' in mediaStream) { // old hack\r\n            if (mediaStream.ended) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.stop(function() {\r\n     *     var blob = recorder.blob;\r\n     * });\r\n     */\r\n    this.blob = null;\r\n\r\n\r\n    /**\r\n     * Get MediaRecorder readonly state.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * var state = recorder.getState();\r\n     * @returns {String} Returns recording state.\r\n     */\r\n    this.getState = function() {\r\n        if (!mediaRecorder) {\r\n            return 'inactive';\r\n        }\r\n\r\n        return mediaRecorder.state || 'inactive';\r\n    };\r\n\r\n    // list of all recording states\r\n    var allStates = [];\r\n\r\n    /**\r\n     * Get MediaRecorder all recording states.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * var state = recorder.getAllStates();\r\n     * @returns {Array} Returns all recording states\r\n     */\r\n    this.getAllStates = function() {\r\n        return allStates;\r\n    };\r\n\r\n    // if any Track within the MediaStream is muted or not enabled at any time, \r\n    // the browser will only record black frames \r\n    // or silence since that is the content produced by the Track\r\n    // so we need to stopRecording as soon as any single track ends.\r\n    if (typeof config.checkForInactiveTracks === 'undefined') {\r\n        config.checkForInactiveTracks = false; // disable to minimize CPU usage\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // this method checks if media stream is stopped\r\n    // or if any track is ended.\r\n    (function looper() {\r\n        if (!mediaRecorder || config.checkForInactiveTracks === false) {\r\n            return;\r\n        }\r\n\r\n        if (isMediaStreamActive() === false) {\r\n            if (!config.disableLogs) {\r\n                console.log('MediaStream seems stopped.');\r\n            }\r\n            self.stop();\r\n            return;\r\n        }\r\n\r\n        setTimeout(looper, 1000); // check every second\r\n    })();\r\n\r\n    // for debugging\r\n    this.name = 'MediaStreamRecorder';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.MediaStreamRecorder = MediaStreamRecorder;\r\n}\n\r\n// source code from: http://typedarray.org/wp-content/projects/WebAudioRecorder/script.js\r\n// https://github.com/mattdiamond/Recorderjs#license-mit\r\n// ______________________\r\n// StereoAudioRecorder.js\r\n\r\n/**\r\n * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring \"stereo\" audio-recording in chrome.\r\n * @summary JavaScript standalone object for stereo audio recording.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef StereoAudioRecorder\r\n * @class\r\n * @example\r\n * var recorder = new StereoAudioRecorder(MediaStream, {\r\n *     sampleRate: 44100,\r\n *     bufferSize: 4096\r\n * });\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}\r\n */\r\n\r\nfunction StereoAudioRecorder(mediaStream, config) {\r\n    if (!getTracks(mediaStream, 'audio').length) {\r\n        throw 'Your stream has no audio tracks.';\r\n    }\r\n\r\n    config = config || {};\r\n\r\n    var self = this;\r\n\r\n    // variables\r\n    var leftchannel = [];\r\n    var rightchannel = [];\r\n    var recording = false;\r\n    var recordingLength = 0;\r\n    var jsAudioNode;\r\n\r\n    var numberOfAudioChannels = 2;\r\n\r\n    /**\r\n     * Set sample rates such as 8K or 16K. Reference: http://stackoverflow.com/a/28977136/552182\r\n     * @property {number} desiredSampRate - Desired Bits per sample * 1000\r\n     * @memberof StereoAudioRecorder\r\n     * @instance\r\n     * @example\r\n     * var recorder = StereoAudioRecorder(mediaStream, {\r\n     *   desiredSampRate: 16 * 1000 // bits-per-sample * 1000\r\n     * });\r\n     */\r\n    var desiredSampRate = config.desiredSampRate;\r\n\r\n    // backward compatibility\r\n    if (config.leftChannel === true) {\r\n        numberOfAudioChannels = 1;\r\n    }\r\n\r\n    if (config.numberOfAudioChannels === 1) {\r\n        numberOfAudioChannels = 1;\r\n    }\r\n\r\n    if (!numberOfAudioChannels || numberOfAudioChannels < 1) {\r\n        numberOfAudioChannels = 2;\r\n    }\r\n\r\n    if (!config.disableLogs) {\r\n        console.log('StereoAudioRecorder is set to record number of channels: ' + numberOfAudioChannels);\r\n    }\r\n\r\n    // if any Track within the MediaStream is muted or not enabled at any time, \r\n    // the browser will only record black frames \r\n    // or silence since that is the content produced by the Track\r\n    // so we need to stopRecording as soon as any single track ends.\r\n    if (typeof config.checkForInactiveTracks === 'undefined') {\r\n        config.checkForInactiveTracks = true;\r\n    }\r\n\r\n    function isMediaStreamActive() {\r\n        if (config.checkForInactiveTracks === false) {\r\n            // always return \"true\"\r\n            return true;\r\n        }\r\n\r\n        if ('active' in mediaStream) {\r\n            if (!mediaStream.active) {\r\n                return false;\r\n            }\r\n        } else if ('ended' in mediaStream) { // old hack\r\n            if (mediaStream.ended) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        if (isMediaStreamActive() === false) {\r\n            throw 'Please make sure MediaStream is active.';\r\n        }\r\n\r\n        resetVariables();\r\n\r\n        isAudioProcessStarted = isPaused = false;\r\n        recording = true;\r\n\r\n        if (typeof config.timeSlice !== 'undefined') {\r\n            looper();\r\n        }\r\n    };\r\n\r\n    function mergeLeftRightBuffers(config, callback) {\r\n        function mergeAudioBuffers(config, cb) {\r\n            var numberOfAudioChannels = config.numberOfAudioChannels;\r\n\r\n            // todo: \"slice(0)\" --- is it causes loop? Should be removed?\r\n            var leftBuffers = config.leftBuffers.slice(0);\r\n            var rightBuffers = config.rightBuffers.slice(0);\r\n            var sampleRate = config.sampleRate;\r\n            var internalInterleavedLength = config.internalInterleavedLength;\r\n            var desiredSampRate = config.desiredSampRate;\r\n\r\n            if (numberOfAudioChannels === 2) {\r\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\r\n                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);\r\n\r\n                if (desiredSampRate) {\r\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\r\n                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);\r\n                }\r\n            }\r\n\r\n            if (numberOfAudioChannels === 1) {\r\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\r\n\r\n                if (desiredSampRate) {\r\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\r\n                }\r\n            }\r\n\r\n            // set sample rate as desired sample rate\r\n            if (desiredSampRate) {\r\n                sampleRate = desiredSampRate;\r\n            }\r\n\r\n            // for changing the sampling rate, reference:\r\n            // http://stackoverflow.com/a/28977136/552182\r\n            function interpolateArray(data, newSampleRate, oldSampleRate) {\r\n                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));\r\n                var newData = [];\r\n                var springFactor = Number((data.length - 1) / (fitCount - 1));\r\n                newData[0] = data[0];\r\n                for (var i = 1; i < fitCount - 1; i++) {\r\n                    var tmp = i * springFactor;\r\n                    var before = Number(Math.floor(tmp)).toFixed();\r\n                    var after = Number(Math.ceil(tmp)).toFixed();\r\n                    var atPoint = tmp - before;\r\n                    newData[i] = linearInterpolate(data[before], data[after], atPoint);\r\n                }\r\n                newData[fitCount - 1] = data[data.length - 1];\r\n                return newData;\r\n            }\r\n\r\n            function linearInterpolate(before, after, atPoint) {\r\n                return before + (after - before) * atPoint;\r\n            }\r\n\r\n            function mergeBuffers(channelBuffer, rLength) {\r\n                var result = new Float64Array(rLength);\r\n                var offset = 0;\r\n                var lng = channelBuffer.length;\r\n\r\n                for (var i = 0; i < lng; i++) {\r\n                    var buffer = channelBuffer[i];\r\n                    result.set(buffer, offset);\r\n                    offset += buffer.length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n            function interleave(leftChannel, rightChannel) {\r\n                var length = leftChannel.length + rightChannel.length;\r\n\r\n                var result = new Float64Array(length);\r\n\r\n                var inputIndex = 0;\r\n\r\n                for (var index = 0; index < length;) {\r\n                    result[index++] = leftChannel[inputIndex];\r\n                    result[index++] = rightChannel[inputIndex];\r\n                    inputIndex++;\r\n                }\r\n                return result;\r\n            }\r\n\r\n            function writeUTFBytes(view, offset, string) {\r\n                var lng = string.length;\r\n                for (var i = 0; i < lng; i++) {\r\n                    view.setUint8(offset + i, string.charCodeAt(i));\r\n                }\r\n            }\r\n\r\n            // interleave both channels together\r\n            var interleaved;\r\n\r\n            if (numberOfAudioChannels === 2) {\r\n                interleaved = interleave(leftBuffers, rightBuffers);\r\n            }\r\n\r\n            if (numberOfAudioChannels === 1) {\r\n                interleaved = leftBuffers;\r\n            }\r\n\r\n            var interleavedLength = interleaved.length;\r\n\r\n            // create wav file\r\n            var resultingBufferLength = 44 + interleavedLength * 2;\r\n\r\n            var buffer = new ArrayBuffer(resultingBufferLength);\r\n\r\n            var view = new DataView(buffer);\r\n\r\n            // RIFF chunk descriptor/identifier \r\n            writeUTFBytes(view, 0, 'RIFF');\r\n\r\n            // RIFF chunk length\r\n            // changed \"44\" to \"36\" via #401\r\n            view.setUint32(4, 36 + interleavedLength * 2, true);\r\n\r\n            // RIFF type \r\n            writeUTFBytes(view, 8, 'WAVE');\r\n\r\n            // format chunk identifier \r\n            // FMT sub-chunk\r\n            writeUTFBytes(view, 12, 'fmt ');\r\n\r\n            // format chunk length \r\n            view.setUint32(16, 16, true);\r\n\r\n            // sample format (raw)\r\n            view.setUint16(20, 1, true);\r\n\r\n            // stereo (2 channels)\r\n            view.setUint16(22, numberOfAudioChannels, true);\r\n\r\n            // sample rate \r\n            view.setUint32(24, sampleRate, true);\r\n\r\n            // byte rate (sample rate * block align)\r\n            view.setUint32(28, sampleRate * 2, true);\r\n\r\n            // block align (channel count * bytes per sample) \r\n            view.setUint16(32, numberOfAudioChannels * 2, true);\r\n\r\n            // bits per sample \r\n            view.setUint16(34, 16, true);\r\n\r\n            // data sub-chunk\r\n            // data chunk identifier \r\n            writeUTFBytes(view, 36, 'data');\r\n\r\n            // data chunk length \r\n            view.setUint32(40, interleavedLength * 2, true);\r\n\r\n            // write the PCM samples\r\n            var lng = interleavedLength;\r\n            var index = 44;\r\n            var volume = 1;\r\n            for (var i = 0; i < lng; i++) {\r\n                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\r\n                index += 2;\r\n            }\r\n\r\n            if (cb) {\r\n                return cb({\r\n                    buffer: buffer,\r\n                    view: view\r\n                });\r\n            }\r\n\r\n            postMessage({\r\n                buffer: buffer,\r\n                view: view\r\n            });\r\n        }\r\n\r\n        if (config.noWorker) {\r\n            mergeAudioBuffers(config, function(data) {\r\n                callback(data.buffer, data.view);\r\n            });\r\n            return;\r\n        }\r\n\r\n\r\n        var webWorker = processInWebWorker(mergeAudioBuffers);\r\n\r\n        webWorker.onmessage = function(event) {\r\n            callback(event.data.buffer, event.data.view);\r\n\r\n            // release memory\r\n            URL.revokeObjectURL(webWorker.workerURL);\r\n\r\n            // kill webworker (or Chrome will kill your page after ~25 calls)\r\n            webWorker.terminate();\r\n        };\r\n\r\n        webWorker.postMessage(config);\r\n    }\r\n\r\n    function processInWebWorker(_function) {\r\n        var workerURL = URL.createObjectURL(new Blob([_function.toString(),\r\n            ';this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\r\n        ], {\r\n            type: 'application/javascript'\r\n        }));\r\n\r\n        var worker = new Worker(workerURL);\r\n        worker.workerURL = workerURL;\r\n        return worker;\r\n    }\r\n\r\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        callback = callback || function() {};\r\n\r\n        // stop recording\r\n        recording = false;\r\n\r\n        mergeLeftRightBuffers({\r\n            desiredSampRate: desiredSampRate,\r\n            sampleRate: sampleRate,\r\n            numberOfAudioChannels: numberOfAudioChannels,\r\n            internalInterleavedLength: recordingLength,\r\n            leftBuffers: leftchannel,\r\n            rightBuffers: numberOfAudioChannels === 1 ? [] : rightchannel,\r\n            noWorker: config.noWorker\r\n        }, function(buffer, view) {\r\n            /**\r\n             * @property {Blob} blob - The recorded blob object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var blob = recorder.blob;\r\n             * });\r\n             */\r\n            self.blob = new Blob([view], {\r\n                type: 'audio/wav'\r\n            });\r\n\r\n            /**\r\n             * @property {ArrayBuffer} buffer - The recorded buffer object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var buffer = recorder.buffer;\r\n             * });\r\n             */\r\n            self.buffer = new ArrayBuffer(view.buffer.byteLength);\r\n\r\n            /**\r\n             * @property {DataView} view - The recorded data-view object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var view = recorder.view;\r\n             * });\r\n             */\r\n            self.view = view;\r\n\r\n            self.sampleRate = desiredSampRate || sampleRate;\r\n            self.bufferSize = bufferSize;\r\n\r\n            // recorded audio length\r\n            self.length = recordingLength;\r\n\r\n            isAudioProcessStarted = false;\r\n\r\n            if (callback) {\r\n                callback(self.blob);\r\n            }\r\n        });\r\n    };\r\n\r\n    if (typeof RecordRTC.Storage === 'undefined') {\r\n        RecordRTC.Storage = {\r\n            AudioContextConstructor: null,\r\n            AudioContext: window.AudioContext || window.webkitAudioContext\r\n        };\r\n    }\r\n\r\n    if (!RecordRTC.Storage.AudioContextConstructor || RecordRTC.Storage.AudioContextConstructor.state === 'closed') {\r\n        RecordRTC.Storage.AudioContextConstructor = new RecordRTC.Storage.AudioContext();\r\n    }\r\n\r\n    var context = RecordRTC.Storage.AudioContextConstructor;\r\n\r\n    // creates an audio node from the microphone incoming stream\r\n    var audioInput = context.createMediaStreamSource(mediaStream);\r\n\r\n    var legalBufferValues = [0, 256, 512, 1024, 2048, 4096, 8192, 16384];\r\n\r\n    /**\r\n     * From the spec: This value controls how frequently the audioprocess event is\r\n     * dispatched and how many sample-frames need to be processed each call.\r\n     * Lower values for buffer size will result in a lower (better) latency.\r\n     * Higher values will be necessary to avoid audio breakup and glitches\r\n     * The size of the buffer (in sample-frames) which needs to\r\n     * be processed each time onprocessaudio is called.\r\n     * Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).\r\n     * @property {number} bufferSize - Buffer-size for how frequently the audioprocess event is dispatched.\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder = new StereoAudioRecorder(mediaStream, {\r\n     *     bufferSize: 4096\r\n     * });\r\n     */\r\n\r\n    // \"0\" means, let chrome decide the most accurate buffer-size for current platform.\r\n    var bufferSize = typeof config.bufferSize === 'undefined' ? 4096 : config.bufferSize;\r\n\r\n    if (legalBufferValues.indexOf(bufferSize) === -1) {\r\n        if (!config.disableLogs) {\r\n            console.log('Legal values for buffer-size are ' + JSON.stringify(legalBufferValues, null, '\\t'));\r\n        }\r\n    }\r\n\r\n    if (context.createJavaScriptNode) {\r\n        jsAudioNode = context.createJavaScriptNode(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\r\n    } else if (context.createScriptProcessor) {\r\n        jsAudioNode = context.createScriptProcessor(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\r\n    } else {\r\n        throw 'WebAudio API has no support on this browser.';\r\n    }\r\n\r\n    // connect the stream to the script processor\r\n    audioInput.connect(jsAudioNode);\r\n\r\n    if (!config.bufferSize) {\r\n        bufferSize = jsAudioNode.bufferSize; // device buffer-size\r\n    }\r\n\r\n    /**\r\n     * The sample rate (in sample-frames per second) at which the\r\n     * AudioContext handles audio. It is assumed that all AudioNodes\r\n     * in the context run at this rate. In making this assumption,\r\n     * sample-rate converters or \"varispeed\" processors are not supported\r\n     * in real-time processing.\r\n     * The sampleRate parameter describes the sample-rate of the\r\n     * linear PCM audio data in the buffer in sample-frames per second.\r\n     * An implementation must support sample-rates in at least\r\n     * the range 22050 to 96000.\r\n     * @property {number} sampleRate - Buffer-size for how frequently the audioprocess event is dispatched.\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder = new StereoAudioRecorder(mediaStream, {\r\n     *     sampleRate: 44100\r\n     * });\r\n     */\r\n    var sampleRate = typeof config.sampleRate !== 'undefined' ? config.sampleRate : context.sampleRate || 44100;\r\n\r\n    if (sampleRate < 22050 || sampleRate > 96000) {\r\n        // Ref: http://stackoverflow.com/a/26303918/552182\r\n        if (!config.disableLogs) {\r\n            console.log('sample-rate must be under range 22050 and 96000.');\r\n        }\r\n    }\r\n\r\n    if (!config.disableLogs) {\r\n        if (config.desiredSampRate) {\r\n            console.log('Desired sample-rate: ' + config.desiredSampRate);\r\n        }\r\n    }\r\n\r\n    var isPaused = false;\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        isPaused = true;\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        if (isMediaStreamActive() === false) {\r\n            throw 'Please make sure MediaStream is active.';\r\n        }\r\n\r\n        if (!recording) {\r\n            if (!config.disableLogs) {\r\n                console.log('Seems recording has been restarted.');\r\n            }\r\n            this.record();\r\n            return;\r\n        }\r\n\r\n        isPaused = false;\r\n    };\r\n\r\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */\r\n    this.clearRecordedData = function() {\r\n        config.checkForInactiveTracks = false;\r\n\r\n        if (recording) {\r\n            this.stop(clearRecordedDataCB);\r\n        }\r\n\r\n        clearRecordedDataCB();\r\n    };\r\n\r\n    function resetVariables() {\r\n        leftchannel = [];\r\n        rightchannel = [];\r\n        recordingLength = 0;\r\n        isAudioProcessStarted = false;\r\n        recording = false;\r\n        isPaused = false;\r\n        context = null;\r\n\r\n        self.leftchannel = leftchannel;\r\n        self.rightchannel = rightchannel;\r\n        self.numberOfAudioChannels = numberOfAudioChannels;\r\n        self.desiredSampRate = desiredSampRate;\r\n        self.sampleRate = sampleRate;\r\n        self.recordingLength = recordingLength;\r\n\r\n        intervalsBasedBuffers = {\r\n            left: [],\r\n            right: [],\r\n            recordingLength: 0\r\n        };\r\n    }\r\n\r\n    function clearRecordedDataCB() {\r\n        if (jsAudioNode) {\r\n            jsAudioNode.onaudioprocess = null;\r\n            jsAudioNode.disconnect();\r\n            jsAudioNode = null;\r\n        }\r\n\r\n        if (audioInput) {\r\n            audioInput.disconnect();\r\n            audioInput = null;\r\n        }\r\n\r\n        resetVariables();\r\n    }\r\n\r\n    // for debugging\r\n    this.name = 'StereoAudioRecorder';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n\r\n    var isAudioProcessStarted = false;\r\n\r\n    function onAudioProcessDataAvailable(e) {\r\n        if (isPaused) {\r\n            return;\r\n        }\r\n\r\n        if (isMediaStreamActive() === false) {\r\n            if (!config.disableLogs) {\r\n                console.log('MediaStream seems stopped.');\r\n            }\r\n            jsAudioNode.disconnect();\r\n            recording = false;\r\n        }\r\n\r\n        if (!recording) {\r\n            if (audioInput) {\r\n                audioInput.disconnect();\r\n                audioInput = null;\r\n            }\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * This method is called on \"onaudioprocess\" event's first invocation.\r\n         * @method {function} onAudioProcessStarted\r\n         * @memberof StereoAudioRecorder\r\n         * @example\r\n         * recorder.onAudioProcessStarted: function() { };\r\n         */\r\n        if (!isAudioProcessStarted) {\r\n            isAudioProcessStarted = true;\r\n            if (config.onAudioProcessStarted) {\r\n                config.onAudioProcessStarted();\r\n            }\r\n\r\n            if (config.initCallback) {\r\n                config.initCallback();\r\n            }\r\n        }\r\n\r\n        var left = e.inputBuffer.getChannelData(0);\r\n\r\n        // we clone the samples\r\n        var chLeft = new Float32Array(left);\r\n        leftchannel.push(chLeft);\r\n\r\n        if (numberOfAudioChannels === 2) {\r\n            var right = e.inputBuffer.getChannelData(1);\r\n            var chRight = new Float32Array(right);\r\n            rightchannel.push(chRight);\r\n        }\r\n\r\n        recordingLength += bufferSize;\r\n\r\n        // export raw PCM\r\n        self.recordingLength = recordingLength;\r\n\r\n        if (typeof config.timeSlice !== 'undefined') {\r\n            intervalsBasedBuffers.recordingLength += bufferSize;\r\n            intervalsBasedBuffers.left.push(chLeft);\r\n\r\n            if (numberOfAudioChannels === 2) {\r\n                intervalsBasedBuffers.right.push(chRight);\r\n            }\r\n        }\r\n    }\r\n\r\n    jsAudioNode.onaudioprocess = onAudioProcessDataAvailable;\r\n\r\n    // to prevent self audio to be connected with speakers\r\n    if (context.createMediaStreamDestination) {\r\n        jsAudioNode.connect(context.createMediaStreamDestination());\r\n    } else {\r\n        jsAudioNode.connect(context.destination);\r\n    }\r\n\r\n    // export raw PCM\r\n    this.leftchannel = leftchannel;\r\n    this.rightchannel = rightchannel;\r\n    this.numberOfAudioChannels = numberOfAudioChannels;\r\n    this.desiredSampRate = desiredSampRate;\r\n    this.sampleRate = sampleRate;\r\n    self.recordingLength = recordingLength;\r\n\r\n    // helper for intervals based blobs\r\n    var intervalsBasedBuffers = {\r\n        left: [],\r\n        right: [],\r\n        recordingLength: 0\r\n    };\r\n\r\n    // this looper is used to support intervals based blobs (via timeSlice+ondataavailable)\r\n    function looper() {\r\n        if (!recording || typeof config.ondataavailable !== 'function' || typeof config.timeSlice === 'undefined') {\r\n            return;\r\n        }\r\n\r\n        if (intervalsBasedBuffers.left.length) {\r\n            mergeLeftRightBuffers({\r\n                desiredSampRate: desiredSampRate,\r\n                sampleRate: sampleRate,\r\n                numberOfAudioChannels: numberOfAudioChannels,\r\n                internalInterleavedLength: intervalsBasedBuffers.recordingLength,\r\n                leftBuffers: intervalsBasedBuffers.left,\r\n                rightBuffers: numberOfAudioChannels === 1 ? [] : intervalsBasedBuffers.right\r\n            }, function(buffer, view) {\r\n                var blob = new Blob([view], {\r\n                    type: 'audio/wav'\r\n                });\r\n                config.ondataavailable(blob);\r\n\r\n                setTimeout(looper, config.timeSlice);\r\n            });\r\n\r\n            intervalsBasedBuffers = {\r\n                left: [],\r\n                right: [],\r\n                recordingLength: 0\r\n            };\r\n        } else {\r\n            setTimeout(looper, config.timeSlice);\r\n        }\r\n    }\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.StereoAudioRecorder = StereoAudioRecorder;\r\n}\r\n\r\n// _________________\r\n// CanvasRecorder.js\r\n\r\n/**\r\n * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.\r\n * @summary HTML2Canvas recording into video WebM.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef CanvasRecorder\r\n * @class\r\n * @example\r\n * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.\r\n * @param {object} config - {disableLogs:true, initCallback: function}\r\n */\r\n\r\nfunction CanvasRecorder(htmlElement, config) {\r\n    if (typeof html2canvas === 'undefined') {\r\n        throw 'Please link: https://www.webrtc-experiment.com/screenshot.js';\r\n    }\r\n\r\n    config = config || {};\r\n    if (!config.frameInterval) {\r\n        config.frameInterval = 10;\r\n    }\r\n\r\n    // via DetectRTC.js\r\n    var isCanvasSupportsStreamCapturing = false;\r\n    ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function(item) {\r\n        if (item in document.createElement('canvas')) {\r\n            isCanvasSupportsStreamCapturing = true;\r\n        }\r\n    });\r\n\r\n    var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome;\r\n\r\n    var chromeVersion = 50;\r\n    var matchArray = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\r\n    if (_isChrome && matchArray && matchArray[2]) {\r\n        chromeVersion = parseInt(matchArray[2], 10);\r\n    }\r\n\r\n    if (_isChrome && chromeVersion < 52) {\r\n        isCanvasSupportsStreamCapturing = false;\r\n    }\r\n\r\n    if (config.useWhammyRecorder) {\r\n        isCanvasSupportsStreamCapturing = false;\r\n    }\r\n\r\n    var globalCanvas, mediaStreamRecorder;\r\n\r\n    if (isCanvasSupportsStreamCapturing) {\r\n        if (!config.disableLogs) {\r\n            console.log('Your browser supports both MediRecorder API and canvas.captureStream!');\r\n        }\r\n\r\n        if (htmlElement instanceof HTMLCanvasElement) {\r\n            globalCanvas = htmlElement;\r\n        } else if (htmlElement instanceof CanvasRenderingContext2D) {\r\n            globalCanvas = htmlElement.canvas;\r\n        } else {\r\n            throw 'Please pass either HTMLCanvasElement or CanvasRenderingContext2D.';\r\n        }\r\n    } else if (!!navigator.mozGetUserMedia) {\r\n        if (!config.disableLogs) {\r\n            console.error('Canvas recording is NOT supported in Firefox.');\r\n        }\r\n    }\r\n\r\n    var isRecording;\r\n\r\n    /**\r\n     * This method records Canvas.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        isRecording = true;\r\n\r\n        if (isCanvasSupportsStreamCapturing && !config.useWhammyRecorder) {\r\n            // CanvasCaptureMediaStream\r\n            var canvasMediaStream;\r\n            if ('captureStream' in globalCanvas) {\r\n                canvasMediaStream = globalCanvas.captureStream(25); // 25 FPS\r\n            } else if ('mozCaptureStream' in globalCanvas) {\r\n                canvasMediaStream = globalCanvas.mozCaptureStream(25);\r\n            } else if ('webkitCaptureStream' in globalCanvas) {\r\n                canvasMediaStream = globalCanvas.webkitCaptureStream(25);\r\n            }\r\n\r\n            try {\r\n                var mdStream = new MediaStream();\r\n                mdStream.addTrack(getTracks(canvasMediaStream, 'video')[0]);\r\n                canvasMediaStream = mdStream;\r\n            } catch (e) {}\r\n\r\n            if (!canvasMediaStream) {\r\n                throw 'captureStream API are NOT available.';\r\n            }\r\n\r\n            // Note: Jan 18, 2016 status is that, \r\n            // Firefox MediaRecorder API can't record CanvasCaptureMediaStream object.\r\n            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {\r\n                mimeType: config.mimeType || 'video/webm'\r\n            });\r\n            mediaStreamRecorder.record();\r\n        } else {\r\n            whammy.frames = [];\r\n            lastTime = new Date().getTime();\r\n            drawCanvasFrame();\r\n        }\r\n\r\n        if (config.initCallback) {\r\n            config.initCallback();\r\n        }\r\n    };\r\n\r\n    this.getWebPImages = function(callback) {\r\n        if (htmlElement.nodeName.toLowerCase() !== 'canvas') {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        var framesLength = whammy.frames.length;\r\n        whammy.frames.forEach(function(frame, idx) {\r\n            var framesRemaining = framesLength - idx;\r\n            if (!config.disableLogs) {\r\n                console.log(framesRemaining + '/' + framesLength + ' frames remaining');\r\n            }\r\n\r\n            if (config.onEncodingCallback) {\r\n                config.onEncodingCallback(framesRemaining, framesLength);\r\n            }\r\n\r\n            var webp = frame.image.toDataURL('image/webp', 1);\r\n            whammy.frames[idx].image = webp;\r\n        });\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('Generating WebM');\r\n        }\r\n\r\n        callback();\r\n    };\r\n\r\n    /**\r\n     * This method stops recording Canvas.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        isRecording = false;\r\n\r\n        var that = this;\r\n\r\n        if (isCanvasSupportsStreamCapturing && mediaStreamRecorder) {\r\n            mediaStreamRecorder.stop(callback);\r\n            return;\r\n        }\r\n\r\n        this.getWebPImages(function() {\r\n            /**\r\n             * @property {Blob} blob - Recorded frames in video/webm blob.\r\n             * @memberof CanvasRecorder\r\n             * @example\r\n             * recorder.stop(function() {\r\n             *     var blob = recorder.blob;\r\n             * });\r\n             */\r\n            whammy.compile(function(blob) {\r\n                if (!config.disableLogs) {\r\n                    console.log('Recording finished!');\r\n                }\r\n\r\n                that.blob = blob;\r\n\r\n                if (that.blob.forEach) {\r\n                    that.blob = new Blob([], {\r\n                        type: 'video/webm'\r\n                    });\r\n                }\r\n\r\n                if (callback) {\r\n                    callback(that.blob);\r\n                }\r\n\r\n                whammy.frames = [];\r\n            });\r\n        });\r\n    };\r\n\r\n    var isPausedRecording = false;\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        isPausedRecording = true;\r\n\r\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\r\n            mediaStreamRecorder.pause();\r\n            return;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        isPausedRecording = false;\r\n\r\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\r\n            mediaStreamRecorder.resume();\r\n            return;\r\n        }\r\n\r\n        if (!isRecording) {\r\n            this.record();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */\r\n    this.clearRecordedData = function() {\r\n        if (isRecording) {\r\n            this.stop(clearRecordedDataCB);\r\n        }\r\n        clearRecordedDataCB();\r\n    };\r\n\r\n    function clearRecordedDataCB() {\r\n        whammy.frames = [];\r\n        isRecording = false;\r\n        isPausedRecording = false;\r\n    }\r\n\r\n    // for debugging\r\n    this.name = 'CanvasRecorder';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n\r\n    function cloneCanvas() {\r\n        //create a new canvas\r\n        var newCanvas = document.createElement('canvas');\r\n        var context = newCanvas.getContext('2d');\r\n\r\n        //set dimensions\r\n        newCanvas.width = htmlElement.width;\r\n        newCanvas.height = htmlElement.height;\r\n\r\n        //apply the old canvas to the new one\r\n        context.drawImage(htmlElement, 0, 0);\r\n\r\n        //return the new canvas\r\n        return newCanvas;\r\n    }\r\n\r\n    function drawCanvasFrame() {\r\n        if (isPausedRecording) {\r\n            lastTime = new Date().getTime();\r\n            return setTimeout(drawCanvasFrame, 500);\r\n        }\r\n\r\n        if (htmlElement.nodeName.toLowerCase() === 'canvas') {\r\n            var duration = new Date().getTime() - lastTime;\r\n            // via #206, by Jack i.e. @Seymourr\r\n            lastTime = new Date().getTime();\r\n\r\n            whammy.frames.push({\r\n                image: cloneCanvas(),\r\n                duration: duration\r\n            });\r\n\r\n            if (isRecording) {\r\n                setTimeout(drawCanvasFrame, config.frameInterval);\r\n            }\r\n            return;\r\n        }\r\n\r\n        html2canvas(htmlElement, {\r\n            grabMouse: typeof config.showMousePointer === 'undefined' || config.showMousePointer,\r\n            onrendered: function(canvas) {\r\n                var duration = new Date().getTime() - lastTime;\r\n                if (!duration) {\r\n                    return setTimeout(drawCanvasFrame, config.frameInterval);\r\n                }\r\n\r\n                // via #206, by Jack i.e. @Seymourr\r\n                lastTime = new Date().getTime();\r\n\r\n                whammy.frames.push({\r\n                    image: canvas.toDataURL('image/webp', 1),\r\n                    duration: duration\r\n                });\r\n\r\n                if (isRecording) {\r\n                    setTimeout(drawCanvasFrame, config.frameInterval);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    var lastTime = new Date().getTime();\r\n\r\n    var whammy = new Whammy.Video(100);\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.CanvasRecorder = CanvasRecorder;\r\n}\n\r\n// _________________\r\n// WhammyRecorder.js\r\n\r\n/**\r\n * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.\r\n * @summary Video recording feature in Chrome.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef WhammyRecorder\r\n * @class\r\n * @example\r\n * var recorder = new WhammyRecorder(mediaStream);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}\r\n */\r\n\r\nfunction WhammyRecorder(mediaStream, config) {\r\n\r\n    config = config || {};\r\n\r\n    if (!config.frameInterval) {\r\n        config.frameInterval = 10;\r\n    }\r\n\r\n    if (!config.disableLogs) {\r\n        console.log('Using frames-interval:', config.frameInterval);\r\n    }\r\n\r\n    /**\r\n     * This method records video.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        if (!config.width) {\r\n            config.width = 320;\r\n        }\r\n\r\n        if (!config.height) {\r\n            config.height = 240;\r\n        }\r\n\r\n        if (!config.video) {\r\n            config.video = {\r\n                width: config.width,\r\n                height: config.height\r\n            };\r\n        }\r\n\r\n        if (!config.canvas) {\r\n            config.canvas = {\r\n                width: config.width,\r\n                height: config.height\r\n            };\r\n        }\r\n\r\n        canvas.width = config.canvas.width || 320;\r\n        canvas.height = config.canvas.height || 240;\r\n\r\n        context = canvas.getContext('2d');\r\n\r\n        // setting defaults\r\n        if (config.video && config.video instanceof HTMLVideoElement) {\r\n            video = config.video.cloneNode();\r\n\r\n            if (config.initCallback) {\r\n                config.initCallback();\r\n            }\r\n        } else {\r\n            video = document.createElement('video');\r\n\r\n            setSrcObject(mediaStream, video);\r\n\r\n            video.onloadedmetadata = function() { // \"onloadedmetadata\" may NOT work in FF?\r\n                if (config.initCallback) {\r\n                    config.initCallback();\r\n                }\r\n            };\r\n\r\n            video.width = config.video.width;\r\n            video.height = config.video.height;\r\n        }\r\n\r\n        video.muted = true;\r\n        video.play();\r\n\r\n        lastTime = new Date().getTime();\r\n        whammy = new Whammy.Video();\r\n\r\n        if (!config.disableLogs) {\r\n            console.log('canvas resolutions', canvas.width, '*', canvas.height);\r\n            console.log('video width/height', video.width || canvas.width, '*', video.height || canvas.height);\r\n        }\r\n\r\n        drawFrames(config.frameInterval);\r\n    };\r\n\r\n    /**\r\n     * Draw and push frames to Whammy\r\n     * @param {integer} frameInterval - set minimum interval (in milliseconds) between each time we push a frame to Whammy\r\n     */\r\n    function drawFrames(frameInterval) {\r\n        frameInterval = typeof frameInterval !== 'undefined' ? frameInterval : 10;\r\n\r\n        var duration = new Date().getTime() - lastTime;\r\n        if (!duration) {\r\n            return setTimeout(drawFrames, frameInterval, frameInterval);\r\n        }\r\n\r\n        if (isPausedRecording) {\r\n            lastTime = new Date().getTime();\r\n            return setTimeout(drawFrames, 100);\r\n        }\r\n\r\n        // via #206, by Jack i.e. @Seymourr\r\n        lastTime = new Date().getTime();\r\n\r\n        if (video.paused) {\r\n            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\r\n            // Tweak for Android Chrome\r\n            video.play();\r\n        }\r\n\r\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n        whammy.frames.push({\r\n            duration: duration,\r\n            image: canvas.toDataURL('image/webp')\r\n        });\r\n\r\n        if (!isStopDrawing) {\r\n            setTimeout(drawFrames, frameInterval, frameInterval);\r\n        }\r\n    }\r\n\r\n    function asyncLoop(o) {\r\n        var i = -1,\r\n            length = o.length;\r\n\r\n        (function loop() {\r\n            i++;\r\n            if (i === length) {\r\n                o.callback();\r\n                return;\r\n            }\r\n\r\n            // \"setTimeout\" added by Jim McLeod\r\n            setTimeout(function() {\r\n                o.functionToLoop(loop, i);\r\n            }, 1);\r\n        })();\r\n    }\r\n\r\n\r\n    /**\r\n     * remove black frames from the beginning to the specified frame\r\n     * @param {Array} _frames - array of frames to be checked\r\n     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not matched will be found)\r\n     * @param {number} _pixTolerance - 0 - very strict (only black pixel color) ; 1 - all\r\n     * @param {number} _frameTolerance - 0 - very strict (only black frame color) ; 1 - all\r\n     * @returns {Array} - array of frames\r\n     */\r\n    // pull#293 by @volodalexey\r\n    function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance, callback) {\r\n        var localCanvas = document.createElement('canvas');\r\n        localCanvas.width = canvas.width;\r\n        localCanvas.height = canvas.height;\r\n        var context2d = localCanvas.getContext('2d');\r\n        var resultFrames = [];\r\n\r\n        var checkUntilNotBlack = _framesToCheck === -1;\r\n        var endCheckFrame = (_framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length) ?\r\n            _framesToCheck : _frames.length;\r\n        var sampleColor = {\r\n            r: 0,\r\n            g: 0,\r\n            b: 0\r\n        };\r\n        var maxColorDifference = Math.sqrt(\r\n            Math.pow(255, 2) +\r\n            Math.pow(255, 2) +\r\n            Math.pow(255, 2)\r\n        );\r\n        var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;\r\n        var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;\r\n        var doNotCheckNext = false;\r\n\r\n        asyncLoop({\r\n            length: endCheckFrame,\r\n            functionToLoop: function(loop, f) {\r\n                var matchPixCount, endPixCheck, maxPixCount;\r\n\r\n                var finishImage = function() {\r\n                    if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {\r\n                        // console.log('removed black frame : ' + f + ' ; frame duration ' + _frames[f].duration);\r\n                    } else {\r\n                        // console.log('frame is passed : ' + f);\r\n                        if (checkUntilNotBlack) {\r\n                            doNotCheckNext = true;\r\n                        }\r\n                        resultFrames.push(_frames[f]);\r\n                    }\r\n                    loop();\r\n                };\r\n\r\n                if (!doNotCheckNext) {\r\n                    var image = new Image();\r\n                    image.onload = function() {\r\n                        context2d.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n                        var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);\r\n                        matchPixCount = 0;\r\n                        endPixCheck = imageData.data.length;\r\n                        maxPixCount = imageData.data.length / 4;\r\n\r\n                        for (var pix = 0; pix < endPixCheck; pix += 4) {\r\n                            var currentColor = {\r\n                                r: imageData.data[pix],\r\n                                g: imageData.data[pix + 1],\r\n                                b: imageData.data[pix + 2]\r\n                            };\r\n                            var colorDifference = Math.sqrt(\r\n                                Math.pow(currentColor.r - sampleColor.r, 2) +\r\n                                Math.pow(currentColor.g - sampleColor.g, 2) +\r\n                                Math.pow(currentColor.b - sampleColor.b, 2)\r\n                            );\r\n                            // difference in color it is difference in color vectors (r1,g1,b1) <=> (r2,g2,b2)\r\n                            if (colorDifference <= maxColorDifference * pixTolerance) {\r\n                                matchPixCount++;\r\n                            }\r\n                        }\r\n                        finishImage();\r\n                    };\r\n                    image.src = _frames[f].image;\r\n                } else {\r\n                    finishImage();\r\n                }\r\n            },\r\n            callback: function() {\r\n                resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));\r\n\r\n                if (resultFrames.length <= 0) {\r\n                    // at least one last frame should be available for next manipulation\r\n                    // if total duration of all frames will be < 1000 than ffmpeg doesn't work well...\r\n                    resultFrames.push(_frames[_frames.length - 1]);\r\n                }\r\n                callback(resultFrames);\r\n            }\r\n        });\r\n    }\r\n\r\n    var isStopDrawing = false;\r\n\r\n    /**\r\n     * This method stops recording video.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        callback = callback || function() {};\r\n\r\n        isStopDrawing = true;\r\n\r\n        var _this = this;\r\n        // analyse of all frames takes some time!\r\n        setTimeout(function() {\r\n            // e.g. dropBlackFrames(frames, 10, 1, 1) - will cut all 10 frames\r\n            // e.g. dropBlackFrames(frames, 10, 0.5, 0.5) - will analyse 10 frames\r\n            // e.g. dropBlackFrames(frames, 10) === dropBlackFrames(frames, 10, 0, 0) - will analyse 10 frames with strict black color\r\n            dropBlackFrames(whammy.frames, -1, null, null, function(frames) {\r\n                whammy.frames = frames;\r\n\r\n                // to display advertisement images!\r\n                if (config.advertisement && config.advertisement.length) {\r\n                    whammy.frames = config.advertisement.concat(whammy.frames);\r\n                }\r\n\r\n                /**\r\n                 * @property {Blob} blob - Recorded frames in video/webm blob.\r\n                 * @memberof WhammyRecorder\r\n                 * @example\r\n                 * recorder.stop(function() {\r\n                 *     var blob = recorder.blob;\r\n                 * });\r\n                 */\r\n                whammy.compile(function(blob) {\r\n                    _this.blob = blob;\r\n\r\n                    if (_this.blob.forEach) {\r\n                        _this.blob = new Blob([], {\r\n                            type: 'video/webm'\r\n                        });\r\n                    }\r\n\r\n                    if (callback) {\r\n                        callback(_this.blob);\r\n                    }\r\n                });\r\n            });\r\n        }, 10);\r\n    };\r\n\r\n    var isPausedRecording = false;\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        isPausedRecording = true;\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        isPausedRecording = false;\r\n\r\n        if (isStopDrawing) {\r\n            this.record();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */\r\n    this.clearRecordedData = function() {\r\n        if (!isStopDrawing) {\r\n            this.stop(clearRecordedDataCB);\r\n        }\r\n        clearRecordedDataCB();\r\n    };\r\n\r\n    function clearRecordedDataCB() {\r\n        whammy.frames = [];\r\n        isStopDrawing = true;\r\n        isPausedRecording = false;\r\n    }\r\n\r\n    // for debugging\r\n    this.name = 'WhammyRecorder';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n\r\n    var video;\r\n    var lastTime;\r\n    var whammy;\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.WhammyRecorder = WhammyRecorder;\r\n}\n\r\n// https://github.com/antimatter15/whammy/blob/master/LICENSE\r\n// _________\r\n// Whammy.js\r\n\r\n// todo: Firefox now supports webp for webm containers!\r\n// their MediaRecorder implementation works well!\r\n// should we provide an option to record via Whammy.js or MediaRecorder API is a better solution?\r\n\r\n/**\r\n * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}\r\n * @summary A real time javascript webm encoder based on a canvas hack.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef Whammy\r\n * @class\r\n * @example\r\n * var recorder = new Whammy().Video(15);\r\n * recorder.add(context || canvas || dataURL);\r\n * var output = recorder.compile();\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */\r\n\r\nvar Whammy = (function() {\r\n    // a more abstract-ish API\r\n\r\n    function WhammyVideo(duration) {\r\n        this.frames = [];\r\n        this.duration = duration || 1;\r\n        this.quality = 0.8;\r\n    }\r\n\r\n    /**\r\n     * Pass Canvas or Context or image/webp(string) to {@link Whammy} encoder.\r\n     * @method\r\n     * @memberof Whammy\r\n     * @example\r\n     * recorder = new Whammy().Video(0.8, 100);\r\n     * recorder.add(canvas || context || 'image/webp');\r\n     * @param {string} frame - Canvas || Context || image/webp\r\n     * @param {number} duration - Stick a duration (in milliseconds)\r\n     */\r\n    WhammyVideo.prototype.add = function(frame, duration) {\r\n        if ('canvas' in frame) { //CanvasRenderingContext2D\r\n            frame = frame.canvas;\r\n        }\r\n\r\n        if ('toDataURL' in frame) {\r\n            frame = frame.toDataURL('image/webp', this.quality);\r\n        }\r\n\r\n        if (!(/^data:image\\/webp;base64,/ig).test(frame)) {\r\n            throw 'Input must be formatted properly as a base64 encoded DataURI of type image/webp';\r\n        }\r\n        this.frames.push({\r\n            image: frame,\r\n            duration: duration || this.duration\r\n        });\r\n    };\r\n\r\n    function processInWebWorker(_function) {\r\n        var blob = URL.createObjectURL(new Blob([_function.toString(),\r\n            'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\r\n        ], {\r\n            type: 'application/javascript'\r\n        }));\r\n\r\n        var worker = new Worker(blob);\r\n        URL.revokeObjectURL(blob);\r\n        return worker;\r\n    }\r\n\r\n    function whammyInWebWorker(frames) {\r\n        function ArrayToWebM(frames) {\r\n            var info = checkFrames(frames);\r\n            if (!info) {\r\n                return [];\r\n            }\r\n\r\n            var clusterMaxDuration = 30000;\r\n\r\n            var EBML = [{\r\n                'id': 0x1a45dfa3, // EBML\r\n                'data': [{\r\n                    'data': 1,\r\n                    'id': 0x4286 // EBMLVersion\r\n                }, {\r\n                    'data': 1,\r\n                    'id': 0x42f7 // EBMLReadVersion\r\n                }, {\r\n                    'data': 4,\r\n                    'id': 0x42f2 // EBMLMaxIDLength\r\n                }, {\r\n                    'data': 8,\r\n                    'id': 0x42f3 // EBMLMaxSizeLength\r\n                }, {\r\n                    'data': 'webm',\r\n                    'id': 0x4282 // DocType\r\n                }, {\r\n                    'data': 2,\r\n                    'id': 0x4287 // DocTypeVersion\r\n                }, {\r\n                    'data': 2,\r\n                    'id': 0x4285 // DocTypeReadVersion\r\n                }]\r\n            }, {\r\n                'id': 0x18538067, // Segment\r\n                'data': [{\r\n                    'id': 0x1549a966, // Info\r\n                    'data': [{\r\n                        'data': 1e6, //do things in millisecs (num of nanosecs for duration scale)\r\n                        'id': 0x2ad7b1 // TimecodeScale\r\n                    }, {\r\n                        'data': 'whammy',\r\n                        'id': 0x4d80 // MuxingApp\r\n                    }, {\r\n                        'data': 'whammy',\r\n                        'id': 0x5741 // WritingApp\r\n                    }, {\r\n                        'data': doubleToString(info.duration),\r\n                        'id': 0x4489 // Duration\r\n                    }]\r\n                }, {\r\n                    'id': 0x1654ae6b, // Tracks\r\n                    'data': [{\r\n                        'id': 0xae, // TrackEntry\r\n                        'data': [{\r\n                            'data': 1,\r\n                            'id': 0xd7 // TrackNumber\r\n                        }, {\r\n                            'data': 1,\r\n                            'id': 0x73c5 // TrackUID\r\n                        }, {\r\n                            'data': 0,\r\n                            'id': 0x9c // FlagLacing\r\n                        }, {\r\n                            'data': 'und',\r\n                            'id': 0x22b59c // Language\r\n                        }, {\r\n                            'data': 'V_VP8',\r\n                            'id': 0x86 // CodecID\r\n                        }, {\r\n                            'data': 'VP8',\r\n                            'id': 0x258688 // CodecName\r\n                        }, {\r\n                            'data': 1,\r\n                            'id': 0x83 // TrackType\r\n                        }, {\r\n                            'id': 0xe0, // Video\r\n                            'data': [{\r\n                                'data': info.width,\r\n                                'id': 0xb0 // PixelWidth\r\n                            }, {\r\n                                'data': info.height,\r\n                                'id': 0xba // PixelHeight\r\n                            }]\r\n                        }]\r\n                    }]\r\n                }]\r\n            }];\r\n\r\n            //Generate clusters (max duration)\r\n            var frameNumber = 0;\r\n            var clusterTimecode = 0;\r\n            while (frameNumber < frames.length) {\r\n\r\n                var clusterFrames = [];\r\n                var clusterDuration = 0;\r\n                do {\r\n                    clusterFrames.push(frames[frameNumber]);\r\n                    clusterDuration += frames[frameNumber].duration;\r\n                    frameNumber++;\r\n                } while (frameNumber < frames.length && clusterDuration < clusterMaxDuration);\r\n\r\n                var clusterCounter = 0;\r\n                var cluster = {\r\n                    'id': 0x1f43b675, // Cluster\r\n                    'data': getClusterData(clusterTimecode, clusterCounter, clusterFrames)\r\n                }; //Add cluster to segment\r\n                EBML[1].data.push(cluster);\r\n                clusterTimecode += clusterDuration;\r\n            }\r\n\r\n            return generateEBML(EBML);\r\n        }\r\n\r\n        function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {\r\n            return [{\r\n                'data': clusterTimecode,\r\n                'id': 0xe7 // Timecode\r\n            }].concat(clusterFrames.map(function(webp) {\r\n                var block = makeSimpleBlock({\r\n                    discardable: 0,\r\n                    frame: webp.data.slice(4),\r\n                    invisible: 0,\r\n                    keyframe: 1,\r\n                    lacing: 0,\r\n                    trackNum: 1,\r\n                    timecode: Math.round(clusterCounter)\r\n                });\r\n                clusterCounter += webp.duration;\r\n                return {\r\n                    data: block,\r\n                    id: 0xa3\r\n                };\r\n            }));\r\n        }\r\n\r\n        // sums the lengths of all the frames and gets the duration\r\n\r\n        function checkFrames(frames) {\r\n            if (!frames[0]) {\r\n                postMessage({\r\n                    error: 'Something went wrong. Maybe WebP format is not supported in the current browser.'\r\n                });\r\n                return;\r\n            }\r\n\r\n            var width = frames[0].width,\r\n                height = frames[0].height,\r\n                duration = frames[0].duration;\r\n\r\n            for (var i = 1; i < frames.length; i++) {\r\n                duration += frames[i].duration;\r\n            }\r\n            return {\r\n                duration: duration,\r\n                width: width,\r\n                height: height\r\n            };\r\n        }\r\n\r\n        function numToBuffer(num) {\r\n            var parts = [];\r\n            while (num > 0) {\r\n                parts.push(num & 0xff);\r\n                num = num >> 8;\r\n            }\r\n            return new Uint8Array(parts.reverse());\r\n        }\r\n\r\n        function strToBuffer(str) {\r\n            return new Uint8Array(str.split('').map(function(e) {\r\n                return e.charCodeAt(0);\r\n            }));\r\n        }\r\n\r\n        function bitsToBuffer(bits) {\r\n            var data = [];\r\n            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\r\n            bits = pad + bits;\r\n            for (var i = 0; i < bits.length; i += 8) {\r\n                data.push(parseInt(bits.substr(i, 8), 2));\r\n            }\r\n            return new Uint8Array(data);\r\n        }\r\n\r\n        function generateEBML(json) {\r\n            var ebml = [];\r\n            for (var i = 0; i < json.length; i++) {\r\n                var data = json[i].data;\r\n\r\n                if (typeof data === 'object') {\r\n                    data = generateEBML(data);\r\n                }\r\n\r\n                if (typeof data === 'number') {\r\n                    data = bitsToBuffer(data.toString(2));\r\n                }\r\n\r\n                if (typeof data === 'string') {\r\n                    data = strToBuffer(data);\r\n                }\r\n\r\n                var len = data.size || data.byteLength || data.length;\r\n                var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\r\n                var sizeToString = len.toString(2);\r\n                var padded = (new Array((zeroes * 7 + 7 + 1) - sizeToString.length)).join('0') + sizeToString;\r\n                var size = (new Array(zeroes)).join('0') + '1' + padded;\r\n\r\n                ebml.push(numToBuffer(json[i].id));\r\n                ebml.push(bitsToBuffer(size));\r\n                ebml.push(data);\r\n            }\r\n\r\n            return new Blob(ebml, {\r\n                type: 'video/webm'\r\n            });\r\n        }\r\n\r\n        function toBinStrOld(bits) {\r\n            var data = '';\r\n            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\r\n            bits = pad + bits;\r\n            for (var i = 0; i < bits.length; i += 8) {\r\n                data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));\r\n            }\r\n            return data;\r\n        }\r\n\r\n        function makeSimpleBlock(data) {\r\n            var flags = 0;\r\n\r\n            if (data.keyframe) {\r\n                flags |= 128;\r\n            }\r\n\r\n            if (data.invisible) {\r\n                flags |= 8;\r\n            }\r\n\r\n            if (data.lacing) {\r\n                flags |= (data.lacing << 1);\r\n            }\r\n\r\n            if (data.discardable) {\r\n                flags |= 1;\r\n            }\r\n\r\n            if (data.trackNum > 127) {\r\n                throw 'TrackNumber > 127 not supported';\r\n            }\r\n\r\n            var out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags].map(function(e) {\r\n                return String.fromCharCode(e);\r\n            }).join('') + data.frame;\r\n\r\n            return out;\r\n        }\r\n\r\n        function parseWebP(riff) {\r\n            var VP8 = riff.RIFF[0].WEBP[0];\r\n\r\n            var frameStart = VP8.indexOf('\\x9d\\x01\\x2a'); // A VP8 keyframe starts with the 0x9d012a header\r\n            for (var i = 0, c = []; i < 4; i++) {\r\n                c[i] = VP8.charCodeAt(frameStart + 3 + i);\r\n            }\r\n\r\n            var width, height, tmp;\r\n\r\n            //the code below is literally copied verbatim from the bitstream spec\r\n            tmp = (c[1] << 8) | c[0];\r\n            width = tmp & 0x3FFF;\r\n            tmp = (c[3] << 8) | c[2];\r\n            height = tmp & 0x3FFF;\r\n            return {\r\n                width: width,\r\n                height: height,\r\n                data: VP8,\r\n                riff: riff\r\n            };\r\n        }\r\n\r\n        function getStrLength(string, offset) {\r\n            return parseInt(string.substr(offset + 4, 4).split('').map(function(i) {\r\n                var unpadded = i.charCodeAt(0).toString(2);\r\n                return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;\r\n            }).join(''), 2);\r\n        }\r\n\r\n        function parseRIFF(string) {\r\n            var offset = 0;\r\n            var chunks = {};\r\n\r\n            while (offset < string.length) {\r\n                var id = string.substr(offset, 4);\r\n                var len = getStrLength(string, offset);\r\n                var data = string.substr(offset + 4 + 4, len);\r\n                offset += 4 + 4 + len;\r\n                chunks[id] = chunks[id] || [];\r\n\r\n                if (id === 'RIFF' || id === 'LIST') {\r\n                    chunks[id].push(parseRIFF(data));\r\n                } else {\r\n                    chunks[id].push(data);\r\n                }\r\n            }\r\n            return chunks;\r\n        }\r\n\r\n        function doubleToString(num) {\r\n            return [].slice.call(\r\n                new Uint8Array((new Float64Array([num])).buffer), 0).map(function(e) {\r\n                return String.fromCharCode(e);\r\n            }).reverse().join('');\r\n        }\r\n\r\n        var webm = new ArrayToWebM(frames.map(function(frame) {\r\n            var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));\r\n            webp.duration = frame.duration;\r\n            return webp;\r\n        }));\r\n\r\n        postMessage(webm);\r\n    }\r\n\r\n    /**\r\n     * Encodes frames in WebM container. It uses WebWorkinvoke to invoke 'ArrayToWebM' method.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof Whammy\r\n     * @example\r\n     * recorder = new Whammy().Video(0.8, 100);\r\n     * recorder.compile(function(blob) {\r\n     *    // blob.size - blob.type\r\n     * });\r\n     */\r\n    WhammyVideo.prototype.compile = function(callback) {\r\n        var webWorker = processInWebWorker(whammyInWebWorker);\r\n\r\n        webWorker.onmessage = function(event) {\r\n            if (event.data.error) {\r\n                console.error(event.data.error);\r\n                return;\r\n            }\r\n            callback(event.data);\r\n        };\r\n\r\n        webWorker.postMessage(this.frames);\r\n    };\r\n\r\n    return {\r\n        /**\r\n         * A more abstract-ish API.\r\n         * @method\r\n         * @memberof Whammy\r\n         * @example\r\n         * recorder = new Whammy().Video(0.8, 100);\r\n         * @param {?number} speed - 0.8\r\n         * @param {?number} quality - 100\r\n         */\r\n        Video: WhammyVideo\r\n    };\r\n})();\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.Whammy = Whammy;\r\n}\n\r\n// ______________ (indexed-db)\r\n// DiskStorage.js\r\n\r\n/**\r\n * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.\r\n * @summary Writing blobs into IndexedDB.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @example\r\n * DiskStorage.Store({\r\n *     audioBlob: yourAudioBlob,\r\n *     videoBlob: yourVideoBlob,\r\n *     gifBlob  : yourGifBlob\r\n * });\r\n * DiskStorage.Fetch(function(dataURL, type) {\r\n *     if(type === 'audioBlob') { }\r\n *     if(type === 'videoBlob') { }\r\n *     if(type === 'gifBlob')   { }\r\n * });\r\n * // DiskStorage.dataStoreName = 'recordRTC';\r\n * // DiskStorage.onError = function(error) { };\r\n * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\r\n * @property {function} Fetch - This method fetches stored blobs from IndexedDB.\r\n * @property {function} Store - This method stores blobs in IndexedDB.\r\n * @property {function} onError - This function is invoked for any known/unknown error.\r\n * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */\r\n\r\n\r\nvar DiskStorage = {\r\n    /**\r\n     * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.init();\r\n     */\r\n    init: function() {\r\n        var self = this;\r\n\r\n        if (typeof indexedDB === 'undefined' || typeof indexedDB.open === 'undefined') {\r\n            console.error('IndexedDB API are not available in this browser.');\r\n            return;\r\n        }\r\n\r\n        var dbVersion = 1;\r\n        var dbName = this.dbName || location.href.replace(/\\/|:|#|%|\\.|\\[|\\]/g, ''),\r\n            db;\r\n        var request = indexedDB.open(dbName, dbVersion);\r\n\r\n        function createObjectStore(dataBase) {\r\n            dataBase.createObjectStore(self.dataStoreName);\r\n        }\r\n\r\n        function putInDB() {\r\n            var transaction = db.transaction([self.dataStoreName], 'readwrite');\r\n\r\n            if (self.videoBlob) {\r\n                transaction.objectStore(self.dataStoreName).put(self.videoBlob, 'videoBlob');\r\n            }\r\n\r\n            if (self.gifBlob) {\r\n                transaction.objectStore(self.dataStoreName).put(self.gifBlob, 'gifBlob');\r\n            }\r\n\r\n            if (self.audioBlob) {\r\n                transaction.objectStore(self.dataStoreName).put(self.audioBlob, 'audioBlob');\r\n            }\r\n\r\n            function getFromStore(portionName) {\r\n                transaction.objectStore(self.dataStoreName).get(portionName).onsuccess = function(event) {\r\n                    if (self.callback) {\r\n                        self.callback(event.target.result, portionName);\r\n                    }\r\n                };\r\n            }\r\n\r\n            getFromStore('audioBlob');\r\n            getFromStore('videoBlob');\r\n            getFromStore('gifBlob');\r\n        }\r\n\r\n        request.onerror = self.onError;\r\n\r\n        request.onsuccess = function() {\r\n            db = request.result;\r\n            db.onerror = self.onError;\r\n\r\n            if (db.setVersion) {\r\n                if (db.version !== dbVersion) {\r\n                    var setVersion = db.setVersion(dbVersion);\r\n                    setVersion.onsuccess = function() {\r\n                        createObjectStore(db);\r\n                        putInDB();\r\n                    };\r\n                } else {\r\n                    putInDB();\r\n                }\r\n            } else {\r\n                putInDB();\r\n            }\r\n        };\r\n        request.onupgradeneeded = function(event) {\r\n            createObjectStore(event.target.result);\r\n        };\r\n    },\r\n    /**\r\n     * This method fetches stored blobs from IndexedDB.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.Fetch(function(dataURL, type) {\r\n     *     if(type === 'audioBlob') { }\r\n     *     if(type === 'videoBlob') { }\r\n     *     if(type === 'gifBlob')   { }\r\n     * });\r\n     */\r\n    Fetch: function(callback) {\r\n        this.callback = callback;\r\n        this.init();\r\n\r\n        return this;\r\n    },\r\n    /**\r\n     * This method stores blobs in IndexedDB.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.Store({\r\n     *     audioBlob: yourAudioBlob,\r\n     *     videoBlob: yourVideoBlob,\r\n     *     gifBlob  : yourGifBlob\r\n     * });\r\n     */\r\n    Store: function(config) {\r\n        this.audioBlob = config.audioBlob;\r\n        this.videoBlob = config.videoBlob;\r\n        this.gifBlob = config.gifBlob;\r\n\r\n        this.init();\r\n\r\n        return this;\r\n    },\r\n    /**\r\n     * This function is invoked for any known/unknown error.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.onError = function(error){\r\n     *     alerot( JSON.stringify(error) );\r\n     * };\r\n     */\r\n    onError: function(error) {\r\n        console.error(JSON.stringify(error, null, '\\t'));\r\n    },\r\n\r\n    /**\r\n     * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.dataStoreName = 'recordRTC';\r\n     */\r\n    dataStoreName: 'recordRTC',\r\n    dbName: null\r\n};\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.DiskStorage = DiskStorage;\r\n}\n\r\n// ______________\r\n// GifRecorder.js\r\n\r\n/**\r\n * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef GifRecorder\r\n * @class\r\n * @example\r\n * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     img.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.\r\n * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}\r\n */\r\n\r\nfunction GifRecorder(mediaStream, config) {\r\n    if (typeof GIFEncoder === 'undefined') {\r\n        var script = document.createElement('script');\r\n        script.src = 'https://www.webrtc-experiment.com/gif-recorder.js';\r\n        (document.body || document.documentElement).appendChild(script);\r\n    }\r\n\r\n    config = config || {};\r\n\r\n    var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;\r\n\r\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        if (typeof GIFEncoder === 'undefined') {\r\n            setTimeout(self.record, 1000);\r\n            return;\r\n        }\r\n\r\n        if (!isLoadedMetaData) {\r\n            setTimeout(self.record, 1000);\r\n            return;\r\n        }\r\n\r\n        if (!isHTMLObject) {\r\n            if (!config.width) {\r\n                config.width = video.offsetWidth || 320;\r\n            }\r\n\r\n            if (!config.height) {\r\n                config.height = video.offsetHeight || 240;\r\n            }\r\n\r\n            if (!config.video) {\r\n                config.video = {\r\n                    width: config.width,\r\n                    height: config.height\r\n                };\r\n            }\r\n\r\n            if (!config.canvas) {\r\n                config.canvas = {\r\n                    width: config.width,\r\n                    height: config.height\r\n                };\r\n            }\r\n\r\n            canvas.width = config.canvas.width || 320;\r\n            canvas.height = config.canvas.height || 240;\r\n\r\n            video.width = config.video.width || 320;\r\n            video.height = config.video.height || 240;\r\n        }\r\n\r\n        // external library to record as GIF images\r\n        gifEncoder = new GIFEncoder();\r\n\r\n        // void setRepeat(int iter) \r\n        // Sets the number of times the set of GIF frames should be played. \r\n        // Default is 1; 0 means play indefinitely.\r\n        gifEncoder.setRepeat(0);\r\n\r\n        // void setFrameRate(Number fps) \r\n        // Sets frame rate in frames per second. \r\n        // Equivalent to setDelay(1000/fps).\r\n        // Using \"setDelay\" instead of \"setFrameRate\"\r\n        gifEncoder.setDelay(config.frameRate || 200);\r\n\r\n        // void setQuality(int quality) \r\n        // Sets quality of color quantization (conversion of images to the \r\n        // maximum 256 colors allowed by the GIF specification). \r\n        // Lower values (minimum = 1) produce better colors, \r\n        // but slow processing significantly. 10 is the default, \r\n        // and produces good color mapping at reasonable speeds. \r\n        // Values greater than 20 do not yield significant improvements in speed.\r\n        gifEncoder.setQuality(config.quality || 10);\r\n\r\n        // Boolean start() \r\n        // This writes the GIF Header and returns false if it fails.\r\n        gifEncoder.start();\r\n\r\n        if (typeof config.onGifRecordingStarted === 'function') {\r\n            config.onGifRecordingStarted();\r\n        }\r\n\r\n        startTime = Date.now();\r\n\r\n        function drawVideoFrame(time) {\r\n            if (self.clearedRecordedData === true) {\r\n                return;\r\n            }\r\n\r\n            if (isPausedRecording) {\r\n                return setTimeout(function() {\r\n                    drawVideoFrame(time);\r\n                }, 100);\r\n            }\r\n\r\n            lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\r\n\r\n            if (typeof lastFrameTime === undefined) {\r\n                lastFrameTime = time;\r\n            }\r\n\r\n            // ~10 fps\r\n            if (time - lastFrameTime < 90) {\r\n                return;\r\n            }\r\n\r\n            if (!isHTMLObject && video.paused) {\r\n                // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\r\n                // Tweak for Android Chrome\r\n                video.play();\r\n            }\r\n\r\n            if (!isHTMLObject) {\r\n                context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n            }\r\n\r\n            if (config.onGifPreview) {\r\n                config.onGifPreview(canvas.toDataURL('image/png'));\r\n            }\r\n\r\n            gifEncoder.addFrame(context);\r\n            lastFrameTime = time;\r\n        }\r\n\r\n        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\r\n\r\n        if (config.initCallback) {\r\n            config.initCallback();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     img.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        callback = callback || function() {};\r\n\r\n        if (lastAnimationFrame) {\r\n            cancelAnimationFrame(lastAnimationFrame);\r\n        }\r\n\r\n        endTime = Date.now();\r\n\r\n        /**\r\n         * @property {Blob} blob - The recorded blob object.\r\n         * @memberof GifRecorder\r\n         * @example\r\n         * recorder.stop(function(){\r\n         *     var blob = recorder.blob;\r\n         * });\r\n         */\r\n        this.blob = new Blob([new Uint8Array(gifEncoder.stream().bin)], {\r\n            type: 'image/gif'\r\n        });\r\n\r\n        callback(this.blob);\r\n\r\n        // bug: find a way to clear old recorded blobs\r\n        gifEncoder.stream().bin = [];\r\n    };\r\n\r\n    var isPausedRecording = false;\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        isPausedRecording = true;\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        isPausedRecording = false;\r\n    };\r\n\r\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */\r\n    this.clearRecordedData = function() {\r\n        self.clearedRecordedData = true;\r\n        clearRecordedDataCB();\r\n    };\r\n\r\n    function clearRecordedDataCB() {\r\n        if (gifEncoder) {\r\n            gifEncoder.stream().bin = [];\r\n        }\r\n    }\r\n\r\n    // for debugging\r\n    this.name = 'GifRecorder';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n\r\n    if (isHTMLObject) {\r\n        if (mediaStream instanceof CanvasRenderingContext2D) {\r\n            context = mediaStream;\r\n            canvas = context.canvas;\r\n        } else if (mediaStream instanceof HTMLCanvasElement) {\r\n            context = mediaStream.getContext('2d');\r\n            canvas = mediaStream;\r\n        }\r\n    }\r\n\r\n    var isLoadedMetaData = true;\r\n\r\n    if (!isHTMLObject) {\r\n        var video = document.createElement('video');\r\n        video.muted = true;\r\n        video.autoplay = true;\r\n        video.playsInline = true;\r\n\r\n        isLoadedMetaData = false;\r\n        video.onloadedmetadata = function() {\r\n            isLoadedMetaData = true;\r\n        };\r\n\r\n        setSrcObject(mediaStream, video);\r\n\r\n        video.play();\r\n    }\r\n\r\n    var lastAnimationFrame = null;\r\n    var startTime, endTime, lastFrameTime;\r\n\r\n    var gifEncoder;\r\n\r\n    var self = this;\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.GifRecorder = GifRecorder;\r\n}\n\r\n// Last time updated: 2019-06-21 4:09:42 AM UTC\r\n\r\n// ________________________\r\n// MultiStreamsMixer v1.2.2\r\n\r\n// Open-Sourced: https://github.com/muaz-khan/MultiStreamsMixer\r\n\r\n// --------------------------------------------------\r\n// Muaz Khan     - www.MuazKhan.com\r\n// MIT License   - www.WebRTC-Experiment.com/licence\r\n// --------------------------------------------------\r\n\r\nfunction MultiStreamsMixer(arrayOfMediaStreams, elementClass) {\r\n\r\n    var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\r\n\r\n    (function(that) {\r\n        if (typeof RecordRTC !== 'undefined') {\r\n            return;\r\n        }\r\n\r\n        if (!that) {\r\n            return;\r\n        }\r\n\r\n        if (typeof window !== 'undefined') {\r\n            return;\r\n        }\r\n\r\n        if (typeof global === 'undefined') {\r\n            return;\r\n        }\r\n\r\n        global.navigator = {\r\n            userAgent: browserFakeUserAgent,\r\n            getUserMedia: function() {}\r\n        };\r\n\r\n        if (!global.console) {\r\n            global.console = {};\r\n        }\r\n\r\n        if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {\r\n            global.console.error = global.console.log = global.console.log || function() {\r\n                console.log(arguments);\r\n            };\r\n        }\r\n\r\n        if (typeof document === 'undefined') {\r\n            /*global document:true */\r\n            that.document = {\r\n                documentElement: {\r\n                    appendChild: function() {\r\n                        return '';\r\n                    }\r\n                }\r\n            };\r\n\r\n            document.createElement = document.captureStream = document.mozCaptureStream = function() {\r\n                var obj = {\r\n                    getContext: function() {\r\n                        return obj;\r\n                    },\r\n                    play: function() {},\r\n                    pause: function() {},\r\n                    drawImage: function() {},\r\n                    toDataURL: function() {\r\n                        return '';\r\n                    },\r\n                    style: {}\r\n                };\r\n                return obj;\r\n            };\r\n\r\n            that.HTMLVideoElement = function() {};\r\n        }\r\n\r\n        if (typeof location === 'undefined') {\r\n            /*global location:true */\r\n            that.location = {\r\n                protocol: 'file:',\r\n                href: '',\r\n                hash: ''\r\n            };\r\n        }\r\n\r\n        if (typeof screen === 'undefined') {\r\n            /*global screen:true */\r\n            that.screen = {\r\n                width: 0,\r\n                height: 0\r\n            };\r\n        }\r\n\r\n        if (typeof URL === 'undefined') {\r\n            /*global screen:true */\r\n            that.URL = {\r\n                createObjectURL: function() {\r\n                    return '';\r\n                },\r\n                revokeObjectURL: function() {\r\n                    return '';\r\n                }\r\n            };\r\n        }\r\n\r\n        /*global window:true */\r\n        that.window = global;\r\n    })(typeof global !== 'undefined' ? global : null);\r\n\r\n    // requires: chrome://flags/#enable-experimental-web-platform-features\r\n\r\n    elementClass = elementClass || 'multi-streams-mixer';\r\n\r\n    var videos = [];\r\n    var isStopDrawingFrames = false;\r\n\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n    canvas.style.opacity = 0;\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.zIndex = -1;\r\n    canvas.style.top = '-1000em';\r\n    canvas.style.left = '-1000em';\r\n    canvas.className = elementClass;\r\n    (document.body || document.documentElement).appendChild(canvas);\r\n\r\n    this.disableLogs = false;\r\n    this.frameInterval = 10;\r\n\r\n    this.width = 360;\r\n    this.height = 240;\r\n\r\n    // use gain node to prevent echo\r\n    this.useGainNode = true;\r\n\r\n    var self = this;\r\n\r\n    // _____________________________\r\n    // Cross-Browser-Declarations.js\r\n\r\n    // WebAudio API representer\r\n    var AudioContext = window.AudioContext;\r\n\r\n    if (typeof AudioContext === 'undefined') {\r\n        if (typeof webkitAudioContext !== 'undefined') {\r\n            /*global AudioContext:true */\r\n            AudioContext = webkitAudioContext;\r\n        }\r\n\r\n        if (typeof mozAudioContext !== 'undefined') {\r\n            /*global AudioContext:true */\r\n            AudioContext = mozAudioContext;\r\n        }\r\n    }\r\n\r\n    /*jshint -W079 */\r\n    var URL = window.URL;\r\n\r\n    if (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {\r\n        /*global URL:true */\r\n        URL = webkitURL;\r\n    }\r\n\r\n    if (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?\r\n        if (typeof navigator.webkitGetUserMedia !== 'undefined') {\r\n            navigator.getUserMedia = navigator.webkitGetUserMedia;\r\n        }\r\n\r\n        if (typeof navigator.mozGetUserMedia !== 'undefined') {\r\n            navigator.getUserMedia = navigator.mozGetUserMedia;\r\n        }\r\n    }\r\n\r\n    var MediaStream = window.MediaStream;\r\n\r\n    if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\r\n        MediaStream = webkitMediaStream;\r\n    }\r\n\r\n    /*global MediaStream:true */\r\n    if (typeof MediaStream !== 'undefined') {\r\n        // override \"stop\" method for all browsers\r\n        if (typeof MediaStream.prototype.stop === 'undefined') {\r\n            MediaStream.prototype.stop = function() {\r\n                this.getTracks().forEach(function(track) {\r\n                    track.stop();\r\n                });\r\n            };\r\n        }\r\n    }\r\n\r\n    var Storage = {};\r\n\r\n    if (typeof AudioContext !== 'undefined') {\r\n        Storage.AudioContext = AudioContext;\r\n    } else if (typeof webkitAudioContext !== 'undefined') {\r\n        Storage.AudioContext = webkitAudioContext;\r\n    }\r\n\r\n    function setSrcObject(stream, element) {\r\n        if ('srcObject' in element) {\r\n            element.srcObject = stream;\r\n        } else if ('mozSrcObject' in element) {\r\n            element.mozSrcObject = stream;\r\n        } else {\r\n            element.srcObject = stream;\r\n        }\r\n    }\r\n\r\n    this.startDrawingFrames = function() {\r\n        drawVideosToCanvas();\r\n    };\r\n\r\n    function drawVideosToCanvas() {\r\n        if (isStopDrawingFrames) {\r\n            return;\r\n        }\r\n\r\n        var videosLength = videos.length;\r\n\r\n        var fullcanvas = false;\r\n        var remaining = [];\r\n        videos.forEach(function(video) {\r\n            if (!video.stream) {\r\n                video.stream = {};\r\n            }\r\n\r\n            if (video.stream.fullcanvas) {\r\n                fullcanvas = video;\r\n            } else {\r\n                // todo: video.stream.active or video.stream.live to fix blank frames issues?\r\n                remaining.push(video);\r\n            }\r\n        });\r\n\r\n        if (fullcanvas) {\r\n            canvas.width = fullcanvas.stream.width;\r\n            canvas.height = fullcanvas.stream.height;\r\n        } else if (remaining.length) {\r\n            canvas.width = videosLength > 1 ? remaining[0].width * 2 : remaining[0].width;\r\n\r\n            var height = 1;\r\n            if (videosLength === 3 || videosLength === 4) {\r\n                height = 2;\r\n            }\r\n            if (videosLength === 5 || videosLength === 6) {\r\n                height = 3;\r\n            }\r\n            if (videosLength === 7 || videosLength === 8) {\r\n                height = 4;\r\n            }\r\n            if (videosLength === 9 || videosLength === 10) {\r\n                height = 5;\r\n            }\r\n            canvas.height = remaining[0].height * height;\r\n        } else {\r\n            canvas.width = self.width || 360;\r\n            canvas.height = self.height || 240;\r\n        }\r\n\r\n        if (fullcanvas && fullcanvas instanceof HTMLVideoElement) {\r\n            drawImage(fullcanvas);\r\n        }\r\n\r\n        remaining.forEach(function(video, idx) {\r\n            drawImage(video, idx);\r\n        });\r\n\r\n        setTimeout(drawVideosToCanvas, self.frameInterval);\r\n    }\r\n\r\n    function drawImage(video, idx) {\r\n        if (isStopDrawingFrames) {\r\n            return;\r\n        }\r\n\r\n        var x = 0;\r\n        var y = 0;\r\n        var width = video.width;\r\n        var height = video.height;\r\n\r\n        if (idx === 1) {\r\n            x = video.width;\r\n        }\r\n\r\n        if (idx === 2) {\r\n            y = video.height;\r\n        }\r\n\r\n        if (idx === 3) {\r\n            x = video.width;\r\n            y = video.height;\r\n        }\r\n\r\n        if (idx === 4) {\r\n            y = video.height * 2;\r\n        }\r\n\r\n        if (idx === 5) {\r\n            x = video.width;\r\n            y = video.height * 2;\r\n        }\r\n\r\n        if (idx === 6) {\r\n            y = video.height * 3;\r\n        }\r\n\r\n        if (idx === 7) {\r\n            x = video.width;\r\n            y = video.height * 3;\r\n        }\r\n\r\n        if (typeof video.stream.left !== 'undefined') {\r\n            x = video.stream.left;\r\n        }\r\n\r\n        if (typeof video.stream.top !== 'undefined') {\r\n            y = video.stream.top;\r\n        }\r\n\r\n        if (typeof video.stream.width !== 'undefined') {\r\n            width = video.stream.width;\r\n        }\r\n\r\n        if (typeof video.stream.height !== 'undefined') {\r\n            height = video.stream.height;\r\n        }\r\n\r\n        context.drawImage(video, x, y, width, height);\r\n\r\n        if (typeof video.stream.onRender === 'function') {\r\n            video.stream.onRender(context, x, y, width, height, idx);\r\n        }\r\n    }\r\n\r\n    function getMixedStream() {\r\n        isStopDrawingFrames = false;\r\n        var mixedVideoStream = getMixedVideoStream();\r\n\r\n        var mixedAudioStream = getMixedAudioStream();\r\n        if (mixedAudioStream) {\r\n            mixedAudioStream.getTracks().filter(function(t) {\r\n                return t.kind === 'audio';\r\n            }).forEach(function(track) {\r\n                mixedVideoStream.addTrack(track);\r\n            });\r\n        }\r\n\r\n        var fullcanvas;\r\n        arrayOfMediaStreams.forEach(function(stream) {\r\n            if (stream.fullcanvas) {\r\n                fullcanvas = true;\r\n            }\r\n        });\r\n\r\n        // mixedVideoStream.prototype.appendStreams = appendStreams;\r\n        // mixedVideoStream.prototype.resetVideoStreams = resetVideoStreams;\r\n        // mixedVideoStream.prototype.clearRecordedData = clearRecordedData;\r\n\r\n        return mixedVideoStream;\r\n    }\r\n\r\n    function getMixedVideoStream() {\r\n        resetVideoStreams();\r\n\r\n        var capturedStream;\r\n\r\n        if ('captureStream' in canvas) {\r\n            capturedStream = canvas.captureStream();\r\n        } else if ('mozCaptureStream' in canvas) {\r\n            capturedStream = canvas.mozCaptureStream();\r\n        } else if (!self.disableLogs) {\r\n            console.error('Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features');\r\n        }\r\n\r\n        var videoStream = new MediaStream();\r\n\r\n        capturedStream.getTracks().filter(function(t) {\r\n            return t.kind === 'video';\r\n        }).forEach(function(track) {\r\n            videoStream.addTrack(track);\r\n        });\r\n\r\n        canvas.stream = videoStream;\r\n\r\n        return videoStream;\r\n    }\r\n\r\n    function getMixedAudioStream() {\r\n        // via: @pehrsons\r\n        if (!Storage.AudioContextConstructor) {\r\n            Storage.AudioContextConstructor = new Storage.AudioContext();\r\n        }\r\n\r\n        self.audioContext = Storage.AudioContextConstructor;\r\n\r\n        self.audioSources = [];\r\n\r\n        if (self.useGainNode === true) {\r\n            self.gainNode = self.audioContext.createGain();\r\n            self.gainNode.connect(self.audioContext.destination);\r\n            self.gainNode.gain.value = 0; // don't hear self\r\n        }\r\n\r\n        var audioTracksLength = 0;\r\n        arrayOfMediaStreams.forEach(function(stream) {\r\n            if (!stream.getTracks().filter(function(t) {\r\n                    return t.kind === 'audio';\r\n                }).length) {\r\n                return;\r\n            }\r\n\r\n            audioTracksLength++;\r\n\r\n            var audioSource = self.audioContext.createMediaStreamSource(stream);\r\n\r\n            if (self.useGainNode === true) {\r\n                audioSource.connect(self.gainNode);\r\n            }\r\n\r\n            self.audioSources.push(audioSource);\r\n        });\r\n\r\n        if (!audioTracksLength) {\r\n            // because \"self.audioContext\" is not initialized\r\n            // that's why we've to ignore rest of the code\r\n            return;\r\n        }\r\n\r\n        self.audioDestination = self.audioContext.createMediaStreamDestination();\r\n        self.audioSources.forEach(function(audioSource) {\r\n            audioSource.connect(self.audioDestination);\r\n        });\r\n        return self.audioDestination.stream;\r\n    }\r\n\r\n    function getVideo(stream) {\r\n        var video = document.createElement('video');\r\n\r\n        setSrcObject(stream, video);\r\n\r\n        video.className = elementClass;\r\n\r\n        video.muted = true;\r\n        video.volume = 0;\r\n\r\n        video.width = stream.width || self.width || 360;\r\n        video.height = stream.height || self.height || 240;\r\n\r\n        video.play();\r\n\r\n        return video;\r\n    }\r\n\r\n    this.appendStreams = function(streams) {\r\n        if (!streams) {\r\n            throw 'First parameter is required.';\r\n        }\r\n\r\n        if (!(streams instanceof Array)) {\r\n            streams = [streams];\r\n        }\r\n\r\n        streams.forEach(function(stream) {\r\n            var newStream = new MediaStream();\r\n\r\n            if (stream.getTracks().filter(function(t) {\r\n                    return t.kind === 'video';\r\n                }).length) {\r\n                var video = getVideo(stream);\r\n                video.stream = stream;\r\n                videos.push(video);\r\n\r\n                newStream.addTrack(stream.getTracks().filter(function(t) {\r\n                    return t.kind === 'video';\r\n                })[0]);\r\n            }\r\n\r\n            if (stream.getTracks().filter(function(t) {\r\n                    return t.kind === 'audio';\r\n                }).length) {\r\n                var audioSource = self.audioContext.createMediaStreamSource(stream);\r\n                self.audioDestination = self.audioContext.createMediaStreamDestination();\r\n                audioSource.connect(self.audioDestination);\r\n\r\n                newStream.addTrack(self.audioDestination.stream.getTracks().filter(function(t) {\r\n                    return t.kind === 'audio';\r\n                })[0]);\r\n            }\r\n\r\n            arrayOfMediaStreams.push(newStream);\r\n        });\r\n    };\r\n\r\n    this.releaseStreams = function() {\r\n        videos = [];\r\n        isStopDrawingFrames = true;\r\n\r\n        if (self.gainNode) {\r\n            self.gainNode.disconnect();\r\n            self.gainNode = null;\r\n        }\r\n\r\n        if (self.audioSources.length) {\r\n            self.audioSources.forEach(function(source) {\r\n                source.disconnect();\r\n            });\r\n            self.audioSources = [];\r\n        }\r\n\r\n        if (self.audioDestination) {\r\n            self.audioDestination.disconnect();\r\n            self.audioDestination = null;\r\n        }\r\n\r\n        if (self.audioContext) {\r\n            self.audioContext.close();\r\n        }\r\n\r\n        self.audioContext = null;\r\n\r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        if (canvas.stream) {\r\n            canvas.stream.stop();\r\n            canvas.stream = null;\r\n        }\r\n    };\r\n\r\n    this.resetVideoStreams = function(streams) {\r\n        if (streams && !(streams instanceof Array)) {\r\n            streams = [streams];\r\n        }\r\n\r\n        resetVideoStreams(streams);\r\n    };\r\n\r\n    function resetVideoStreams(streams) {\r\n        videos = [];\r\n        streams = streams || arrayOfMediaStreams;\r\n\r\n        // via: @adrian-ber\r\n        streams.forEach(function(stream) {\r\n            if (!stream.getTracks().filter(function(t) {\r\n                    return t.kind === 'video';\r\n                }).length) {\r\n                return;\r\n            }\r\n\r\n            var video = getVideo(stream);\r\n            video.stream = stream;\r\n            videos.push(video);\r\n        });\r\n    }\r\n\r\n    // for debugging\r\n    this.name = 'MultiStreamsMixer';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n\r\n    this.getMixedStream = getMixedStream;\r\n\r\n}\r\n\r\nif (typeof RecordRTC === 'undefined') {\r\n    if (typeof module !== 'undefined' /* && !!module.exports*/ ) {\r\n        module.exports = MultiStreamsMixer;\r\n    }\r\n\r\n    if (typeof define === 'function' && define.amd) {\r\n        define('MultiStreamsMixer', [], function() {\r\n            return MultiStreamsMixer;\r\n        });\r\n    }\r\n}\n\r\n// ______________________\r\n// MultiStreamRecorder.js\r\n\r\n/*\r\n * Video conference recording, using captureStream API along with WebAudio and Canvas2D API.\r\n */\r\n\r\n/**\r\n * MultiStreamRecorder can record multiple videos in single container.\r\n * @summary Multi-videos recorder.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef MultiStreamRecorder\r\n * @class\r\n * @example\r\n * var options = {\r\n *     mimeType: 'video/webm'\r\n * }\r\n * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n *\r\n *     // or\r\n *     var blob = recorder.blob;\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStreams} mediaStreams - Array of MediaStreams.\r\n * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: \"video/webm\"}\r\n */\r\n\r\nfunction MultiStreamRecorder(arrayOfMediaStreams, options) {\r\n    arrayOfMediaStreams = arrayOfMediaStreams || [];\r\n    var self = this;\r\n\r\n    var mixer;\r\n    var mediaRecorder;\r\n\r\n    options = options || {\r\n        elementClass: 'multi-streams-mixer',\r\n        mimeType: 'video/webm',\r\n        video: {\r\n            width: 360,\r\n            height: 240\r\n        }\r\n    };\r\n\r\n    if (!options.frameInterval) {\r\n        options.frameInterval = 10;\r\n    }\r\n\r\n    if (!options.video) {\r\n        options.video = {};\r\n    }\r\n\r\n    if (!options.video.width) {\r\n        options.video.width = 360;\r\n    }\r\n\r\n    if (!options.video.height) {\r\n        options.video.height = 240;\r\n    }\r\n\r\n    /**\r\n     * This method records all MediaStreams.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        // github/muaz-khan/MultiStreamsMixer\r\n        mixer = new MultiStreamsMixer(arrayOfMediaStreams, options.elementClass || 'multi-streams-mixer');\r\n\r\n        if (getAllVideoTracks().length) {\r\n            mixer.frameInterval = options.frameInterval || 10;\r\n            mixer.width = options.video.width || 360;\r\n            mixer.height = options.video.height || 240;\r\n            mixer.startDrawingFrames();\r\n        }\r\n\r\n        if (options.previewStream && typeof options.previewStream === 'function') {\r\n            options.previewStream(mixer.getMixedStream());\r\n        }\r\n\r\n        // record using MediaRecorder API\r\n        mediaRecorder = new MediaStreamRecorder(mixer.getMixedStream(), options);\r\n        mediaRecorder.record();\r\n    };\r\n\r\n    function getAllVideoTracks() {\r\n        var tracks = [];\r\n        arrayOfMediaStreams.forEach(function(stream) {\r\n            getTracks(stream, 'video').forEach(function(track) {\r\n                tracks.push(track);\r\n            });\r\n        });\r\n        return tracks;\r\n    }\r\n\r\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        mediaRecorder.stop(function(blob) {\r\n            self.blob = blob;\r\n\r\n            callback(blob);\r\n\r\n            self.clearRecordedData();\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        if (mediaRecorder) {\r\n            mediaRecorder.pause();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        if (mediaRecorder) {\r\n            mediaRecorder.resume();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */\r\n    this.clearRecordedData = function() {\r\n        if (mediaRecorder) {\r\n            mediaRecorder.clearRecordedData();\r\n            mediaRecorder = null;\r\n        }\r\n\r\n        if (mixer) {\r\n            mixer.releaseStreams();\r\n            mixer = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Add extra media-streams to existing recordings.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\r\n     * @example\r\n     * recorder.addStreams([newAudioStream, newVideoStream]);\r\n     */\r\n    this.addStreams = function(streams) {\r\n        if (!streams) {\r\n            throw 'First parameter is required.';\r\n        }\r\n\r\n        if (!(streams instanceof Array)) {\r\n            streams = [streams];\r\n        }\r\n\r\n        arrayOfMediaStreams.concat(streams);\r\n\r\n        if (!mediaRecorder || !mixer) {\r\n            return;\r\n        }\r\n\r\n        mixer.appendStreams(streams);\r\n\r\n        if (options.previewStream && typeof options.previewStream === 'function') {\r\n            options.previewStream(mixer.getMixedStream());\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Reset videos during live recording. Replace old videos e.g. replace cameras with full-screen.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\r\n     * @example\r\n     * recorder.resetVideoStreams([newVideo1, newVideo2]);\r\n     */\r\n    this.resetVideoStreams = function(streams) {\r\n        if (!mixer) {\r\n            return;\r\n        }\r\n\r\n        if (streams && !(streams instanceof Array)) {\r\n            streams = [streams];\r\n        }\r\n\r\n        mixer.resetVideoStreams(streams);\r\n    };\r\n\r\n    /**\r\n     * Returns MultiStreamsMixer\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * let mixer = recorder.getMixer();\r\n     * mixer.appendStreams([newStream]);\r\n     */\r\n    this.getMixer = function() {\r\n        return mixer;\r\n    };\r\n\r\n    // for debugging\r\n    this.name = 'MultiStreamRecorder';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.MultiStreamRecorder = MultiStreamRecorder;\r\n}\n\r\n// _____________________\r\n// RecordRTC.promises.js\r\n\r\n/**\r\n * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}\r\n * @summary Promises for {@link RecordRTC}\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef RecordRTCPromisesHandler\r\n * @class\r\n * @example\r\n * var recorder = new RecordRTCPromisesHandler(mediaStream, options);\r\n * recorder.startRecording()\r\n *         .then(successCB)\r\n *         .catch(errorCB);\r\n * // Note: You can access all RecordRTC API using \"recorder.recordRTC\" e.g. \r\n * recorder.recordRTC.onStateChanged = function(state) {};\r\n * recorder.recordRTC.setRecordingDuration(5000);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\r\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\r\n * @throws Will throw an error if \"new\" keyword is not used to initiate \"RecordRTCPromisesHandler\". Also throws error if first argument \"MediaStream\" is missing.\r\n * @requires {@link RecordRTC}\r\n */\r\n\r\nfunction RecordRTCPromisesHandler(mediaStream, options) {\r\n    if (!this) {\r\n        throw 'Use \"new RecordRTCPromisesHandler()\"';\r\n    }\r\n\r\n    if (typeof mediaStream === 'undefined') {\r\n        throw 'First argument \"MediaStream\" is required.';\r\n    }\r\n\r\n    var self = this;\r\n\r\n    /**\r\n     * @property {Blob} blob - Access/reach the native {@link RecordRTC} object.\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * let internal = recorder.recordRTC.getInternalRecorder();\r\n     * alert(internal instanceof MediaStreamRecorder);\r\n     * recorder.recordRTC.onStateChanged = function(state) {};\r\n     */\r\n    self.recordRTC = new RecordRTC(mediaStream, options);\r\n\r\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.startRecording()\r\n     *         .then(successCB)\r\n     *         .catch(errorCB);\r\n     */\r\n    this.startRecording = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                self.recordRTC.startRecording();\r\n                resolve();\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method stops the recording.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.stopRecording().then(function() {\r\n     *     var blob = recorder.getBlob();\r\n     * }).catch(errorCB);\r\n     */\r\n    this.stopRecording = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                self.recordRTC.stopRecording(function(url) {\r\n                    self.blob = self.recordRTC.getBlob();\r\n\r\n                    if (!self.blob || !self.blob.size) {\r\n                        reject('Empty blob.', self.blob);\r\n                        return;\r\n                    }\r\n\r\n                    resolve(url);\r\n                });\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.pauseRecording()\r\n     *         .then(successCB)\r\n     *         .catch(errorCB);\r\n     */\r\n    this.pauseRecording = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                self.recordRTC.pauseRecording();\r\n                resolve();\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.resumeRecording()\r\n     *         .then(successCB)\r\n     *         .catch(errorCB);\r\n     */\r\n    this.resumeRecording = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                self.recordRTC.resumeRecording();\r\n                resolve();\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method returns data-url for the recorded blob.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.stopRecording().then(function() {\r\n     *     recorder.getDataURL().then(function(dataURL) {\r\n     *         window.open(dataURL);\r\n     *     }).catch(errorCB);;\r\n     * }).catch(errorCB);\r\n     */\r\n    this.getDataURL = function(callback) {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                self.recordRTC.getDataURL(function(dataURL) {\r\n                    resolve(dataURL);\r\n                });\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method returns the recorded blob.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.stopRecording().then(function() {\r\n     *     recorder.getBlob().then(function(blob) {})\r\n     * }).catch(errorCB);\r\n     */\r\n    this.getBlob = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                resolve(self.recordRTC.getBlob());\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method returns the internal recording object.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * let internalRecorder = await recorder.getInternalRecorder();\r\n     * if(internalRecorder instanceof MultiStreamRecorder) {\r\n     *     internalRecorder.addStreams([newAudioStream]);\r\n     *     internalRecorder.resetVideoStreams([screenStream]);\r\n     * }\r\n     * @returns {Object} \r\n     */\r\n    this.getInternalRecorder = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                resolve(self.recordRTC.getInternalRecorder());\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method resets the recorder. So that you can reuse single recorder instance many times.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * await recorder.reset();\r\n     * recorder.startRecording(); // record again\r\n     */\r\n    this.reset = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                resolve(self.recordRTC.reset());\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Destroy RecordRTC instance. Clear all recorders and objects.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.destroy().then(successCB).catch(errorCB);\r\n     */\r\n    this.destroy = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                resolve(self.recordRTC.destroy());\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Get recorder's readonly state.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * let state = await recorder.getState();\r\n     * // or\r\n     * recorder.getState().then(state => { console.log(state); })\r\n     * @returns {String} Returns recording state.\r\n     */\r\n    this.getState = function() {\r\n        return new Promise(function(resolve, reject) {\r\n            try {\r\n                resolve(self.recordRTC.getState());\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * await recorder.stopRecording();\r\n     * let blob = recorder.getBlob(); // or \"recorder.recordRTC.blob\"\r\n     * invokeSaveAsDialog(blob);\r\n     */\r\n    this.blob = null;\r\n\r\n    /**\r\n     * RecordRTC version number\r\n     * @property {String} version - Release version number.\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @static\r\n     * @readonly\r\n     * @example\r\n     * alert(recorder.version);\r\n     */\r\n    this.version = '5.5.9';\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler;\r\n}\n\r\n// ______________________\r\n// WebAssemblyRecorder.js\r\n\r\n/**\r\n * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.\r\n * @summary Video recording feature in Chrome, Firefox and maybe Edge.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef WebAssemblyRecorder\r\n * @class\r\n * @example\r\n * var recorder = new WebAssemblyRecorder(mediaStream);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024}\r\n */\r\nfunction WebAssemblyRecorder(stream, config) {\r\n    // based on: github.com/GoogleChromeLabs/webm-wasm\r\n\r\n    if (typeof ReadableStream === 'undefined' || typeof WritableStream === 'undefined') {\r\n        // because it fixes readable/writable streams issues\r\n        console.error('Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js');\r\n    }\r\n\r\n    config = config || {};\r\n\r\n    config.width = config.width || 640;\r\n    config.height = config.height || 480;\r\n    config.frameRate = config.frameRate || 30;\r\n    config.bitrate = config.bitrate || 1200;\r\n\r\n    function createBufferURL(buffer, type) {\r\n        return URL.createObjectURL(new Blob([buffer], {\r\n            type: type || ''\r\n        }));\r\n    }\r\n\r\n    function cameraStream() {\r\n        return new ReadableStream({\r\n            start: function(controller) {\r\n                var cvs = document.createElement('canvas');\r\n                var video = document.createElement('video');\r\n                video.srcObject = stream;\r\n                video.onplaying = function() {\r\n                    cvs.width = config.width;\r\n                    cvs.height = config.height;\r\n                    var ctx = cvs.getContext('2d');\r\n                    var frameTimeout = 1000 / config.frameRate;\r\n                    setTimeout(function f() {\r\n                        ctx.drawImage(video, 0, 0);\r\n                        controller.enqueue(\r\n                            ctx.getImageData(0, 0, config.width, config.height)\r\n                        );\r\n                        setTimeout(f, frameTimeout);\r\n                    }, frameTimeout);\r\n                };\r\n                video.play();\r\n            }\r\n        });\r\n    }\r\n\r\n    var worker;\r\n\r\n    function startRecording(stream, buffer) {\r\n        if (!config.workerPath && !buffer) {\r\n            // is it safe to use @latest ?\r\n            fetch(\r\n                'https://unpkg.com/webm-wasm@latest/dist/webm-worker.js'\r\n            ).then(function(r) {\r\n                r.arrayBuffer().then(function(buffer) {\r\n                    startRecording(stream, buffer);\r\n                });\r\n            });\r\n            return;\r\n        }\r\n\r\n        if (!config.workerPath && buffer instanceof ArrayBuffer) {\r\n            var blob = new Blob([buffer], {\r\n                type: 'text/javascript'\r\n            });\r\n            config.workerPath = URL.createObjectURL(blob);\r\n        }\r\n\r\n        if (!config.workerPath) {\r\n            console.error('workerPath parameter is missing.');\r\n        }\r\n\r\n        worker = new Worker(config.workerPath);\r\n\r\n        worker.postMessage(config.webAssemblyPath || 'https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm');\r\n        worker.addEventListener('message', function(event) {\r\n            if (event.data === 'READY') {\r\n                worker.postMessage({\r\n                    width: config.width,\r\n                    height: config.height,\r\n                    bitrate: config.bitrate || 1200,\r\n                    timebaseDen: config.frameRate || 30,\r\n                    realtime: true\r\n                });\r\n\r\n                cameraStream().pipeTo(new WritableStream({\r\n                    write: function(image) {\r\n                        if (!worker) {\r\n                            return;\r\n                        }\r\n\r\n                        worker.postMessage(image.data.buffer, [image.data.buffer]);\r\n                    }\r\n                }));\r\n            } else if (!!event.data) {\r\n                if (!isPaused) {\r\n                    arrayOfBuffers.push(event.data);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This method records video.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        arrayOfBuffers = [];\r\n        isPaused = false;\r\n        this.blob = null;\r\n        startRecording(stream);\r\n\r\n        if (typeof config.initCallback === 'function') {\r\n            config.initCallback();\r\n        }\r\n    };\r\n\r\n    var isPaused;\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        isPaused = true;\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        isPaused = false;\r\n    };\r\n\r\n    function terminate() {\r\n        if (!worker) {\r\n            return;\r\n        }\r\n\r\n        worker.postMessage(null);\r\n        worker.terminate();\r\n        worker = null;\r\n    }\r\n\r\n    var arrayOfBuffers = [];\r\n\r\n    /**\r\n     * This method stops recording video.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        terminate();\r\n\r\n        this.blob = new Blob(arrayOfBuffers, {\r\n            type: 'video/webm'\r\n        });\r\n\r\n        callback(this.blob);\r\n    };\r\n\r\n    // for debugging\r\n    this.name = 'WebAssemblyRecorder';\r\n    this.toString = function() {\r\n        return this.name;\r\n    };\r\n\r\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */\r\n    this.clearRecordedData = function() {\r\n        arrayOfBuffers = [];\r\n        isPaused = false;\r\n        this.blob = null;\r\n\r\n        // todo: if recording-ON then STOP it first\r\n    };\r\n\r\n    /**\r\n     * @property {Blob} blob - The recorded blob object.\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.stop(function(){\r\n     *     var blob = recorder.blob;\r\n     * });\r\n     */\r\n    this.blob = null;\r\n}\r\n\r\nif (typeof RecordRTC !== 'undefined') {\r\n    RecordRTC.WebAssemblyRecorder = WebAssemblyRecorder;\r\n}\n","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)(_react.default.createElement(_react.default.Fragment, null, _react.default.createElement(\"path\", {\n  fill: \"none\",\n  d: \"M0 0h24v24H0z\"\n}), _react.default.createElement(\"path\", {\n  d: \"M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z\"\n})), 'People');\n\nexports.default = _default;","import pathToRegexp from \"path-to-regexp\";\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compileGenerator = function compileGenerator(pattern) {\n  var cacheKey = pattern;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  var compiledGenerator = pathToRegexp.compile(pattern);\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledGenerator;\n    cacheCount++;\n  }\n\n  return compiledGenerator;\n};\n\n/**\n * Public API for generating a URL pathname from a pattern and parameters.\n */\nvar generatePath = function generatePath() {\n  var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (pattern === \"/\") {\n    return pattern;\n  }\n  var generator = compileGenerator(pattern);\n  return generator(params, { pretty: true });\n};\n\nexport default generatePath;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"warning\";\nimport invariant from \"invariant\";\nimport { createLocation, locationsAreEqual } from \"history\";\nimport generatePath from \"./generatePath\";\n\n/**\n * The public API for updating the location programmatically\n * with a component.\n */\n\nvar Redirect = function (_React$Component) {\n  _inherits(Redirect, _React$Component);\n\n  function Redirect() {\n    _classCallCheck(this, Redirect);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Redirect.prototype.isStatic = function isStatic() {\n    return this.context.router && this.context.router.staticContext;\n  };\n\n  Redirect.prototype.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, \"You should not use <Redirect> outside a <Router>\");\n\n    if (this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var prevTo = createLocation(prevProps.to);\n    var nextTo = createLocation(this.props.to);\n\n    if (locationsAreEqual(prevTo, nextTo)) {\n      warning(false, \"You tried to redirect to the same route you're currently on: \" + (\"\\\"\" + nextTo.pathname + nextTo.search + \"\\\"\"));\n      return;\n    }\n\n    this.perform();\n  };\n\n  Redirect.prototype.computeTo = function computeTo(_ref) {\n    var computedMatch = _ref.computedMatch,\n        to = _ref.to;\n\n    if (computedMatch) {\n      if (typeof to === \"string\") {\n        return generatePath(to, computedMatch.params);\n      } else {\n        return _extends({}, to, {\n          pathname: generatePath(to.pathname, computedMatch.params)\n        });\n      }\n    }\n\n    return to;\n  };\n\n  Redirect.prototype.perform = function perform() {\n    var history = this.context.router.history;\n    var push = this.props.push;\n\n    var to = this.computeTo(this.props);\n\n    if (push) {\n      history.push(to);\n    } else {\n      history.replace(to);\n    }\n  };\n\n  Redirect.prototype.render = function render() {\n    return null;\n  };\n\n  return Redirect;\n}(React.Component);\n\nRedirect.propTypes = {\n  computedMatch: PropTypes.object, // private, from <Switch>\n  push: PropTypes.bool,\n  from: PropTypes.string,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired\n};\nRedirect.defaultProps = {\n  push: false\n};\nRedirect.contextTypes = {\n  router: PropTypes.shape({\n    history: PropTypes.shape({\n      push: PropTypes.func.isRequired,\n      replace: PropTypes.func.isRequired\n    }).isRequired,\n    staticContext: PropTypes.object\n  }).isRequired\n};\n\n\nexport default Redirect;","// Written in this round about way for babel-transform-imports\nimport Redirect from \"react-router/es/Redirect\";\n\nexport default Redirect;"],"sourceRoot":""}